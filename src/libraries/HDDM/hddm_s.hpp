/*
 * hddm_s.hpp - DO NOT EDIT THIS FILE
 *
 * This file was generated automatically by hddm-cpp from the file
 * libraries/HDDM/event.xml

 * This header file defines the c++ classes that hold the data
 * described in the data model (from libraries/HDDM/event.xml). 
 *
 * The hddm data model tool set was written by
 * Richard Jones, University of Connecticut.
 *
 * For more information see the following web site
 *
 * http://zeus.phys.uconn.edu/halld/datamodel/doc
 *
 */

#ifndef SAW_s_HDDM
#define SAW_s_HDDM

#include <list>
#include <deque>
#include <vector>
#include <string>
#include <atomic>
#include <sstream>
#include <stdexcept>
#include <streambuf>
#include <xstream/z.h>
#include <xstream/bz.h>
#include <xstream/xdr.h>
#include <xstream/digest.h>
#include <particleType.h>
#include <pthread.h>
#include <assert.h>

#define MY_SETUP thread_private_data *my_private = lookup_private_data();
#define MY(VAR) my_private->m_ ## VAR

namespace hddm_s {

const int k_default_status = 0x0;
const int k_bits_compression = 0xf0;
const int k_no_compression = 0x00;
const int k_z_compression = 0x10;
const int k_bz2_compression = 0x20;
const int k_bits_integrity = 0x0f;
const int k_no_integrity = 0x00;
const int k_crc32_integrity = 0x01;
const int k_bits_randomaccess = 0xf00;
const int k_can_reposition = 0x100;

enum hddm_type {
   k_hddm_unknown,
   k_hddm_int,
   k_hddm_long,
   k_hddm_float,
   k_hddm_double,
   k_hddm_boolean,
   k_hddm_string,
   k_hddm_anyURI,
   k_hddm_Particle_t
};

class HDDM;
class istream;
class ostream;

class streamable {
 public:
   virtual ~streamable() {}
   virtual void streamer(istream &istr) {}
   virtual void streamer(ostream &ostr) {}
};

class streamposition {
 public:
   uint64_t block_start;
   uint32_t block_offset;
   uint32_t block_status;
   streamposition();
   streamposition(uint64_t start, uint32_t offset, uint32_t status);
   bool operator==(const streamposition src) const {
      return (block_start == src.block_start &&
              block_offset == src.block_offset &&
              block_status == src.block_status);
   }
   bool operator!=(const streamposition src) const {
      return !(*this == src);
   }
   bool operator>(const streamposition src) const {
      return (block_start > src.block_start ||
              (block_start == src.block_start &&
               block_offset > src.block_offset));
   }
   bool operator>=(const streamposition src) const {
      return (*this > src || *this == src);
   }
   bool operator<(const streamposition src) const {
      return !(*this >= src);
   }
   bool operator<=(const streamposition src) const {
      return !(*this > src);
   }
};

class threads {
 public:
   static thread_local int ID;
   static int getID() {
      // protected access to the ID tls data member
      if (ID == 0) {
         if (ID >= max_threads) {
            throw std::runtime_error("hddm_s::threads::getID - "
                                     "thread count exceeds max_threads");
         }
         ID = ++next_unique_ID;
      }
      return ID;
   }
   static const int max_threads = 999;
 protected:
   static std::atomic<int> next_unique_ID;
};

class istreambuffer : public std::streambuf {
 public:
   istreambuffer(char* buffer, std::streamsize bufferLength) {
      setg(buffer, buffer, buffer + bufferLength);
   }

   std::streampos tellg() {
      return gptr() - eback();
   }

   void seekg(std::streampos pos) {
      reset();
      gbump(pos);
   }

   int size() {
      return egptr() - gptr();
   }

   void reset() {
      char *gbegin = eback();
      char *gend = egptr();
      setg(gbegin, gbegin, gend);
   }

   char *getbuf() {
      return eback();
   }
};

class ostreambuffer : public std::streambuf {
 public:
   ostreambuffer(char* buffer, std::streamsize bufferLength) {
      setp(buffer, buffer + bufferLength);
   }

   std::streampos tellp() {
      return pptr() - pbase();
   }

   void seekp(std::streampos pos) {
      reset();
      pbump(pos);
   }

   int size() {
      return pptr() - pbase();
   }

   void reset() {
      char *pbegin = pbase();
      char *pend = epptr();
      setp(pbegin, pend);
   }

   char *getbuf() {
      return pbase();
   }
};

class ostream {
 public:
   ostream(std::ostream &src);
   ~ostream();
   ostream &operator<<(HDDM &record);
   int getCompression() const;
   void setCompression(int flags);
   int getIntegrityChecks() const;
   void setIntegrityChecks(int flags);
   streamposition getPosition();
   int getBytesWritten() const;
   int getRecordsWritten() const;
 //protected:
   xstream::xdr::ostream *getXDRostream() {
      return my_thread_private[threads::ID]->m_xstr;
   }
   ostream &operator<<(streamable &object);
 private:
   void configure_streambufs();
   void update_streambufs();
   void lock_streambufs();
   void unlock_streambufs();
   std::ostream &m_ostr;
   std::atomic<int> m_status_bits;
   pthread_mutex_t m_streambuf_mutex;

   typedef struct {
      xstream::xdr::ostream *m_xstr;
      std::ostream *m_ostr;
      ostreambuffer *m_sbuf;
      std::streambuf *m_xcmp;
      char *m_event_buffer;
      int m_event_buffer_size;
      std::streampos m_last_start;
      std::streamoff m_last_offset;
      int m_status_bits;
      int m_mutex_lock;
      int m_bytes_written;
      int m_records_written;
   } thread_private_data;

   thread_private_data *my_thread_private[threads::max_threads];
   thread_private_data *lookup_private_data();
   void init_private_data();
};

class codon {
 public:
   codon(): m_order(0) {}
   int m_order;
   std::string m_tagname;
   std::vector<codon> m_sequence;
   std::deque<streamable*> m_target;
};

typedef std::vector<codon> chromosome;

class istream {
 public:
   istream(std::istream &src);
   ~istream();
   istream &operator>>(HDDM &record);
   void skip(int count);
   int getCompression() const;
   int getIntegrityChecks() const;
   streamposition getPosition();
   void setPosition(const streamposition &pos);
   int getBytesRead() const;
   int getRecordsRead() const;
   bool eof();
   bool operator!();
   operator void*();
 //protected:
   void reset_sequencer();
   void sequencer(streamable &object);
   istream &operator>>(streamable &object);
   xstream::xdr::istream *getXDRistream() {
      return my_thread_private[threads::ID]->m_xstr;
   }

 private:
   std::string m_documentString;
   chromosome synthesize(const std::string &src, int p_src,
                         const std::string &ref, int p_ref);
   int getTag(const std::string &src, int p_src, std::string &tag, int &level);
   int getEndTag(const std::string &src, int p_src, const std::string &tag);
   void collide(const std::string &itag, const std::string &rtag);
   void configure_streambufs();
   void update_streambufs();
   void lock_streambufs();
   void unlock_streambufs();
   std::istream &m_istr;
   std::atomic<int> m_status_bits;
   pthread_mutex_t m_streambuf_mutex;
   int m_leftovers[100];

   typedef struct {
      codon m_genome;
      codon *m_codon;
      int m_sequencing;
      xstream::xdr::istream *m_xstr;
      std::istream *m_istr;
      istreambuffer *m_sbuf;
      std::streambuf *m_xcmp;
      int m_events_to_skip;
      char *m_event_buffer;
      int m_event_buffer_size;
      int m_event_size;
      std::streampos m_last_start;
      std::streamoff m_last_offset;
      std::streamoff m_next_start;
      int m_status_bits;
      int m_mutex_lock;
      int m_bytes_read;
      int m_records_read;
      bool m_hit_eof;
   } thread_private_data;

   thread_private_data *my_thread_private[threads::max_threads];
   thread_private_data *lookup_private_data();
   void init_private_data();
};

template <class T> class HDDM_ElementList;

class HDDM_Element: public streamable {
 public:
   ~HDDM_Element() {}
   virtual const void *getAttribute(const std::string &name,
                                    hddm_type *atype=0) const {
      return 0;
   }
   virtual std::string toString(int indent=0) {
      return "bad apple";
   }
   virtual std::string toXML(int indent=0) {
      return "<!--bad apple-->";
   }
   friend class HDDM_ElementList<HDDM_Element>;
 protected:
   HDDM_Element() : m_parent(0), m_host(0) {}
   HDDM_Element(HDDM_Element *parent)
    : m_parent(parent),
      m_host(parent->m_host)
    {}
   HDDM_Element(HDDM_Element &src)
    : m_parent(src.m_parent),
      m_host(src.m_host)
   {}
   HDDM_Element *m_parent;
   HDDM *m_host;
};

template <class T>
class HDDM_ElementList: public streamable {
 public:
   HDDM_ElementList(typename std::list<T*> *plist,
                    typename std::list<T*>::iterator begin,
                    typename std::list<T*>::iterator end,
                    HDDM_Element *parent=0)
    : m_host_plist(plist),
      m_first_iter(begin),
      m_last_iter(end),
      m_parent(parent)
   {
      for (m_size = 0; begin != end; ++m_size, ++begin) {}
      if (m_size) {
         --m_last_iter;
      }
   }

   HDDM_ElementList(const HDDM_ElementList<T> &src)
    : m_host_plist(src.m_host_plist),
      m_first_iter(src.m_first_iter),
      m_last_iter(src.m_last_iter),
      m_parent(0),
      m_size(src.m_size)
   {}

   bool empty() const { return (m_size == 0); }
   int size() const { return m_size; }
   T &front() const { return *m_first_iter; }
   T &back() const { return *m_last_iter; }
   T &operator()() { return *m_first_iter; }
   T &operator()(int index) {
      if (index == 0) {
         return *m_first_iter;
      }
      else if (index == -1) {
         return *m_last_iter;
      }
      else if (index > 0) {
         return *(m_first_iter + index);
      }
      else {
         return *(m_last_iter + (++index));
      }
   }

   class iterator: public std::list<T*>::iterator {
    public:
      iterator() {}
      iterator(typename std::list<T*>::iterator src)
       : std::list<T*>::iterator(src) {}

      T *operator->() const { 
         return *(typename std::list<T*>::iterator)(*this);
      }

      T &operator*() const {
         return **(typename std::list<T*>::iterator)(*this);
      }

      iterator operator+=(int offset) {
         if (offset > 0) {
            for (int i=0; i<offset; ++i, ++(*this)) {}
         }
         else if (offset < 0) {
            for (int i=0; i>offset; --i, --(*this)) {}
         }
         return *this;
      }

      iterator operator-=(int offset) {
         if (offset > 0) {
            for (int i=0; i<offset; ++i, --(*this)) {}
         }
         else if (offset < 0) {
            for (int i=0; i>offset; --i, ++(*this)) {}
         }
         return *this;
      }

      iterator operator+(int offset) const {
         iterator iter(*this);
         return iter += offset;
      }

      iterator operator-(int offset) const {
         iterator iter(*this);
         return iter -= offset;
      }

      int operator-(iterator iter) const {
         if (*this == iter) {
            return 0;
         }
         iterator iter2(iter);
         for (int n=1; n < m_size; ++n) {
            if (++iter == *this) {
               return n;
            }
            else if (--iter2 == *this) {
               return -n;
            }
         }
         return m_size;
      }
   };

   class const_iterator: public std::list<T*>::const_iterator {
    public:
      const_iterator() {}
      const_iterator(const typename std::list<T*>::const_iterator src)
       : std::list<T*>::const_iterator(src) {}

      const_iterator(const typename std::list<T*>::iterator src)
       : std::list<T*>::const_iterator(src) {}

      const T *operator->() const { 
         return *(typename std::list<T*>::const_iterator)(*this);
      }

      const T &operator*() const { 
         return **(typename std::list<T*>::const_iterator)(*this);
      }

      const const_iterator operator+=(int offset) {
         if (offset > 0) {
            for (int i=0; i<offset; ++i, ++(*this)) {}
         }
         else if (offset < 0) {
            for (int i=0; i>offset; --i, --(*this)) {}
         }
         return *this;
      }

      const const_iterator operator-=(int offset) {
         if (offset > 0) {
            for (int i=0; i<offset; ++i, --(*this)) {}
         }
         else if (offset > 0) {
            for (int i=0; i>offset; --i, ++(*this)) {}
         }
         return *this;
      }

      const const_iterator operator+(int offset) const {
         const_iterator iter(*this);
         return iter += offset;
      }

      const const_iterator operator-(int offset) const {
         const_iterator iter(*this);
         return iter -= offset;
      }

      int operator-(const_iterator iter) const {
         if (*this == iter) {
            return 0;
         }
         const_iterator iter2(iter);
         for (int n=1; n < m_size; ++n) {
            if (++iter == *this) {
               return n;
            }
            else if (--iter2 == *this) {
               return -n;
            }
         }
         return m_size;
      }
   };

   iterator begin() const { return m_first_iter; }
   iterator end() const { return (m_size)? m_last_iter + 1 : m_last_iter; }
   void clear() { del(); }

   HDDM_ElementList add(int count=1, int start=-1) {
      if (m_parent == 0) {
         throw std::runtime_error("HDDM_ElementList error - "
                                  "attempt to add to immutable list");
      }
      iterator it = insert(start, count);
      typename std::list<T*>::iterator iter(it);
      for (int n=0; n<count; ++n, ++iter) {
         *iter = new T(m_parent);
      }
      return HDDM_ElementList(m_host_plist, it, it+count, m_parent);
   }

   void del(int count=-1, int start=0) {
      if (m_parent == 0) {
         throw std::runtime_error("HDDM_ElementList error - "
                                  "attempt to delete from immutable list");
      }
      if (m_size == 0 || count == 0) {
         return;
      }
      iterator iter_begin(begin());
      iterator iter_end(end());
      if (start < 0) {
         iter_begin = iter_end + start;
         if (count >= 0) {
            iter_end = iter_begin + count;
         }
      }
      else {
         iter_begin += start;
         if (count >= 0) {
            iter_end = iter_begin + count;
         }
      }
      typename std::list<T*>::iterator iter;
      for (iter = iter_begin; iter != iter_end; ++iter) {
         delete *iter;
      }
      erase(start, count);
   }

   HDDM_ElementList slice(int first=0, int last=-1) {
      int n1 = (first < 0)? first + m_size : first;
      int n2 = (last < 0)? last + m_size + 1 : last + 1;
      int count = n2 - n1;
      iterator iter_begin;
      if (first > 0)
         iter_begin = begin() + first;
      else if (first < 0)
         iter_begin = end() + first;
      iterator iter_end(iter_begin + count);
      return HDDM_ElementList(m_host_plist, iter_begin, iter_end);
   }

   void streamer(istream &istr) {
      clear();
      int size;
      *istr.getXDRistream() >> size;
      if (size) {
         iterator iter = add(size).begin();
         for (int n=0; n < size; ++n, ++iter) {
            istr.sequencer(*iter);
         }
      }
      istr.reset_sequencer();
   }

   void streamer(ostream &ostr) {
      if (m_size) {
         *ostr.getXDRostream() << m_size;
         for (iterator iter = begin(); iter != end(); ++iter) {
            iter->streamer(ostr);
         }
      }
   }
   std::string toString(int indent=0) {
      std::string result;
      if (m_size) {
         for (iterator iter = begin(); iter != end(); ++iter) {
            result += iter->toString(indent);
         }
      }
      return result;
   }
   std::string toXML(int indent=0) {
      std::string result;
      if (m_size) {
         for (iterator iter = begin(); iter != end(); ++iter) {
            result += iter->toXML(indent);
         }
      }
      return result;
   }

 private:
   HDDM_ElementList() {}

   iterator insert(int start, int count) {
      if (m_size == 0) {
         if (count > 0) {
            if (m_first_iter == m_host_plist->begin()) {
               m_host_plist->insert(m_first_iter,count,(T*)0);
               m_first_iter = m_host_plist->begin();
            }
            else {
               m_host_plist->insert(m_first_iter--,count,(T*)0);
               ++m_first_iter;
            }
            --m_last_iter;
            m_size = count;
         }
         return m_first_iter;
      }
      else if (start == 0) {
         if (count > 0) {
            if (m_first_iter == m_host_plist->begin()) {
               m_host_plist->insert(m_first_iter,count,(T*)0);
               m_first_iter = m_host_plist->begin();
            }
            else {
               m_host_plist->insert(m_first_iter--,count,(T*)0);
               ++m_first_iter;
            }
            m_size += count;
         }
         return m_first_iter;
      }
      else if (start == -1) {
         if (count > 0) {
            iterator pos(m_last_iter);
            m_host_plist->insert(++m_last_iter,count,(T*)0);
            --m_last_iter;
            m_size += count;
            return ++pos;
         }
         return m_last_iter;
      }
      else if (start > 0) {
         if (count > 0) {
            iterator pos(m_first_iter);
            iterator pos2(pos += start-1);
            m_host_plist->insert(++pos,count,(T*)0);
            if (m_last_iter == pos2) {
               m_last_iter = --pos;
            }
            m_size += count;
            return ++pos2;
         }
         return m_first_iter + start;
      }
      else {
         if (count > 0) {
            iterator pos(m_last_iter);
            iterator pos2(pos += start+1);
            m_host_plist->insert(++pos,count,(T*)0);
            m_size += count;
            return ++pos2;
         }
         return m_last_iter + (start+1);
      }
   }

   iterator erase(int start, int count) {
      start = (start < 0)? start + m_size :
              (start < m_size)? start : m_size;
      count = (count == -1)? m_size - start : count;
      assert(start >= 0 && count > 0 && start + count <= m_size);
      if (count == m_size) {
         m_first_iter = m_host_plist->erase(m_first_iter,++m_last_iter);
         m_last_iter = m_first_iter;
         m_size = 0;
         return m_first_iter;
      }
      else if (start > 0 && count + start == m_size) {
         iterator pos(m_first_iter + start);
         m_last_iter = m_host_plist->erase(pos,pos+count);
         iterator pos2(m_last_iter);
         if (m_last_iter != m_first_iter) {
            --m_last_iter;
         }
         m_size -= count;
         return pos2;
      }
      else if (start == 0) {
         iterator pos(m_first_iter);
         m_first_iter = m_host_plist->erase(pos,pos+count);
         m_size -= count;
         return m_first_iter;
      }
      else {
         iterator pos(m_first_iter + start);
         iterator pos2 = m_host_plist->erase(pos,pos+count);
         m_size -= count;
         return pos2;
      }
   }

 protected:
   std::list<T*> *m_host_plist;
   iterator m_first_iter;
   iterator m_last_iter;
   HDDM_Element *m_parent;
   int m_size;
};

template <class T>
class HDDM_ElementLink: public HDDM_ElementList<T> {
 public:
   HDDM_ElementLink(typename std::list<T*> *plist,
                    typename std::list<T*>::iterator begin,
                    typename std::list<T*>::iterator end,
                    HDDM_Element *parent)
    : HDDM_ElementList<T>(plist,begin,end,parent)
   {}
   HDDM_ElementLink(const HDDM_ElementList<T> &src)
    : HDDM_ElementList<T>(src)
   {}

   void streamer(istream &istr) {
      HDDM_ElementList<T>::clear();
      HDDM_ElementList<T>::add().begin()->streamer(istr);
   }

   void streamer(ostream &ostr) {
      if (HDDM_ElementList<T>::m_size) {
         HDDM_ElementList<T>::begin()->streamer(ostr);
      }
   }

 protected:
   HDDM_ElementLink() {}
};

class Geometry: public HDDM_Element {
 public:
   ~Geometry();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getMaxOccurs() const;
   std::string getMd5reconstruction() const;
   void setMd5reconstruction(const std::string &md5reconstruction);
   std::string getMd5simulation() const;
   void setMd5simulation(const std::string &md5simulation);
   std::string getMd5smear() const;
   void setMd5smear(const std::string &md5smear);
   int getMinOccurs() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Geometry>;
   friend class HDDM_ElementLink<Geometry>;
 private:
   Geometry(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   std::string m_md5reconstruction;
   std::string m_md5simulation;
   std::string m_md5smear;
};

typedef HDDM_ElementList<Geometry> GeometryList;
typedef HDDM_ElementLink<Geometry> GeometryLink;

class DataVersionString: public HDDM_Element {
 public:
   ~DataVersionString();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   std::string getText() const;
   void setText(const std::string &text);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<DataVersionString>;
   friend class HDDM_ElementLink<DataVersionString>;
 private:
   DataVersionString(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   std::string m_text;
};

typedef HDDM_ElementList<DataVersionString> DataVersionStringList;
typedef HDDM_ElementLink<DataVersionString> DataVersionStringLink;

class CcdbContext: public HDDM_Element {
 public:
   ~CcdbContext();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   std::string getText() const;
   void setText(const std::string &text);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CcdbContext>;
   friend class HDDM_ElementLink<CcdbContext>;
 private:
   CcdbContext(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   std::string m_text;
};

typedef HDDM_ElementList<CcdbContext> CcdbContextList;
typedef HDDM_ElementLink<CcdbContext> CcdbContextLink;

class Momentum: public HDDM_Element {
 public:
   ~Momentum();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   float getFOM() const;
   int getNdof() const;
   int getCandidateid() const;
   float getChisq() const;
   int getId() const;
   int getTrackid() const;
   int getType() const;
   float getWeight() const;
   int getDecayVertex() const;
   int getMech() const;
   int getParentid() const;
   int getPdgtype() const;
   float getE() const;
   void setE(float E);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Momentum>;
   friend class HDDM_ElementLink<Momentum>;
 private:
   Momentum(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_px;
   float m_py;
   float m_pz;
};

typedef HDDM_ElementList<Momentum> MomentumList;
typedef HDDM_ElementLink<Momentum> MomentumLink;

class Polarization: public HDDM_Element {
 public:
   ~Polarization();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getType() const;
   float getWeight() const;
   int getDecayVertex() const;
   int getId() const;
   int getMech() const;
   int getParentid() const;
   int getPdgtype() const;
   float getPx() const;
   void setPx(float Px);
   float getPy() const;
   void setPy(float Py);
   float getPz() const;
   void setPz(float Pz);
   int getMinOccurs() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Polarization>;
   friend class HDDM_ElementLink<Polarization>;
 private:
   Polarization(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_Px;
   float m_Py;
   float m_Pz;
};

typedef HDDM_ElementList<Polarization> PolarizationList;
typedef HDDM_ElementLink<Polarization> PolarizationLink;

class Properties: public HDDM_Element {
 public:
   ~Properties();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   float getFOM() const;
   int getNdof() const;
   int getCandidateid() const;
   float getChisq() const;
   int getId() const;
   int getTrackid() const;
   int getType() const;
   float getWeight() const;
   int getDecayVertex() const;
   int getMech() const;
   int getParentid() const;
   int getPdgtype() const;
   int getCharge() const;
   void setCharge(int charge);
   float getMass() const;
   void setMass(float mass);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Properties>;
   friend class HDDM_ElementLink<Properties>;
 private:
   Properties(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_charge;
   float m_mass;
};

typedef HDDM_ElementList<Properties> PropertiesList;
typedef HDDM_ElementLink<Properties> PropertiesLink;

class Beam: public HDDM_Element {
 public:
   ~Beam();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   float getWeight() const;
   int getMinOccurs() const;
   Particle_t getType() const;
   void setType(Particle_t type);
   Momentum &getMomentum();
   MomentumList &getMomenta();
   MomentumList addMomenta(int count=1, int start=-1);
   void deleteMomenta(int count=-1, int start=0);
   Polarization &getPolarization();
   PolarizationList &getPolarizations();
   PolarizationList addPolarizations(int count=1, int start=-1);
   void deletePolarizations(int count=-1, int start=0);
   Properties &getProperties();
   PropertiesList &getPropertiesList();
   PropertiesList addPropertiesList(int count=1, int start=-1);
   void deletePropertiesList(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Beam>;
   friend class HDDM_ElementLink<Beam>;
 private:
   Beam(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_type;
   MomentumLink m_momentum_link;
   PolarizationLink m_polarization_link;
   PropertiesLink m_properties_link;
};

typedef HDDM_ElementList<Beam> BeamList;
typedef HDDM_ElementLink<Beam> BeamLink;

class Target: public HDDM_Element {
 public:
   ~Target();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   float getWeight() const;
   int getMinOccurs() const;
   Particle_t getType() const;
   void setType(Particle_t type);
   Momentum &getMomentum();
   MomentumList &getMomenta();
   MomentumList addMomenta(int count=1, int start=-1);
   void deleteMomenta(int count=-1, int start=0);
   Polarization &getPolarization();
   PolarizationList &getPolarizations();
   PolarizationList addPolarizations(int count=1, int start=-1);
   void deletePolarizations(int count=-1, int start=0);
   Properties &getProperties();
   PropertiesList &getPropertiesList();
   PropertiesList addPropertiesList(int count=1, int start=-1);
   void deletePropertiesList(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Target>;
   friend class HDDM_ElementLink<Target>;
 private:
   Target(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_type;
   MomentumLink m_momentum_link;
   PolarizationLink m_polarization_link;
   PropertiesLink m_properties_link;
};

typedef HDDM_ElementList<Target> TargetList;
typedef HDDM_ElementLink<Target> TargetLink;

class Product: public HDDM_Element {
 public:
   ~Product();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   float getWeight() const;
   int getDecayVertex() const;
   void setDecayVertex(int decayVertex);
   int getId() const;
   void setId(int id);
   std::string getMaxOccurs() const;
   int getMech() const;
   void setMech(int mech);
   int getParentid() const;
   void setParentid(int parentid);
   int getPdgtype() const;
   void setPdgtype(int pdgtype);
   Particle_t getType() const;
   void setType(Particle_t type);
   Momentum &getMomentum();
   MomentumList &getMomenta();
   MomentumList addMomenta(int count=1, int start=-1);
   void deleteMomenta(int count=-1, int start=0);
   Polarization &getPolarization();
   PolarizationList &getPolarizations();
   PolarizationList addPolarizations(int count=1, int start=-1);
   void deletePolarizations(int count=-1, int start=0);
   Properties &getProperties();
   PropertiesList &getPropertiesList();
   PropertiesList addPropertiesList(int count=1, int start=-1);
   void deletePropertiesList(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Product>;
   friend class HDDM_ElementLink<Product>;
 private:
   Product(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_decayVertex;
   int m_id;
   int m_mech;
   int m_parentid;
   int m_pdgtype;
   int m_type;
   MomentumLink m_momentum_link;
   PolarizationLink m_polarization_link;
   PropertiesLink m_properties_link;
};

typedef HDDM_ElementList<Product> ProductList;
typedef HDDM_ElementLink<Product> ProductLink;

class Origin: public HDDM_Element {
 public:
   ~Origin();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   float getFOM() const;
   int getNdof() const;
   int getCandidateid() const;
   float getChisq() const;
   int getId() const;
   int getTrackid() const;
   int getType() const;
   float getWeight() const;
   float getT() const;
   void setT(float t);
   float getVx() const;
   void setVx(float vx);
   float getVy() const;
   void setVy(float vy);
   float getVz() const;
   void setVz(float vz);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Origin>;
   friend class HDDM_ElementLink<Origin>;
 private:
   Origin(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_t;
   float m_vx;
   float m_vy;
   float m_vz;
};

typedef HDDM_ElementList<Origin> OriginList;
typedef HDDM_ElementLink<Origin> OriginLink;

class Vertex: public HDDM_Element {
 public:
   ~Vertex();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getType() const;
   float getWeight() const;
   std::string getMaxOccurs() const;
   Product &getProduct(int index=0);
   ProductList &getProducts();
   ProductList addProducts(int count=1, int start=-1);
   void deleteProducts(int count=-1, int start=0);
   Origin &getOrigin();
   OriginList &getOrigins();
   OriginList addOrigins(int count=1, int start=-1);
   void deleteOrigins(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Vertex>;
   friend class HDDM_ElementLink<Vertex>;
 private:
   Vertex(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   ProductList m_product_list;
   OriginLink m_origin_link;
};

typedef HDDM_ElementList<Vertex> VertexList;
typedef HDDM_ElementLink<Vertex> VertexLink;

class Random: public HDDM_Element {
 public:
   ~Random();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getType() const;
   float getWeight() const;
   int getMaxOccurs() const;
   int getMinOccurs() const;
   int getSeed1() const;
   void setSeed1(int seed1);
   int getSeed2() const;
   void setSeed2(int seed2);
   int getSeed3() const;
   void setSeed3(int seed3);
   int getSeed4() const;
   void setSeed4(int seed4);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Random>;
   friend class HDDM_ElementLink<Random>;
 private:
   Random(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_seed1;
   int m_seed2;
   int m_seed3;
   int m_seed4;
};

typedef HDDM_ElementList<Random> RandomList;
typedef HDDM_ElementLink<Random> RandomLink;

class UserDataFloat: public HDDM_Element {
 public:
   ~UserDataFloat();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getType() const;
   float getWeight() const;
   std::string getDescription() const;
   float getData() const;
   void setData(float data);
   std::string getMaxOccurs() const;
   std::string getMeaning() const;
   void setMeaning(const std::string &meaning);
   int getMinOccurs() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<UserDataFloat>;
   friend class HDDM_ElementLink<UserDataFloat>;
 private:
   UserDataFloat(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_data;
   std::string m_meaning;
};

typedef HDDM_ElementList<UserDataFloat> UserDataFloatList;
typedef HDDM_ElementLink<UserDataFloat> UserDataFloatLink;

class UserDataInt: public HDDM_Element {
 public:
   ~UserDataInt();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getType() const;
   float getWeight() const;
   std::string getDescription() const;
   int getData() const;
   void setData(int data);
   std::string getMaxOccurs() const;
   std::string getMeaning() const;
   void setMeaning(const std::string &meaning);
   int getMinOccurs() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<UserDataInt>;
   friend class HDDM_ElementLink<UserDataInt>;
 private:
   UserDataInt(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_data;
   std::string m_meaning;
};

typedef HDDM_ElementList<UserDataInt> UserDataIntList;
typedef HDDM_ElementLink<UserDataInt> UserDataIntLink;

class UserData: public HDDM_Element {
 public:
   ~UserData();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getType() const;
   float getWeight() const;
   std::string getDescription() const;
   void setDescription(const std::string &description);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   UserDataFloat &getUserDataFloat(int index=0);
   UserDataFloatList &getUserDataFloats();
   UserDataFloatList addUserDataFloats(int count=1, int start=-1);
   void deleteUserDataFloats(int count=-1, int start=0);
   UserDataInt &getUserDataInt(int index=0);
   UserDataIntList &getUserDataInts();
   UserDataIntList addUserDataInts(int count=1, int start=-1);
   void deleteUserDataInts(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<UserData>;
   friend class HDDM_ElementLink<UserData>;
 private:
   UserData(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   std::string m_description;
   UserDataFloatList m_userDataFloat_list;
   UserDataIntList m_userDataInt_list;
};

typedef HDDM_ElementList<UserData> UserDataList;
typedef HDDM_ElementLink<UserData> UserDataLink;

class Reaction: public HDDM_Element {
 public:
   ~Reaction();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getType() const;
   void setType(int type);
   float getWeight() const;
   void setWeight(float weight);
   Beam &getBeam();
   BeamList &getBeams();
   BeamList addBeams(int count=1, int start=-1);
   void deleteBeams(int count=-1, int start=0);
   Target &getTarget();
   TargetList &getTargets();
   TargetList addTargets(int count=1, int start=-1);
   void deleteTargets(int count=-1, int start=0);
   Vertex &getVertex(int index=0);
   VertexList &getVertices();
   VertexList addVertices(int count=1, int start=-1);
   void deleteVertices(int count=-1, int start=0);
   Random &getRandom();
   RandomList &getRandoms();
   RandomList addRandoms(int count=1, int start=-1);
   void deleteRandoms(int count=-1, int start=0);
   UserData &getUserData(int index=0);
   UserDataList &getUserDatas();
   UserDataList addUserDatas(int count=1, int start=-1);
   void deleteUserDatas(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Reaction>;
   friend class HDDM_ElementLink<Reaction>;
 private:
   Reaction(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_type;
   float m_weight;
   BeamLink m_beam_link;
   TargetLink m_target_link;
   VertexList m_vertex_list;
   RandomLink m_random_link;
   UserDataList m_userData_list;
};

typedef HDDM_ElementList<Reaction> ReactionList;
typedef HDDM_ElementLink<Reaction> ReactionLink;

class CdcDigihit: public HDDM_Element {
 public:
   ~CdcDigihit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getRing() const;
   int getStraw() const;
   float getQ() const;
   float getT() const;
   int getMinOccurs() const;
   float getPeakAmp() const;
   void setPeakAmp(float peakAmp);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CdcDigihit>;
   friend class HDDM_ElementLink<CdcDigihit>;
 private:
   CdcDigihit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_peakAmp;
};

typedef HDDM_ElementList<CdcDigihit> CdcDigihitList;
typedef HDDM_ElementLink<CdcDigihit> CdcDigihitLink;

class CdcHitQF: public HDDM_Element {
 public:
   ~CdcHitQF();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getRing() const;
   int getStraw() const;
   float getQ() const;
   float getT() const;
   float getQF() const;
   void setQF(float QF);
   int getMinOccurs() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CdcHitQF>;
   friend class HDDM_ElementLink<CdcHitQF>;
 private:
   CdcHitQF(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_QF;
};

typedef HDDM_ElementList<CdcHitQF> CdcHitQFList;
typedef HDDM_ElementLink<CdcHitQF> CdcHitQFLink;

class CdcStrawHit: public HDDM_Element {
 public:
   ~CdcStrawHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getRing() const;
   int getStraw() const;
   std::string getMaxOccurs() const;
   float getQ() const;
   void setQ(float q);
   float getT() const;
   void setT(float t);
   CdcDigihit &getCdcDigihit();
   CdcDigihitList &getCdcDigihits();
   CdcDigihitList addCdcDigihits(int count=1, int start=-1);
   void deleteCdcDigihits(int count=-1, int start=0);
   CdcHitQF &getCdcHitQF();
   CdcHitQFList &getCdcHitQFs();
   CdcHitQFList addCdcHitQFs(int count=1, int start=-1);
   void deleteCdcHitQFs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CdcStrawHit>;
   friend class HDDM_ElementLink<CdcStrawHit>;
 private:
   CdcStrawHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_q;
   float m_t;
   CdcDigihitLink m_cdcDigihit_link;
   CdcHitQFLink m_cdcHitQF_link;
};

typedef HDDM_ElementList<CdcStrawHit> CdcStrawHitList;
typedef HDDM_ElementLink<CdcStrawHit> CdcStrawHitLink;

class CdcStrawTruthHit: public HDDM_Element {
 public:
   ~CdcStrawTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getRing() const;
   int getStraw() const;
   float getD() const;
   void setD(float d);
   int getItrack() const;
   void setItrack(int itrack);
   std::string getMaxOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getQ() const;
   void setQ(float q);
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CdcStrawTruthHit>;
   friend class HDDM_ElementLink<CdcStrawTruthHit>;
 private:
   CdcStrawTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_d;
   int m_itrack;
   int m_ptype;
   float m_q;
   float m_t;
};

typedef HDDM_ElementList<CdcStrawTruthHit> CdcStrawTruthHitList;
typedef HDDM_ElementLink<CdcStrawTruthHit> CdcStrawTruthHitLink;

class CdcStraw: public HDDM_Element {
 public:
   ~CdcStraw();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getRing() const;
   void setRing(int ring);
   int getStraw() const;
   void setStraw(int straw);
   CdcStrawHit &getCdcStrawHit(int index=0);
   CdcStrawHitList &getCdcStrawHits();
   CdcStrawHitList addCdcStrawHits(int count=1, int start=-1);
   void deleteCdcStrawHits(int count=-1, int start=0);
   CdcStrawTruthHit &getCdcStrawTruthHit(int index=0);
   CdcStrawTruthHitList &getCdcStrawTruthHits();
   CdcStrawTruthHitList addCdcStrawTruthHits(int count=1, int start=-1);
   void deleteCdcStrawTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CdcStraw>;
   friend class HDDM_ElementLink<CdcStraw>;
 private:
   CdcStraw(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_ring;
   int m_straw;
   CdcStrawHitList m_cdcStrawHit_list;
   CdcStrawTruthHitList m_cdcStrawTruthHit_list;
};

typedef HDDM_ElementList<CdcStraw> CdcStrawList;
typedef HDDM_ElementLink<CdcStraw> CdcStrawLink;

class TrackID: public HDDM_Element {
 public:
   ~TrackID();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   float getE() const;
   bool getPrimary() const;
   int getPtype() const;
   float getPx() const;
   float getPy() const;
   float getPz() const;
   float getT() const;
   int getTrack() const;
   float getX() const;
   float getY() const;
   float getZ() const;
   float getDEdx() const;
   float getPhi() const;
   float getR() const;
   int getArm() const;
   int getModule() const;
   int getColumn() const;
   int getSector() const;
   int getLayer() const;
   float getDradius() const;
   int getItrack() const;
   void setItrack(int itrack);
   int getMinOccurs() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TrackID>;
   friend class HDDM_ElementLink<TrackID>;
 private:
   TrackID(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_itrack;
};

typedef HDDM_ElementList<TrackID> TrackIDList;
typedef HDDM_ElementLink<TrackID> TrackIDLink;

class CdcTruthPoint: public HDDM_Element {
 public:
   ~CdcTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getDEdx() const;
   void setDEdx(float dEdx);
   float getDradius() const;
   void setDradius(float dradius);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getPhi() const;
   void setPhi(float phi);
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getR() const;
   void setR(float r);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CdcTruthPoint>;
   friend class HDDM_ElementLink<CdcTruthPoint>;
 private:
   CdcTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dEdx;
   float m_dradius;
   float m_phi;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_r;
   float m_t;
   int m_track;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<CdcTruthPoint> CdcTruthPointList;
typedef HDDM_ElementLink<CdcTruthPoint> CdcTruthPointLink;

class CentralDC: public HDDM_Element {
 public:
   ~CentralDC();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   CdcStraw &getCdcStraw(int index=0);
   CdcStrawList &getCdcStraws();
   CdcStrawList addCdcStraws(int count=1, int start=-1);
   void deleteCdcStraws(int count=-1, int start=0);
   CdcTruthPoint &getCdcTruthPoint(int index=0);
   CdcTruthPointList &getCdcTruthPoints();
   CdcTruthPointList addCdcTruthPoints(int count=1, int start=-1);
   void deleteCdcTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CentralDC>;
   friend class HDDM_ElementLink<CentralDC>;
 private:
   CentralDC(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   CdcStrawList m_cdcStraw_list;
   CdcTruthPointList m_cdcTruthPoint_list;
};

typedef HDDM_ElementList<CentralDC> CentralDCList;
typedef HDDM_ElementLink<CentralDC> CentralDCLink;

class FdcAnodeHit: public HDDM_Element {
 public:
   ~FdcAnodeHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getLayer() const;
   int getModule() const;
   int getWire() const;
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcAnodeHit>;
   friend class HDDM_ElementLink<FdcAnodeHit>;
 private:
   FdcAnodeHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   float m_t;
};

typedef HDDM_ElementList<FdcAnodeHit> FdcAnodeHitList;
typedef HDDM_ElementLink<FdcAnodeHit> FdcAnodeHitLink;

class FdcAnodeTruthHit: public HDDM_Element {
 public:
   ~FdcAnodeTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getLayer() const;
   int getModule() const;
   int getWire() const;
   float getD() const;
   void setD(float d);
   float getDE() const;
   void setDE(float dE);
   int getItrack() const;
   void setItrack(int itrack);
   std::string getMaxOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getT() const;
   void setT(float t);
   float getT_unsmeared() const;
   void setT_unsmeared(float t_unsmeared);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcAnodeTruthHit>;
   friend class HDDM_ElementLink<FdcAnodeTruthHit>;
 private:
   FdcAnodeTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_d;
   float m_dE;
   int m_itrack;
   int m_ptype;
   float m_t;
   float m_t_unsmeared;
};

typedef HDDM_ElementList<FdcAnodeTruthHit> FdcAnodeTruthHitList;
typedef HDDM_ElementLink<FdcAnodeTruthHit> FdcAnodeTruthHitLink;

class FdcAnodeWire: public HDDM_Element {
 public:
   ~FdcAnodeWire();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getWire() const;
   void setWire(int wire);
   FdcAnodeHit &getFdcAnodeHit(int index=0);
   FdcAnodeHitList &getFdcAnodeHits();
   FdcAnodeHitList addFdcAnodeHits(int count=1, int start=-1);
   void deleteFdcAnodeHits(int count=-1, int start=0);
   FdcAnodeTruthHit &getFdcAnodeTruthHit(int index=0);
   FdcAnodeTruthHitList &getFdcAnodeTruthHits();
   FdcAnodeTruthHitList addFdcAnodeTruthHits(int count=1, int start=-1);
   void deleteFdcAnodeTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcAnodeWire>;
   friend class HDDM_ElementLink<FdcAnodeWire>;
 private:
   FdcAnodeWire(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_wire;
   FdcAnodeHitList m_fdcAnodeHit_list;
   FdcAnodeTruthHitList m_fdcAnodeTruthHit_list;
};

typedef HDDM_ElementList<FdcAnodeWire> FdcAnodeWireList;
typedef HDDM_ElementLink<FdcAnodeWire> FdcAnodeWireLink;

class FdcDigihit: public HDDM_Element {
 public:
   ~FdcDigihit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getPlane() const;
   int getStrip() const;
   float getQ() const;
   float getT() const;
   int getMinOccurs() const;
   float getPeakAmp() const;
   void setPeakAmp(float peakAmp);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcDigihit>;
   friend class HDDM_ElementLink<FdcDigihit>;
 private:
   FdcDigihit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_peakAmp;
};

typedef HDDM_ElementList<FdcDigihit> FdcDigihitList;
typedef HDDM_ElementLink<FdcDigihit> FdcDigihitLink;

class FdcCathodeHit: public HDDM_Element {
 public:
   ~FdcCathodeHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getLayer() const;
   int getModule() const;
   int getPlane() const;
   int getStrip() const;
   std::string getMaxOccurs() const;
   float getQ() const;
   void setQ(float q);
   float getT() const;
   void setT(float t);
   FdcDigihit &getFdcDigihit();
   FdcDigihitList &getFdcDigihits();
   FdcDigihitList addFdcDigihits(int count=1, int start=-1);
   void deleteFdcDigihits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcCathodeHit>;
   friend class HDDM_ElementLink<FdcCathodeHit>;
 private:
   FdcCathodeHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_q;
   float m_t;
   FdcDigihitLink m_fdcDigihit_link;
};

typedef HDDM_ElementList<FdcCathodeHit> FdcCathodeHitList;
typedef HDDM_ElementLink<FdcCathodeHit> FdcCathodeHitLink;

class FdcCathodeTruthHit: public HDDM_Element {
 public:
   ~FdcCathodeTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getLayer() const;
   int getModule() const;
   int getPlane() const;
   int getStrip() const;
   int getItrack() const;
   void setItrack(int itrack);
   std::string getMaxOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getQ() const;
   void setQ(float q);
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcCathodeTruthHit>;
   friend class HDDM_ElementLink<FdcCathodeTruthHit>;
 private:
   FdcCathodeTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_itrack;
   int m_ptype;
   float m_q;
   float m_t;
};

typedef HDDM_ElementList<FdcCathodeTruthHit> FdcCathodeTruthHitList;
typedef HDDM_ElementLink<FdcCathodeTruthHit> FdcCathodeTruthHitLink;

class FdcCathodeStrip: public HDDM_Element {
 public:
   ~FdcCathodeStrip();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getPlane() const;
   void setPlane(int plane);
   int getStrip() const;
   void setStrip(int strip);
   FdcCathodeHit &getFdcCathodeHit(int index=0);
   FdcCathodeHitList &getFdcCathodeHits();
   FdcCathodeHitList addFdcCathodeHits(int count=1, int start=-1);
   void deleteFdcCathodeHits(int count=-1, int start=0);
   FdcCathodeTruthHit &getFdcCathodeTruthHit(int index=0);
   FdcCathodeTruthHitList &getFdcCathodeTruthHits();
   FdcCathodeTruthHitList addFdcCathodeTruthHits(int count=1, int start=-1);
   void deleteFdcCathodeTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcCathodeStrip>;
   friend class HDDM_ElementLink<FdcCathodeStrip>;
 private:
   FdcCathodeStrip(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_plane;
   int m_strip;
   FdcCathodeHitList m_fdcCathodeHit_list;
   FdcCathodeTruthHitList m_fdcCathodeTruthHit_list;
};

typedef HDDM_ElementList<FdcCathodeStrip> FdcCathodeStripList;
typedef HDDM_ElementLink<FdcCathodeStrip> FdcCathodeStripLink;

class FdcTruthPoint: public HDDM_Element {
 public:
   ~FdcTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   float getE() const;
   void setE(float E);
   float getDEdx() const;
   void setDEdx(float dEdx);
   float getDradius() const;
   void setDradius(float dradius);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcTruthPoint>;
   friend class HDDM_ElementLink<FdcTruthPoint>;
 private:
   FdcTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_dEdx;
   float m_dradius;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<FdcTruthPoint> FdcTruthPointList;
typedef HDDM_ElementLink<FdcTruthPoint> FdcTruthPointLink;

class FdcChamber: public HDDM_Element {
 public:
   ~FdcChamber();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getLayer() const;
   void setLayer(int layer);
   std::string getMaxOccurs() const;
   int getModule() const;
   void setModule(int module);
   FdcAnodeWire &getFdcAnodeWire(int index=0);
   FdcAnodeWireList &getFdcAnodeWires();
   FdcAnodeWireList addFdcAnodeWires(int count=1, int start=-1);
   void deleteFdcAnodeWires(int count=-1, int start=0);
   FdcCathodeStrip &getFdcCathodeStrip(int index=0);
   FdcCathodeStripList &getFdcCathodeStrips();
   FdcCathodeStripList addFdcCathodeStrips(int count=1, int start=-1);
   void deleteFdcCathodeStrips(int count=-1, int start=0);
   FdcTruthPoint &getFdcTruthPoint(int index=0);
   FdcTruthPointList &getFdcTruthPoints();
   FdcTruthPointList addFdcTruthPoints(int count=1, int start=-1);
   void deleteFdcTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FdcChamber>;
   friend class HDDM_ElementLink<FdcChamber>;
 private:
   FdcChamber(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_layer;
   int m_module;
   FdcAnodeWireList m_fdcAnodeWire_list;
   FdcCathodeStripList m_fdcCathodeStrip_list;
   FdcTruthPointList m_fdcTruthPoint_list;
};

typedef HDDM_ElementList<FdcChamber> FdcChamberList;
typedef HDDM_ElementLink<FdcChamber> FdcChamberLink;

class ForwardDC: public HDDM_Element {
 public:
   ~ForwardDC();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   FdcChamber &getFdcChamber(int index=0);
   FdcChamberList &getFdcChambers();
   FdcChamberList addFdcChambers(int count=1, int start=-1);
   void deleteFdcChambers(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<ForwardDC>;
   friend class HDDM_ElementLink<ForwardDC>;
 private:
   ForwardDC(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   FdcChamberList m_fdcChamber_list;
};

typedef HDDM_ElementList<ForwardDC> ForwardDCList;
typedef HDDM_ElementLink<ForwardDC> ForwardDCLink;

class StcDigihit: public HDDM_Element {
 public:
   ~StcDigihit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getSector() const;
   float getDE() const;
   float getT() const;
   int getMinOccurs() const;
   float getPeakAmp() const;
   void setPeakAmp(float peakAmp);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<StcDigihit>;
   friend class HDDM_ElementLink<StcDigihit>;
 private:
   StcDigihit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_peakAmp;
};

typedef HDDM_ElementList<StcDigihit> StcDigihitList;
typedef HDDM_ElementLink<StcDigihit> StcDigihitLink;

class StcHit: public HDDM_Element {
 public:
   ~StcHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getSector() const;
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   StcDigihit &getStcDigihit();
   StcDigihitList &getStcDigihits();
   StcDigihitList addStcDigihits(int count=1, int start=-1);
   void deleteStcDigihits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<StcHit>;
   friend class HDDM_ElementLink<StcHit>;
 private:
   StcHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   float m_t;
   StcDigihitLink m_stcDigihit_link;
};

typedef HDDM_ElementList<StcHit> StcHitList;
typedef HDDM_ElementLink<StcHit> StcHitLink;

class StcTruthHit: public HDDM_Element {
 public:
   ~StcTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getSector() const;
   float getDE() const;
   void setDE(float dE);
   int getItrack() const;
   void setItrack(int itrack);
   std::string getMaxOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<StcTruthHit>;
   friend class HDDM_ElementLink<StcTruthHit>;
 private:
   StcTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   int m_itrack;
   int m_ptype;
   float m_t;
};

typedef HDDM_ElementList<StcTruthHit> StcTruthHitList;
typedef HDDM_ElementLink<StcTruthHit> StcTruthHitLink;

class StcPaddle: public HDDM_Element {
 public:
   ~StcPaddle();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getSector() const;
   void setSector(int sector);
   StcHit &getStcHit(int index=0);
   StcHitList &getStcHits();
   StcHitList addStcHits(int count=1, int start=-1);
   void deleteStcHits(int count=-1, int start=0);
   StcTruthHit &getStcTruthHit(int index=0);
   StcTruthHitList &getStcTruthHits();
   StcTruthHitList addStcTruthHits(int count=1, int start=-1);
   void deleteStcTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<StcPaddle>;
   friend class HDDM_ElementLink<StcPaddle>;
 private:
   StcPaddle(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_sector;
   StcHitList m_stcHit_list;
   StcTruthHitList m_stcTruthHit_list;
};

typedef HDDM_ElementList<StcPaddle> StcPaddleList;
typedef HDDM_ElementLink<StcPaddle> StcPaddleLink;

class StcTruthPoint: public HDDM_Element {
 public:
   ~StcTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   float getDEdx() const;
   void setDEdx(float dEdx);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getPhi() const;
   void setPhi(float phi);
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getR() const;
   void setR(float r);
   int getSector() const;
   void setSector(int sector);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<StcTruthPoint>;
   friend class HDDM_ElementLink<StcTruthPoint>;
 private:
   StcTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_dEdx;
   float m_phi;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_r;
   int m_sector;
   float m_t;
   int m_track;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<StcTruthPoint> StcTruthPointList;
typedef HDDM_ElementLink<StcTruthPoint> StcTruthPointLink;

class StartCntr: public HDDM_Element {
 public:
   ~StartCntr();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   StcPaddle &getStcPaddle(int index=0);
   StcPaddleList &getStcPaddles();
   StcPaddleList addStcPaddles(int count=1, int start=-1);
   void deleteStcPaddles(int count=-1, int start=0);
   StcTruthPoint &getStcTruthPoint(int index=0);
   StcTruthPointList &getStcTruthPoints();
   StcTruthPointList addStcTruthPoints(int count=1, int start=-1);
   void deleteStcTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<StartCntr>;
   friend class HDDM_ElementLink<StartCntr>;
 private:
   StartCntr(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   StcPaddleList m_stcPaddle_list;
   StcTruthPointList m_stcTruthPoint_list;
};

typedef HDDM_ElementList<StartCntr> StartCntrList;
typedef HDDM_ElementLink<StartCntr> StartCntrLink;

class BcalSiPMUpHit: public HDDM_Element {
 public:
   ~BcalSiPMUpHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalSiPMUpHit>;
   friend class HDDM_ElementLink<BcalSiPMUpHit>;
 private:
   BcalSiPMUpHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_t;
};

typedef HDDM_ElementList<BcalSiPMUpHit> BcalSiPMUpHitList;
typedef HDDM_ElementLink<BcalSiPMUpHit> BcalSiPMUpHitLink;

class BcalSiPMDownHit: public HDDM_Element {
 public:
   ~BcalSiPMDownHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalSiPMDownHit>;
   friend class HDDM_ElementLink<BcalSiPMDownHit>;
 private:
   BcalSiPMDownHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_t;
};

typedef HDDM_ElementList<BcalSiPMDownHit> BcalSiPMDownHitList;
typedef HDDM_ElementLink<BcalSiPMDownHit> BcalSiPMDownHitLink;

class BcalSiPMTruth: public HDDM_Element {
 public:
   ~BcalSiPMTruth();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   float getBin_width() const;
   int getEnd() const;
   float getTstart() const;
   std::string getVals() const;
   float getE() const;
   void setE(float E);
   int getIncident_id() const;
   void setIncident_id(int incident_id);
   int getMinOccurs() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalSiPMTruth>;
   friend class HDDM_ElementLink<BcalSiPMTruth>;
 private:
   BcalSiPMTruth(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_incident_id;
};

typedef HDDM_ElementList<BcalSiPMTruth> BcalSiPMTruthList;
typedef HDDM_ElementLink<BcalSiPMTruth> BcalSiPMTruthLink;

class BcalSiPMSpectrum: public HDDM_Element {
 public:
   ~BcalSiPMSpectrum();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   float getBin_width() const;
   void setBin_width(float bin_width);
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getTstart() const;
   void setTstart(float tstart);
   std::string getVals() const;
   void setVals(const std::string &vals);
   BcalSiPMTruth &getBcalSiPMTruth();
   BcalSiPMTruthList &getBcalSiPMTruths();
   BcalSiPMTruthList addBcalSiPMTruths(int count=1, int start=-1);
   void deleteBcalSiPMTruths(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalSiPMSpectrum>;
   friend class HDDM_ElementLink<BcalSiPMSpectrum>;
 private:
   BcalSiPMSpectrum(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_bin_width;
   int m_end;
   float m_tstart;
   std::string m_vals;
   BcalSiPMTruthLink m_bcalSiPMTruth_link;
};

typedef HDDM_ElementList<BcalSiPMSpectrum> BcalSiPMSpectrumList;
typedef HDDM_ElementLink<BcalSiPMSpectrum> BcalSiPMSpectrumLink;

class BcalfADCHit: public HDDM_Element {
 public:
   ~BcalfADCHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   float getE() const;
   void setE(float E);
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalfADCHit>;
   friend class HDDM_ElementLink<BcalfADCHit>;
 private:
   BcalfADCHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_end;
   float m_t;
};

typedef HDDM_ElementList<BcalfADCHit> BcalfADCHitList;
typedef HDDM_ElementLink<BcalfADCHit> BcalfADCHitLink;

class BcalfADCPeak: public HDDM_Element {
 public:
   ~BcalfADCPeak();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   int getEnd() const;
   int getPulse_integral() const;
   int getPulse_time() const;
   int getMinOccurs() const;
   float getPeakAmp() const;
   void setPeakAmp(float peakAmp);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalfADCPeak>;
   friend class HDDM_ElementLink<BcalfADCPeak>;
 private:
   BcalfADCPeak(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_peakAmp;
};

typedef HDDM_ElementList<BcalfADCPeak> BcalfADCPeakList;
typedef HDDM_ElementLink<BcalfADCPeak> BcalfADCPeakLink;

class BcalfADCDigiHit: public HDDM_Element {
 public:
   ~BcalfADCDigiHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getPulse_integral() const;
   void setPulse_integral(int pulse_integral);
   int getPulse_time() const;
   void setPulse_time(int pulse_time);
   BcalfADCPeak &getBcalfADCPeak();
   BcalfADCPeakList &getBcalfADCPeaks();
   BcalfADCPeakList addBcalfADCPeaks(int count=1, int start=-1);
   void deleteBcalfADCPeaks(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalfADCDigiHit>;
   friend class HDDM_ElementLink<BcalfADCDigiHit>;
 private:
   BcalfADCDigiHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_end;
   int m_pulse_integral;
   int m_pulse_time;
   BcalfADCPeakLink m_bcalfADCPeak_link;
};

typedef HDDM_ElementList<BcalfADCDigiHit> BcalfADCDigiHitList;
typedef HDDM_ElementLink<BcalfADCDigiHit> BcalfADCDigiHitLink;

class BcalTDCHit: public HDDM_Element {
 public:
   ~BcalTDCHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalTDCHit>;
   friend class HDDM_ElementLink<BcalTDCHit>;
 private:
   BcalTDCHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_end;
   float m_t;
};

typedef HDDM_ElementList<BcalTDCHit> BcalTDCHitList;
typedef HDDM_ElementLink<BcalTDCHit> BcalTDCHitLink;

class BcalTDCDigiHit: public HDDM_Element {
 public:
   ~BcalTDCDigiHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getTime() const;
   void setTime(float time);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalTDCDigiHit>;
   friend class HDDM_ElementLink<BcalTDCDigiHit>;
 private:
   BcalTDCDigiHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_end;
   float m_time;
};

typedef HDDM_ElementList<BcalTDCDigiHit> BcalTDCDigiHitList;
typedef HDDM_ElementLink<BcalTDCDigiHit> BcalTDCDigiHitLink;

class BcalTruthHit: public HDDM_Element {
 public:
   ~BcalTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getModule() const;
   int getSector() const;
   float getE() const;
   void setE(float E);
   int getIncident_id() const;
   void setIncident_id(int incident_id);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   float getZLocal() const;
   void setZLocal(float zLocal);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalTruthHit>;
   friend class HDDM_ElementLink<BcalTruthHit>;
 private:
   BcalTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_incident_id;
   float m_t;
   float m_zLocal;
};

typedef HDDM_ElementList<BcalTruthHit> BcalTruthHitList;
typedef HDDM_ElementLink<BcalTruthHit> BcalTruthHitLink;

class BcalCell: public HDDM_Element {
 public:
   ~BcalCell();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   void setLayer(int layer);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getModule() const;
   void setModule(int module);
   int getSector() const;
   void setSector(int sector);
   BcalSiPMUpHit &getBcalSiPMUpHit(int index=0);
   BcalSiPMUpHitList &getBcalSiPMUpHits();
   BcalSiPMUpHitList addBcalSiPMUpHits(int count=1, int start=-1);
   void deleteBcalSiPMUpHits(int count=-1, int start=0);
   BcalSiPMDownHit &getBcalSiPMDownHit(int index=0);
   BcalSiPMDownHitList &getBcalSiPMDownHits();
   BcalSiPMDownHitList addBcalSiPMDownHits(int count=1, int start=-1);
   void deleteBcalSiPMDownHits(int count=-1, int start=0);
   BcalSiPMSpectrum &getBcalSiPMSpectrum(int index=0);
   BcalSiPMSpectrumList &getBcalSiPMSpectrums();
   BcalSiPMSpectrumList addBcalSiPMSpectrums(int count=1, int start=-1);
   void deleteBcalSiPMSpectrums(int count=-1, int start=0);
   BcalfADCHit &getBcalfADCHit(int index=0);
   BcalfADCHitList &getBcalfADCHits();
   BcalfADCHitList addBcalfADCHits(int count=1, int start=-1);
   void deleteBcalfADCHits(int count=-1, int start=0);
   BcalfADCDigiHit &getBcalfADCDigiHit(int index=0);
   BcalfADCDigiHitList &getBcalfADCDigiHits();
   BcalfADCDigiHitList addBcalfADCDigiHits(int count=1, int start=-1);
   void deleteBcalfADCDigiHits(int count=-1, int start=0);
   BcalTDCHit &getBcalTDCHit(int index=0);
   BcalTDCHitList &getBcalTDCHits();
   BcalTDCHitList addBcalTDCHits(int count=1, int start=-1);
   void deleteBcalTDCHits(int count=-1, int start=0);
   BcalTDCDigiHit &getBcalTDCDigiHit(int index=0);
   BcalTDCDigiHitList &getBcalTDCDigiHits();
   BcalTDCDigiHitList addBcalTDCDigiHits(int count=1, int start=-1);
   void deleteBcalTDCDigiHits(int count=-1, int start=0);
   BcalTruthHit &getBcalTruthHit(int index=0);
   BcalTruthHitList &getBcalTruthHits();
   BcalTruthHitList addBcalTruthHits(int count=1, int start=-1);
   void deleteBcalTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalCell>;
   friend class HDDM_ElementLink<BcalCell>;
 private:
   BcalCell(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_layer;
   int m_module;
   int m_sector;
   BcalSiPMUpHitList m_bcalSiPMUpHit_list;
   BcalSiPMDownHitList m_bcalSiPMDownHit_list;
   BcalSiPMSpectrumList m_bcalSiPMSpectrum_list;
   BcalfADCHitList m_bcalfADCHit_list;
   BcalfADCDigiHitList m_bcalfADCDigiHit_list;
   BcalTDCHitList m_bcalTDCHit_list;
   BcalTDCDigiHitList m_bcalTDCDigiHit_list;
   BcalTruthHitList m_bcalTruthHit_list;
};

typedef HDDM_ElementList<BcalCell> BcalCellList;
typedef HDDM_ElementLink<BcalCell> BcalCellLink;

class BcalTruthIncidentParticle: public HDDM_Element {
 public:
   ~BcalTruthIncidentParticle();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getId() const;
   void setId(int id);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalTruthIncidentParticle>;
   friend class HDDM_ElementLink<BcalTruthIncidentParticle>;
 private:
   BcalTruthIncidentParticle(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_id;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_x;
   float m_y;
   float m_z;
};

typedef HDDM_ElementList<BcalTruthIncidentParticle> BcalTruthIncidentParticleList;
typedef HDDM_ElementLink<BcalTruthIncidentParticle> BcalTruthIncidentParticleLink;

class BcalTruthShower: public HDDM_Element {
 public:
   ~BcalTruthShower();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getPhi() const;
   void setPhi(float phi);
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getR() const;
   void setR(float r);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BcalTruthShower>;
   friend class HDDM_ElementLink<BcalTruthShower>;
 private:
   BcalTruthShower(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_phi;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_r;
   float m_t;
   int m_track;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<BcalTruthShower> BcalTruthShowerList;
typedef HDDM_ElementLink<BcalTruthShower> BcalTruthShowerLink;

class BarrelEMcal: public HDDM_Element {
 public:
   ~BarrelEMcal();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   BcalCell &getBcalCell(int index=0);
   BcalCellList &getBcalCells();
   BcalCellList addBcalCells(int count=1, int start=-1);
   void deleteBcalCells(int count=-1, int start=0);
   BcalTruthIncidentParticle &getBcalTruthIncidentParticle(int index=0);
   BcalTruthIncidentParticleList &getBcalTruthIncidentParticles();
   BcalTruthIncidentParticleList addBcalTruthIncidentParticles(int count=1, int start=-1);
   void deleteBcalTruthIncidentParticles(int count=-1, int start=0);
   BcalTruthShower &getBcalTruthShower(int index=0);
   BcalTruthShowerList &getBcalTruthShowers();
   BcalTruthShowerList addBcalTruthShowers(int count=1, int start=-1);
   void deleteBcalTruthShowers(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<BarrelEMcal>;
   friend class HDDM_ElementLink<BarrelEMcal>;
 private:
   BarrelEMcal(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   BcalCellList m_bcalCell_list;
   BcalTruthIncidentParticleList m_bcalTruthIncidentParticle_list;
   BcalTruthShowerList m_bcalTruthShower_list;
};

typedef HDDM_ElementList<BarrelEMcal> BarrelEMcalList;
typedef HDDM_ElementLink<BarrelEMcal> BarrelEMcalLink;

class GcalHit: public HDDM_Element {
 public:
   ~GcalHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getModule() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   float getZLocal() const;
   void setZLocal(float zLocal);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<GcalHit>;
   friend class HDDM_ElementLink<GcalHit>;
 private:
   GcalHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_t;
   float m_zLocal;
};

typedef HDDM_ElementList<GcalHit> GcalHitList;
typedef HDDM_ElementLink<GcalHit> GcalHitLink;

class GcalTruthHit: public HDDM_Element {
 public:
   ~GcalTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getModule() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   float getZLocal() const;
   void setZLocal(float zLocal);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<GcalTruthHit>;
   friend class HDDM_ElementLink<GcalTruthHit>;
 private:
   GcalTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_t;
   float m_zLocal;
};

typedef HDDM_ElementList<GcalTruthHit> GcalTruthHitList;
typedef HDDM_ElementLink<GcalTruthHit> GcalTruthHitLink;

class GcalCell: public HDDM_Element {
 public:
   ~GcalCell();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMaxOccurs() const;
   int getMinOccurs() const;
   int getModule() const;
   void setModule(int module);
   GcalHit &getGcalHit(int index=0);
   GcalHitList &getGcalHits();
   GcalHitList addGcalHits(int count=1, int start=-1);
   void deleteGcalHits(int count=-1, int start=0);
   GcalTruthHit &getGcalTruthHit(int index=0);
   GcalTruthHitList &getGcalTruthHits();
   GcalTruthHitList addGcalTruthHits(int count=1, int start=-1);
   void deleteGcalTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<GcalCell>;
   friend class HDDM_ElementLink<GcalCell>;
 private:
   GcalCell(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_module;
   GcalHitList m_gcalHit_list;
   GcalTruthHitList m_gcalTruthHit_list;
};

typedef HDDM_ElementList<GcalCell> GcalCellList;
typedef HDDM_ElementLink<GcalCell> GcalCellLink;

class GcalTruthShower: public HDDM_Element {
 public:
   ~GcalTruthShower();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getPhi() const;
   void setPhi(float phi);
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getR() const;
   void setR(float r);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<GcalTruthShower>;
   friend class HDDM_ElementLink<GcalTruthShower>;
 private:
   GcalTruthShower(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_phi;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_r;
   float m_t;
   int m_track;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<GcalTruthShower> GcalTruthShowerList;
typedef HDDM_ElementLink<GcalTruthShower> GcalTruthShowerLink;

class GapEMcal: public HDDM_Element {
 public:
   ~GapEMcal();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   GcalCell &getGcalCell(int index=0);
   GcalCellList &getGcalCells();
   GcalCellList addGcalCells(int count=1, int start=-1);
   void deleteGcalCells(int count=-1, int start=0);
   GcalTruthShower &getGcalTruthShower(int index=0);
   GcalTruthShowerList &getGcalTruthShowers();
   GcalTruthShowerList addGcalTruthShowers(int count=1, int start=-1);
   void deleteGcalTruthShowers(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<GapEMcal>;
   friend class HDDM_ElementLink<GapEMcal>;
 private:
   GapEMcal(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   GcalCellList m_gcalCell_list;
   GcalTruthShowerList m_gcalTruthShower_list;
};

typedef HDDM_ElementList<GapEMcal> GapEMcalList;
typedef HDDM_ElementLink<GapEMcal> GapEMcalLink;

class CereHit: public HDDM_Element {
 public:
   ~CereHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getSector() const;
   std::string getMaxOccurs() const;
   float getPe() const;
   void setPe(float pe);
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CereHit>;
   friend class HDDM_ElementLink<CereHit>;
 private:
   CereHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_pe;
   float m_t;
};

typedef HDDM_ElementList<CereHit> CereHitList;
typedef HDDM_ElementLink<CereHit> CereHitLink;

class CereTruthHit: public HDDM_Element {
 public:
   ~CereTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getSector() const;
   std::string getMaxOccurs() const;
   float getPe() const;
   void setPe(float pe);
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CereTruthHit>;
   friend class HDDM_ElementLink<CereTruthHit>;
 private:
   CereTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_pe;
   float m_t;
};

typedef HDDM_ElementList<CereTruthHit> CereTruthHitList;
typedef HDDM_ElementLink<CereTruthHit> CereTruthHitLink;

class CereSection: public HDDM_Element {
 public:
   ~CereSection();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getSector() const;
   void setSector(int sector);
   CereHit &getCereHit(int index=0);
   CereHitList &getCereHits();
   CereHitList addCereHits(int count=1, int start=-1);
   void deleteCereHits(int count=-1, int start=0);
   CereTruthHit &getCereTruthHit(int index=0);
   CereTruthHitList &getCereTruthHits();
   CereTruthHitList addCereTruthHits(int count=1, int start=-1);
   void deleteCereTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CereSection>;
   friend class HDDM_ElementLink<CereSection>;
 private:
   CereSection(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_sector;
   CereHitList m_cereHit_list;
   CereTruthHitList m_cereTruthHit_list;
};

typedef HDDM_ElementList<CereSection> CereSectionList;
typedef HDDM_ElementLink<CereSection> CereSectionLink;

class CereTruthPoint: public HDDM_Element {
 public:
   ~CereTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CereTruthPoint>;
   friend class HDDM_ElementLink<CereTruthPoint>;
 private:
   CereTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<CereTruthPoint> CereTruthPointList;
typedef HDDM_ElementLink<CereTruthPoint> CereTruthPointLink;

class Cerenkov: public HDDM_Element {
 public:
   ~Cerenkov();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   CereSection &getCereSection(int index=0);
   CereSectionList &getCereSections();
   CereSectionList addCereSections(int count=1, int start=-1);
   void deleteCereSections(int count=-1, int start=0);
   CereTruthPoint &getCereTruthPoint(int index=0);
   CereTruthPointList &getCereTruthPoints();
   CereTruthPointList addCereTruthPoints(int count=1, int start=-1);
   void deleteCereTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Cerenkov>;
   friend class HDDM_ElementLink<Cerenkov>;
 private:
   Cerenkov(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   CereSectionList m_cereSection_list;
   CereTruthPointList m_cereTruthPoint_list;
};

typedef HDDM_ElementList<Cerenkov> CerenkovList;
typedef HDDM_ElementLink<Cerenkov> CerenkovLink;

class RichTruthHit: public HDDM_Element {
 public:
   ~RichTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<RichTruthHit>;
   friend class HDDM_ElementLink<RichTruthHit>;
 private:
   RichTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_t;
   float m_x;
   float m_y;
   float m_z;
};

typedef HDDM_ElementList<RichTruthHit> RichTruthHitList;
typedef HDDM_ElementLink<RichTruthHit> RichTruthHitLink;

class RichTruthPoint: public HDDM_Element {
 public:
   ~RichTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<RichTruthPoint>;
   friend class HDDM_ElementLink<RichTruthPoint>;
 private:
   RichTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<RichTruthPoint> RichTruthPointList;
typedef HDDM_ElementLink<RichTruthPoint> RichTruthPointLink;

class RICH: public HDDM_Element {
 public:
   ~RICH();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   RichTruthHit &getRichTruthHit(int index=0);
   RichTruthHitList &getRichTruthHits();
   RichTruthHitList addRichTruthHits(int count=1, int start=-1);
   void deleteRichTruthHits(int count=-1, int start=0);
   RichTruthPoint &getRichTruthPoint(int index=0);
   RichTruthPointList &getRichTruthPoints();
   RichTruthPointList addRichTruthPoints(int count=1, int start=-1);
   void deleteRichTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<RICH>;
   friend class HDDM_ElementLink<RICH>;
 private:
   RICH(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   RichTruthHitList m_richTruthHit_list;
   RichTruthPointList m_richTruthPoint_list;
};

typedef HDDM_ElementList<RICH> RICHList;
typedef HDDM_ElementLink<RICH> RICHLink;

class DircTruthBarHit: public HDDM_Element {
 public:
   ~DircTruthBarHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   int getBar() const;
   void setBar(int bar);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getPdg() const;
   void setPdg(int pdg);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<DircTruthBarHit>;
   friend class HDDM_ElementLink<DircTruthBarHit>;
 private:
   DircTruthBarHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_bar;
   int m_pdg;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
};

typedef HDDM_ElementList<DircTruthBarHit> DircTruthBarHitList;
typedef HDDM_ElementLink<DircTruthBarHit> DircTruthBarHitLink;

class DircTruthPmtHitExtra: public HDDM_Element {
 public:
   ~DircTruthPmtHitExtra();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   int getCh() const;
   int getKey_bar() const;
   float getT() const;
   float getX() const;
   float getY() const;
   float getZ() const;
   bool getBbrefl() const;
   void setBbrefl(bool bbrefl);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int64_t getPath() const;
   void setPath(int64_t path);
   int getRefl() const;
   void setRefl(int refl);
   float getT_fixed() const;
   void setT_fixed(float t_fixed);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<DircTruthPmtHitExtra>;
   friend class HDDM_ElementLink<DircTruthPmtHitExtra>;
 private:
   DircTruthPmtHitExtra(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_bbrefl;
   int64_t m_path;
   int m_refl;
   float m_t_fixed;
};

typedef HDDM_ElementList<DircTruthPmtHitExtra> DircTruthPmtHitExtraList;
typedef HDDM_ElementLink<DircTruthPmtHitExtra> DircTruthPmtHitExtraLink;

class DircTruthPmtHit: public HDDM_Element {
 public:
   ~DircTruthPmtHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   int getCh() const;
   void setCh(int ch);
   int getKey_bar() const;
   void setKey_bar(int key_bar);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   DircTruthPmtHitExtra &getDircTruthPmtHitExtra(int index=0);
   DircTruthPmtHitExtraList &getDircTruthPmtHitExtras();
   DircTruthPmtHitExtraList addDircTruthPmtHitExtras(int count=1, int start=-1);
   void deleteDircTruthPmtHitExtras(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<DircTruthPmtHit>;
   friend class HDDM_ElementLink<DircTruthPmtHit>;
 private:
   DircTruthPmtHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_ch;
   int m_key_bar;
   float m_t;
   float m_x;
   float m_y;
   float m_z;
   DircTruthPmtHitExtraList m_dircTruthPmtHitExtra_list;
};

typedef HDDM_ElementList<DircTruthPmtHit> DircTruthPmtHitList;
typedef HDDM_ElementLink<DircTruthPmtHit> DircTruthPmtHitLink;

class DircPmtHit: public HDDM_Element {
 public:
   ~DircPmtHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getCh() const;
   void setCh(int ch);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<DircPmtHit>;
   friend class HDDM_ElementLink<DircPmtHit>;
 private:
   DircPmtHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_ch;
   float m_t;
};

typedef HDDM_ElementList<DircPmtHit> DircPmtHitList;
typedef HDDM_ElementLink<DircPmtHit> DircPmtHitLink;

class DIRC: public HDDM_Element {
 public:
   ~DIRC();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   DircTruthBarHit &getDircTruthBarHit(int index=0);
   DircTruthBarHitList &getDircTruthBarHits();
   DircTruthBarHitList addDircTruthBarHits(int count=1, int start=-1);
   void deleteDircTruthBarHits(int count=-1, int start=0);
   DircTruthPmtHit &getDircTruthPmtHit(int index=0);
   DircTruthPmtHitList &getDircTruthPmtHits();
   DircTruthPmtHitList addDircTruthPmtHits(int count=1, int start=-1);
   void deleteDircTruthPmtHits(int count=-1, int start=0);
   DircPmtHit &getDircPmtHit(int index=0);
   DircPmtHitList &getDircPmtHits();
   DircPmtHitList addDircPmtHits(int count=1, int start=-1);
   void deleteDircPmtHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<DIRC>;
   friend class HDDM_ElementLink<DIRC>;
 private:
   DIRC(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   DircTruthBarHitList m_dircTruthBarHit_list;
   DircTruthPmtHitList m_dircTruthPmtHit_list;
   DircPmtHitList m_dircPmtHit_list;
};

typedef HDDM_ElementList<DIRC> DIRCList;
typedef HDDM_ElementLink<DIRC> DIRCLink;

class FtofDigihit: public HDDM_Element {
 public:
   ~FtofDigihit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getBar() const;
   int getPlane() const;
   float getDE() const;
   int getEnd() const;
   float getT() const;
   int getMinOccurs() const;
   float getPeakAmp() const;
   void setPeakAmp(float peakAmp);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FtofDigihit>;
   friend class HDDM_ElementLink<FtofDigihit>;
 private:
   FtofDigihit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_peakAmp;
};

typedef HDDM_ElementList<FtofDigihit> FtofDigihitList;
typedef HDDM_ElementLink<FtofDigihit> FtofDigihitLink;

class FtofHit: public HDDM_Element {
 public:
   ~FtofHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getBar() const;
   int getPlane() const;
   float getDE() const;
   void setDE(float dE);
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   FtofDigihit &getFtofDigihit();
   FtofDigihitList &getFtofDigihits();
   FtofDigihitList addFtofDigihits(int count=1, int start=-1);
   void deleteFtofDigihits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FtofHit>;
   friend class HDDM_ElementLink<FtofHit>;
 private:
   FtofHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   int m_end;
   float m_t;
   FtofDigihitLink m_ftofDigihit_link;
};

typedef HDDM_ElementList<FtofHit> FtofHitList;
typedef HDDM_ElementLink<FtofHit> FtofHitLink;

class FtofTruthExtra: public HDDM_Element {
 public:
   ~FtofTruthExtra();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getBar() const;
   int getPlane() const;
   float getDE() const;
   int getEnd() const;
   float getT() const;
   float getE() const;
   void setE(float E);
   float getDist() const;
   void setDist(float dist);
   int getItrack() const;
   void setItrack(int itrack);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FtofTruthExtra>;
   friend class HDDM_ElementLink<FtofTruthExtra>;
 private:
   FtofTruthExtra(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_dist;
   int m_itrack;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_x;
   float m_y;
   float m_z;
};

typedef HDDM_ElementList<FtofTruthExtra> FtofTruthExtraList;
typedef HDDM_ElementLink<FtofTruthExtra> FtofTruthExtraLink;

class FtofTruthHit: public HDDM_Element {
 public:
   ~FtofTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getBar() const;
   int getPlane() const;
   float getDE() const;
   void setDE(float dE);
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   FtofTruthExtra &getFtofTruthExtra(int index=0);
   FtofTruthExtraList &getFtofTruthExtras();
   FtofTruthExtraList addFtofTruthExtras(int count=1, int start=-1);
   void deleteFtofTruthExtras(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FtofTruthHit>;
   friend class HDDM_ElementLink<FtofTruthHit>;
 private:
   FtofTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   int m_end;
   float m_t;
   FtofTruthExtraList m_ftofTruthExtra_list;
};

typedef HDDM_ElementList<FtofTruthHit> FtofTruthHitList;
typedef HDDM_ElementLink<FtofTruthHit> FtofTruthHitLink;

class FtofCounter: public HDDM_Element {
 public:
   ~FtofCounter();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getBar() const;
   void setBar(int bar);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getPlane() const;
   void setPlane(int plane);
   FtofHit &getFtofHit(int index=0);
   FtofHitList &getFtofHits();
   FtofHitList addFtofHits(int count=1, int start=-1);
   void deleteFtofHits(int count=-1, int start=0);
   FtofTruthHit &getFtofTruthHit(int index=0);
   FtofTruthHitList &getFtofTruthHits();
   FtofTruthHitList addFtofTruthHits(int count=1, int start=-1);
   void deleteFtofTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FtofCounter>;
   friend class HDDM_ElementLink<FtofCounter>;
 private:
   FtofCounter(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_bar;
   int m_plane;
   FtofHitList m_ftofHit_list;
   FtofTruthHitList m_ftofTruthHit_list;
};

typedef HDDM_ElementList<FtofCounter> FtofCounterList;
typedef HDDM_ElementLink<FtofCounter> FtofCounterLink;

class FtofTruthPoint: public HDDM_Element {
 public:
   ~FtofTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FtofTruthPoint>;
   friend class HDDM_ElementLink<FtofTruthPoint>;
 private:
   FtofTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<FtofTruthPoint> FtofTruthPointList;
typedef HDDM_ElementLink<FtofTruthPoint> FtofTruthPointLink;

class ForwardTOF: public HDDM_Element {
 public:
   ~ForwardTOF();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   FtofCounter &getFtofCounter(int index=0);
   FtofCounterList &getFtofCounters();
   FtofCounterList addFtofCounters(int count=1, int start=-1);
   void deleteFtofCounters(int count=-1, int start=0);
   FtofTruthPoint &getFtofTruthPoint(int index=0);
   FtofTruthPointList &getFtofTruthPoints();
   FtofTruthPointList addFtofTruthPoints(int count=1, int start=-1);
   void deleteFtofTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<ForwardTOF>;
   friend class HDDM_ElementLink<ForwardTOF>;
 private:
   ForwardTOF(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   FtofCounterList m_ftofCounter_list;
   FtofTruthPointList m_ftofTruthPoint_list;
};

typedef HDDM_ElementList<ForwardTOF> ForwardTOFList;
typedef HDDM_ElementLink<ForwardTOF> ForwardTOFLink;

class FcalDigihit: public HDDM_Element {
 public:
   ~FcalDigihit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getColumn() const;
   int getRow() const;
   float getE() const;
   float getT() const;
   float getIntegralOverPeak() const;
   void setIntegralOverPeak(float integralOverPeak);
   int getMinOccurs() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FcalDigihit>;
   friend class HDDM_ElementLink<FcalDigihit>;
 private:
   FcalDigihit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_integralOverPeak;
};

typedef HDDM_ElementList<FcalDigihit> FcalDigihitList;
typedef HDDM_ElementLink<FcalDigihit> FcalDigihitLink;

class FcalHit: public HDDM_Element {
 public:
   ~FcalHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getColumn() const;
   int getRow() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   FcalDigihit &getFcalDigihit();
   FcalDigihitList &getFcalDigihits();
   FcalDigihitList addFcalDigihits(int count=1, int start=-1);
   void deleteFcalDigihits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FcalHit>;
   friend class HDDM_ElementLink<FcalHit>;
 private:
   FcalHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_t;
   FcalDigihitLink m_fcalDigihit_link;
};

typedef HDDM_ElementList<FcalHit> FcalHitList;
typedef HDDM_ElementLink<FcalHit> FcalHitLink;

class FcalTruthLightGuide: public HDDM_Element {
 public:
   ~FcalTruthLightGuide();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getColumn() const;
   int getRow() const;
   float getE() const;
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FcalTruthLightGuide>;
   friend class HDDM_ElementLink<FcalTruthLightGuide>;
 private:
   FcalTruthLightGuide(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   float m_t;
};

typedef HDDM_ElementList<FcalTruthLightGuide> FcalTruthLightGuideList;
typedef HDDM_ElementLink<FcalTruthLightGuide> FcalTruthLightGuideLink;

class FcalTruthHit: public HDDM_Element {
 public:
   ~FcalTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getColumn() const;
   int getRow() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   FcalTruthLightGuide &getFcalTruthLightGuide(int index=0);
   FcalTruthLightGuideList &getFcalTruthLightGuides();
   FcalTruthLightGuideList addFcalTruthLightGuides(int count=1, int start=-1);
   void deleteFcalTruthLightGuides(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FcalTruthHit>;
   friend class HDDM_ElementLink<FcalTruthHit>;
 private:
   FcalTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_t;
   FcalTruthLightGuideList m_fcalTruthLightGuide_list;
};

typedef HDDM_ElementList<FcalTruthHit> FcalTruthHitList;
typedef HDDM_ElementLink<FcalTruthHit> FcalTruthHitLink;

class FcalBlock: public HDDM_Element {
 public:
   ~FcalBlock();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getColumn() const;
   void setColumn(int column);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getRow() const;
   void setRow(int row);
   FcalHit &getFcalHit(int index=0);
   FcalHitList &getFcalHits();
   FcalHitList addFcalHits(int count=1, int start=-1);
   void deleteFcalHits(int count=-1, int start=0);
   FcalTruthHit &getFcalTruthHit(int index=0);
   FcalTruthHitList &getFcalTruthHits();
   FcalTruthHitList addFcalTruthHits(int count=1, int start=-1);
   void deleteFcalTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FcalBlock>;
   friend class HDDM_ElementLink<FcalBlock>;
 private:
   FcalBlock(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_column;
   int m_row;
   FcalHitList m_fcalHit_list;
   FcalTruthHitList m_fcalTruthHit_list;
};

typedef HDDM_ElementList<FcalBlock> FcalBlockList;
typedef HDDM_ElementLink<FcalBlock> FcalBlockLink;

class FcalTruthShower: public HDDM_Element {
 public:
   ~FcalTruthShower();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FcalTruthShower>;
   friend class HDDM_ElementLink<FcalTruthShower>;
 private:
   FcalTruthShower(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<FcalTruthShower> FcalTruthShowerList;
typedef HDDM_ElementLink<FcalTruthShower> FcalTruthShowerLink;

class ForwardEMcal: public HDDM_Element {
 public:
   ~ForwardEMcal();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   FcalBlock &getFcalBlock(int index=0);
   FcalBlockList &getFcalBlocks();
   FcalBlockList addFcalBlocks(int count=1, int start=-1);
   void deleteFcalBlocks(int count=-1, int start=0);
   FcalTruthShower &getFcalTruthShower(int index=0);
   FcalTruthShowerList &getFcalTruthShowers();
   FcalTruthShowerList addFcalTruthShowers(int count=1, int start=-1);
   void deleteFcalTruthShowers(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<ForwardEMcal>;
   friend class HDDM_ElementLink<ForwardEMcal>;
 private:
   ForwardEMcal(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   FcalBlockList m_fcalBlock_list;
   FcalTruthShowerList m_fcalTruthShower_list;
};

typedef HDDM_ElementList<ForwardEMcal> ForwardEMcalList;
typedef HDDM_ElementLink<ForwardEMcal> ForwardEMcalLink;

class CcalHit: public HDDM_Element {
 public:
   ~CcalHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getColumn() const;
   int getRow() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CcalHit>;
   friend class HDDM_ElementLink<CcalHit>;
 private:
   CcalHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_t;
};

typedef HDDM_ElementList<CcalHit> CcalHitList;
typedef HDDM_ElementLink<CcalHit> CcalHitLink;

class CcalTruthHit: public HDDM_Element {
 public:
   ~CcalTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getColumn() const;
   int getRow() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CcalTruthHit>;
   friend class HDDM_ElementLink<CcalTruthHit>;
 private:
   CcalTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_t;
};

typedef HDDM_ElementList<CcalTruthHit> CcalTruthHitList;
typedef HDDM_ElementLink<CcalTruthHit> CcalTruthHitLink;

class CcalBlock: public HDDM_Element {
 public:
   ~CcalBlock();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getColumn() const;
   void setColumn(int column);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getRow() const;
   void setRow(int row);
   CcalHit &getCcalHit(int index=0);
   CcalHitList &getCcalHits();
   CcalHitList addCcalHits(int count=1, int start=-1);
   void deleteCcalHits(int count=-1, int start=0);
   CcalTruthHit &getCcalTruthHit(int index=0);
   CcalTruthHitList &getCcalTruthHits();
   CcalTruthHitList addCcalTruthHits(int count=1, int start=-1);
   void deleteCcalTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CcalBlock>;
   friend class HDDM_ElementLink<CcalBlock>;
 private:
   CcalBlock(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_column;
   int m_row;
   CcalHitList m_ccalHit_list;
   CcalTruthHitList m_ccalTruthHit_list;
};

typedef HDDM_ElementList<CcalBlock> CcalBlockList;
typedef HDDM_ElementLink<CcalBlock> CcalBlockLink;

class CcalTruthShower: public HDDM_Element {
 public:
   ~CcalTruthShower();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<CcalTruthShower>;
   friend class HDDM_ElementLink<CcalTruthShower>;
 private:
   CcalTruthShower(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<CcalTruthShower> CcalTruthShowerList;
typedef HDDM_ElementLink<CcalTruthShower> CcalTruthShowerLink;

class ComptonEMcal: public HDDM_Element {
 public:
   ~ComptonEMcal();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   CcalBlock &getCcalBlock(int index=0);
   CcalBlockList &getCcalBlocks();
   CcalBlockList addCcalBlocks(int count=1, int start=-1);
   void deleteCcalBlocks(int count=-1, int start=0);
   CcalTruthShower &getCcalTruthShower(int index=0);
   CcalTruthShowerList &getCcalTruthShowers();
   CcalTruthShowerList addCcalTruthShowers(int count=1, int start=-1);
   void deleteCcalTruthShowers(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<ComptonEMcal>;
   friend class HDDM_ElementLink<ComptonEMcal>;
 private:
   ComptonEMcal(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   CcalBlockList m_ccalBlock_list;
   CcalTruthShowerList m_ccalTruthShower_list;
};

typedef HDDM_ElementList<ComptonEMcal> ComptonEMcalList;
typedef HDDM_ElementLink<ComptonEMcal> ComptonEMcalLink;

class UpvHit: public HDDM_Element {
 public:
   ~UpvHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getRow() const;
   float getE() const;
   void setE(float E);
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<UpvHit>;
   friend class HDDM_ElementLink<UpvHit>;
 private:
   UpvHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_end;
   float m_t;
};

typedef HDDM_ElementList<UpvHit> UpvHitList;
typedef HDDM_ElementLink<UpvHit> UpvHitLink;

class UpvTruthHit: public HDDM_Element {
 public:
   ~UpvTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   int getRow() const;
   float getE() const;
   void setE(float E);
   int getEnd() const;
   void setEnd(int end);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   float getXlocal() const;
   void setXlocal(float xlocal);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<UpvTruthHit>;
   friend class HDDM_ElementLink<UpvTruthHit>;
 private:
   UpvTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_end;
   float m_t;
   float m_xlocal;
};

typedef HDDM_ElementList<UpvTruthHit> UpvTruthHitList;
typedef HDDM_ElementLink<UpvTruthHit> UpvTruthHitLink;

class UpvPaddle: public HDDM_Element {
 public:
   ~UpvPaddle();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   void setLayer(int layer);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getRow() const;
   void setRow(int row);
   UpvHit &getUpvHit(int index=0);
   UpvHitList &getUpvHits();
   UpvHitList addUpvHits(int count=1, int start=-1);
   void deleteUpvHits(int count=-1, int start=0);
   UpvTruthHit &getUpvTruthHit(int index=0);
   UpvTruthHitList &getUpvTruthHits();
   UpvTruthHitList addUpvTruthHits(int count=1, int start=-1);
   void deleteUpvTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<UpvPaddle>;
   friend class HDDM_ElementLink<UpvPaddle>;
 private:
   UpvPaddle(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_layer;
   int m_row;
   UpvHitList m_upvHit_list;
   UpvTruthHitList m_upvTruthHit_list;
};

typedef HDDM_ElementList<UpvPaddle> UpvPaddleList;
typedef HDDM_ElementLink<UpvPaddle> UpvPaddleLink;

class UpvTruthShower: public HDDM_Element {
 public:
   ~UpvTruthShower();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<UpvTruthShower>;
   friend class HDDM_ElementLink<UpvTruthShower>;
 private:
   UpvTruthShower(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<UpvTruthShower> UpvTruthShowerList;
typedef HDDM_ElementLink<UpvTruthShower> UpvTruthShowerLink;

class UpstreamEMveto: public HDDM_Element {
 public:
   ~UpstreamEMveto();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   UpvPaddle &getUpvPaddle(int index=0);
   UpvPaddleList &getUpvPaddles();
   UpvPaddleList addUpvPaddles(int count=1, int start=-1);
   void deleteUpvPaddles(int count=-1, int start=0);
   UpvTruthShower &getUpvTruthShower(int index=0);
   UpvTruthShowerList &getUpvTruthShowers();
   UpvTruthShowerList addUpvTruthShowers(int count=1, int start=-1);
   void deleteUpvTruthShowers(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<UpstreamEMveto>;
   friend class HDDM_ElementLink<UpstreamEMveto>;
 private:
   UpstreamEMveto(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   UpvPaddleList m_upvPaddle_list;
   UpvTruthShowerList m_upvTruthShower_list;
};

typedef HDDM_ElementList<UpstreamEMveto> UpstreamEMvetoList;
typedef HDDM_ElementLink<UpstreamEMveto> UpstreamEMvetoLink;

class TaggerHit: public HDDM_Element {
 public:
   ~TaggerHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   int getCounterId() const;
   int getColumn() const;
   int getRow() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getNpe() const;
   void setNpe(int npe);
   float getT() const;
   void setT(float t);
   float getTADC() const;
   void setTADC(float tADC);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TaggerHit>;
   friend class HDDM_ElementLink<TaggerHit>;
 private:
   TaggerHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_npe;
   float m_t;
   float m_tADC;
};

typedef HDDM_ElementList<TaggerHit> TaggerHitList;
typedef HDDM_ElementLink<TaggerHit> TaggerHitLink;

class TaggerTruthHit: public HDDM_Element {
 public:
   ~TaggerTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getCounterId() const;
   int getColumn() const;
   int getRow() const;
   float getE() const;
   void setE(float E);
   int getBg() const;
   void setBg(int bg);
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TaggerTruthHit>;
   friend class HDDM_ElementLink<TaggerTruthHit>;
 private:
   TaggerTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_bg;
   float m_dE;
   float m_t;
};

typedef HDDM_ElementList<TaggerTruthHit> TaggerTruthHitList;
typedef HDDM_ElementLink<TaggerTruthHit> TaggerTruthHitLink;

class MicroChannel: public HDDM_Element {
 public:
   ~MicroChannel();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   int getColumn() const;
   void setColumn(int column);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getRow() const;
   void setRow(int row);
   TaggerHit &getTaggerHit(int index=0);
   TaggerHitList &getTaggerHits();
   TaggerHitList addTaggerHits(int count=1, int start=-1);
   void deleteTaggerHits(int count=-1, int start=0);
   TaggerTruthHit &getTaggerTruthHit(int index=0);
   TaggerTruthHitList &getTaggerTruthHits();
   TaggerTruthHitList addTaggerTruthHits(int count=1, int start=-1);
   void deleteTaggerTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<MicroChannel>;
   friend class HDDM_ElementLink<MicroChannel>;
 private:
   MicroChannel(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_column;
   int m_row;
   TaggerHitList m_taggerHit_list;
   TaggerTruthHitList m_taggerTruthHit_list;
};

typedef HDDM_ElementList<MicroChannel> MicroChannelList;
typedef HDDM_ElementLink<MicroChannel> MicroChannelLink;

class HodoChannel: public HDDM_Element {
 public:
   ~HodoChannel();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   int getCounterId() const;
   void setCounterId(int counterId);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   TaggerHit &getTaggerHit(int index=0);
   TaggerHitList &getTaggerHits();
   TaggerHitList addTaggerHits(int count=1, int start=-1);
   void deleteTaggerHits(int count=-1, int start=0);
   TaggerTruthHit &getTaggerTruthHit(int index=0);
   TaggerTruthHitList &getTaggerTruthHits();
   TaggerTruthHitList addTaggerTruthHits(int count=1, int start=-1);
   void deleteTaggerTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<HodoChannel>;
   friend class HDDM_ElementLink<HodoChannel>;
 private:
   HodoChannel(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_counterId;
   TaggerHitList m_taggerHit_list;
   TaggerTruthHitList m_taggerTruthHit_list;
};

typedef HDDM_ElementList<HodoChannel> HodoChannelList;
typedef HDDM_ElementLink<HodoChannel> HodoChannelLink;

class Tagger: public HDDM_Element {
 public:
   ~Tagger();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   MicroChannel &getMicroChannel(int index=0);
   MicroChannelList &getMicroChannels();
   MicroChannelList addMicroChannels(int count=1, int start=-1);
   void deleteMicroChannels(int count=-1, int start=0);
   HodoChannel &getHodoChannel(int index=0);
   HodoChannelList &getHodoChannels();
   HodoChannelList addHodoChannels(int count=1, int start=-1);
   void deleteHodoChannels(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Tagger>;
   friend class HDDM_ElementLink<Tagger>;
 private:
   Tagger(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   MicroChannelList m_microChannel_list;
   HodoChannelList m_hodoChannel_list;
};

typedef HDDM_ElementList<Tagger> TaggerList;
typedef HDDM_ElementLink<Tagger> TaggerLink;

class PsHit: public HDDM_Element {
 public:
   ~PsHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getArm() const;
   int getColumn() const;
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PsHit>;
   friend class HDDM_ElementLink<PsHit>;
 private:
   PsHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   float m_t;
};

typedef HDDM_ElementList<PsHit> PsHitList;
typedef HDDM_ElementLink<PsHit> PsHitLink;

class PsTruthHit: public HDDM_Element {
 public:
   ~PsTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getArm() const;
   int getColumn() const;
   float getDE() const;
   void setDE(float dE);
   int getItrack() const;
   void setItrack(int itrack);
   std::string getMaxOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PsTruthHit>;
   friend class HDDM_ElementLink<PsTruthHit>;
 private:
   PsTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   int m_itrack;
   int m_ptype;
   float m_t;
};

typedef HDDM_ElementList<PsTruthHit> PsTruthHitList;
typedef HDDM_ElementLink<PsTruthHit> PsTruthHitLink;

class PsTile: public HDDM_Element {
 public:
   ~PsTile();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getArm() const;
   void setArm(int arm);
   int getColumn() const;
   void setColumn(int column);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   PsHit &getPsHit(int index=0);
   PsHitList &getPsHits();
   PsHitList addPsHits(int count=1, int start=-1);
   void deletePsHits(int count=-1, int start=0);
   PsTruthHit &getPsTruthHit(int index=0);
   PsTruthHitList &getPsTruthHits();
   PsTruthHitList addPsTruthHits(int count=1, int start=-1);
   void deletePsTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PsTile>;
   friend class HDDM_ElementLink<PsTile>;
 private:
   PsTile(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_arm;
   int m_column;
   PsHitList m_psHit_list;
   PsTruthHitList m_psTruthHit_list;
};

typedef HDDM_ElementList<PsTile> PsTileList;
typedef HDDM_ElementLink<PsTile> PsTileLink;

class PsTruthPoint: public HDDM_Element {
 public:
   ~PsTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   int getArm() const;
   void setArm(int arm);
   int getColumn() const;
   void setColumn(int column);
   float getDEdx() const;
   void setDEdx(float dEdx);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PsTruthPoint>;
   friend class HDDM_ElementLink<PsTruthPoint>;
 private:
   PsTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_arm;
   int m_column;
   float m_dEdx;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<PsTruthPoint> PsTruthPointList;
typedef HDDM_ElementLink<PsTruthPoint> PsTruthPointLink;

class PairSpectrometerFine: public HDDM_Element {
 public:
   ~PairSpectrometerFine();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   PsTile &getPsTile(int index=0);
   PsTileList &getPsTiles();
   PsTileList addPsTiles(int count=1, int start=-1);
   void deletePsTiles(int count=-1, int start=0);
   PsTruthPoint &getPsTruthPoint(int index=0);
   PsTruthPointList &getPsTruthPoints();
   PsTruthPointList addPsTruthPoints(int count=1, int start=-1);
   void deletePsTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PairSpectrometerFine>;
   friend class HDDM_ElementLink<PairSpectrometerFine>;
 private:
   PairSpectrometerFine(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   PsTileList m_psTile_list;
   PsTruthPointList m_psTruthPoint_list;
};

typedef HDDM_ElementList<PairSpectrometerFine> PairSpectrometerFineList;
typedef HDDM_ElementLink<PairSpectrometerFine> PairSpectrometerFineLink;

class PscHit: public HDDM_Element {
 public:
   ~PscHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getArm() const;
   int getModule() const;
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PscHit>;
   friend class HDDM_ElementLink<PscHit>;
 private:
   PscHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   float m_t;
};

typedef HDDM_ElementList<PscHit> PscHitList;
typedef HDDM_ElementLink<PscHit> PscHitLink;

class PscTruthHit: public HDDM_Element {
 public:
   ~PscTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getArm() const;
   int getModule() const;
   float getDE() const;
   void setDE(float dE);
   int getItrack() const;
   void setItrack(int itrack);
   std::string getMaxOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PscTruthHit>;
   friend class HDDM_ElementLink<PscTruthHit>;
 private:
   PscTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   int m_itrack;
   int m_ptype;
   float m_t;
};

typedef HDDM_ElementList<PscTruthHit> PscTruthHitList;
typedef HDDM_ElementLink<PscTruthHit> PscTruthHitLink;

class PscPaddle: public HDDM_Element {
 public:
   ~PscPaddle();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getArm() const;
   void setArm(int arm);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getModule() const;
   void setModule(int module);
   PscHit &getPscHit(int index=0);
   PscHitList &getPscHits();
   PscHitList addPscHits(int count=1, int start=-1);
   void deletePscHits(int count=-1, int start=0);
   PscTruthHit &getPscTruthHit(int index=0);
   PscTruthHitList &getPscTruthHits();
   PscTruthHitList addPscTruthHits(int count=1, int start=-1);
   void deletePscTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PscPaddle>;
   friend class HDDM_ElementLink<PscPaddle>;
 private:
   PscPaddle(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_arm;
   int m_module;
   PscHitList m_pscHit_list;
   PscTruthHitList m_pscTruthHit_list;
};

typedef HDDM_ElementList<PscPaddle> PscPaddleList;
typedef HDDM_ElementLink<PscPaddle> PscPaddleLink;

class PscTruthPoint: public HDDM_Element {
 public:
   ~PscTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   int getArm() const;
   void setArm(int arm);
   float getDEdx() const;
   void setDEdx(float dEdx);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getModule() const;
   void setModule(int module);
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PscTruthPoint>;
   friend class HDDM_ElementLink<PscTruthPoint>;
 private:
   PscTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_arm;
   float m_dEdx;
   int m_module;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<PscTruthPoint> PscTruthPointList;
typedef HDDM_ElementLink<PscTruthPoint> PscTruthPointLink;

class PairSpectrometerCoarse: public HDDM_Element {
 public:
   ~PairSpectrometerCoarse();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   PscPaddle &getPscPaddle(int index=0);
   PscPaddleList &getPscPaddles();
   PscPaddleList addPscPaddles(int count=1, int start=-1);
   void deletePscPaddles(int count=-1, int start=0);
   PscTruthPoint &getPscTruthPoint(int index=0);
   PscTruthPointList &getPscTruthPoints();
   PscTruthPointList addPscTruthPoints(int count=1, int start=-1);
   void deletePscTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PairSpectrometerCoarse>;
   friend class HDDM_ElementLink<PairSpectrometerCoarse>;
 private:
   PairSpectrometerCoarse(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   PscPaddleList m_pscPaddle_list;
   PscTruthPointList m_pscTruthPoint_list;
};

typedef HDDM_ElementList<PairSpectrometerCoarse> PairSpectrometerCoarseList;
typedef HDDM_ElementLink<PairSpectrometerCoarse> PairSpectrometerCoarseLink;

class TpolHit: public HDDM_Element {
 public:
   ~TpolHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getRing() const;
   int getSector() const;
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TpolHit>;
   friend class HDDM_ElementLink<TpolHit>;
 private:
   TpolHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   float m_t;
};

typedef HDDM_ElementList<TpolHit> TpolHitList;
typedef HDDM_ElementLink<TpolHit> TpolHitLink;

class TpolTruthHit: public HDDM_Element {
 public:
   ~TpolTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getRing() const;
   int getSector() const;
   float getDE() const;
   void setDE(float dE);
   int getItrack() const;
   void setItrack(int itrack);
   std::string getMaxOccurs() const;
   int getPtype() const;
   void setPtype(int ptype);
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TpolTruthHit>;
   friend class HDDM_ElementLink<TpolTruthHit>;
 private:
   TpolTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   int m_itrack;
   int m_ptype;
   float m_t;
};

typedef HDDM_ElementList<TpolTruthHit> TpolTruthHitList;
typedef HDDM_ElementLink<TpolTruthHit> TpolTruthHitLink;

class TpolSector: public HDDM_Element {
 public:
   ~TpolSector();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getRing() const;
   void setRing(int ring);
   int getSector() const;
   void setSector(int sector);
   TpolHit &getTpolHit(int index=0);
   TpolHitList &getTpolHits();
   TpolHitList addTpolHits(int count=1, int start=-1);
   void deleteTpolHits(int count=-1, int start=0);
   TpolTruthHit &getTpolTruthHit(int index=0);
   TpolTruthHitList &getTpolTruthHits();
   TpolTruthHitList addTpolTruthHits(int count=1, int start=-1);
   void deleteTpolTruthHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TpolSector>;
   friend class HDDM_ElementLink<TpolSector>;
 private:
   TpolSector(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_ring;
   int m_sector;
   TpolHitList m_tpolHit_list;
   TpolTruthHitList m_tpolTruthHit_list;
};

typedef HDDM_ElementList<TpolSector> TpolSectorList;
typedef HDDM_ElementLink<TpolSector> TpolSectorLink;

class TpolTruthPoint: public HDDM_Element {
 public:
   ~TpolTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   float getDEdx() const;
   void setDEdx(float dEdx);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getPhi() const;
   void setPhi(float phi);
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getR() const;
   void setR(float r);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TpolTruthPoint>;
   friend class HDDM_ElementLink<TpolTruthPoint>;
 private:
   TpolTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_dEdx;
   float m_phi;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_r;
   float m_t;
   int m_track;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<TpolTruthPoint> TpolTruthPointList;
typedef HDDM_ElementLink<TpolTruthPoint> TpolTruthPointLink;

class TripletPolarimeter: public HDDM_Element {
 public:
   ~TripletPolarimeter();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   TpolSector &getTpolSector(int index=0);
   TpolSectorList &getTpolSectors();
   TpolSectorList addTpolSectors(int count=1, int start=-1);
   void deleteTpolSectors(int count=-1, int start=0);
   TpolTruthPoint &getTpolTruthPoint(int index=0);
   TpolTruthPointList &getTpolTruthPoints();
   TpolTruthPointList addTpolTruthPoints(int count=1, int start=-1);
   void deleteTpolTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TripletPolarimeter>;
   friend class HDDM_ElementLink<TripletPolarimeter>;
 private:
   TripletPolarimeter(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   TpolSectorList m_tpolSector_list;
   TpolTruthPointList m_tpolTruthPoint_list;
};

typedef HDDM_ElementList<TripletPolarimeter> TripletPolarimeterList;
typedef HDDM_ElementLink<TripletPolarimeter> TripletPolarimeterLink;

class McTrajectoryPoint: public HDDM_Element {
 public:
   ~McTrajectoryPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   int getMech() const;
   void setMech(int mech);
   int getMinOccurs() const;
   int getPart() const;
   void setPart(int part);
   int getPrimary_track() const;
   void setPrimary_track(int primary_track);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getRadlen() const;
   void setRadlen(float radlen);
   float getStep() const;
   void setStep(float step);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<McTrajectoryPoint>;
   friend class HDDM_ElementLink<McTrajectoryPoint>;
 private:
   McTrajectoryPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   float m_dE;
   int m_mech;
   int m_part;
   int m_primary_track;
   float m_px;
   float m_py;
   float m_pz;
   float m_radlen;
   float m_step;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
};

typedef HDDM_ElementList<McTrajectoryPoint> McTrajectoryPointList;
typedef HDDM_ElementLink<McTrajectoryPoint> McTrajectoryPointLink;

class McTrajectory: public HDDM_Element {
 public:
   ~McTrajectory();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   McTrajectoryPoint &getMcTrajectoryPoint(int index=0);
   McTrajectoryPointList &getMcTrajectoryPoints();
   McTrajectoryPointList addMcTrajectoryPoints(int count=1, int start=-1);
   void deleteMcTrajectoryPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<McTrajectory>;
   friend class HDDM_ElementLink<McTrajectory>;
 private:
   McTrajectory(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   McTrajectoryPointList m_mcTrajectoryPoint_list;
};

typedef HDDM_ElementList<McTrajectory> McTrajectoryList;
typedef HDDM_ElementLink<McTrajectory> McTrajectoryLink;

class RFsubsystem: public HDDM_Element {
 public:
   ~RFsubsystem();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   std::string getJtag() const;
   void setJtag(const std::string &jtag);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   float getTsync() const;
   void setTsync(float tsync);
   std::string getTunit() const;
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<RFsubsystem>;
   friend class HDDM_ElementLink<RFsubsystem>;
 private:
   RFsubsystem(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   std::string m_jtag;
   float m_tsync;
};

typedef HDDM_ElementList<RFsubsystem> RFsubsystemList;
typedef HDDM_ElementLink<RFsubsystem> RFsubsystemLink;

class RFtime: public HDDM_Element {
 public:
   ~RFtime();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   std::string getJtag() const;
   void setJtag(const std::string &jtag);
   int getMinOccurs() const;
   float getTsync() const;
   void setTsync(float tsync);
   std::string getTunit() const;
   RFsubsystem &getRFsubsystem(int index=0);
   RFsubsystemList &getRFsubsystems();
   RFsubsystemList addRFsubsystems(int count=1, int start=-1);
   void deleteRFsubsystems(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<RFtime>;
   friend class HDDM_ElementLink<RFtime>;
 private:
   RFtime(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   std::string m_jtag;
   float m_tsync;
   RFsubsystemList m_RFsubsystem_list;
};

typedef HDDM_ElementList<RFtime> RFtimeList;
typedef HDDM_ElementLink<RFtime> RFtimeLink;

class FmwpcTruthHit: public HDDM_Element {
 public:
   ~FmwpcTruthHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getLayer() const;
   int getWire() const;
   float getDE() const;
   void setDE(float dE);
   float getDx() const;
   void setDx(float dx);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FmwpcTruthHit>;
   friend class HDDM_ElementLink<FmwpcTruthHit>;
 private:
   FmwpcTruthHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   float m_dx;
   float m_t;
};

typedef HDDM_ElementList<FmwpcTruthHit> FmwpcTruthHitList;
typedef HDDM_ElementLink<FmwpcTruthHit> FmwpcTruthHitLink;

class FmwpcHit: public HDDM_Element {
 public:
   ~FmwpcHit();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getMinOccurs() const;
   int getLayer() const;
   int getWire() const;
   float getDE() const;
   void setDE(float dE);
   std::string getMaxOccurs() const;
   float getT() const;
   void setT(float t);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FmwpcHit>;
   friend class HDDM_ElementLink<FmwpcHit>;
 private:
   FmwpcHit(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_dE;
   float m_t;
};

typedef HDDM_ElementList<FmwpcHit> FmwpcHitList;
typedef HDDM_ElementLink<FmwpcHit> FmwpcHitLink;

class FmwpcChamber: public HDDM_Element {
 public:
   ~FmwpcChamber();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   int getLayer() const;
   void setLayer(int layer);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getWire() const;
   void setWire(int wire);
   FmwpcTruthHit &getFmwpcTruthHit(int index=0);
   FmwpcTruthHitList &getFmwpcTruthHits();
   FmwpcTruthHitList addFmwpcTruthHits(int count=1, int start=-1);
   void deleteFmwpcTruthHits(int count=-1, int start=0);
   FmwpcHit &getFmwpcHit(int index=0);
   FmwpcHitList &getFmwpcHits();
   FmwpcHitList addFmwpcHits(int count=1, int start=-1);
   void deleteFmwpcHits(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FmwpcChamber>;
   friend class HDDM_ElementLink<FmwpcChamber>;
 private:
   FmwpcChamber(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_layer;
   int m_wire;
   FmwpcTruthHitList m_fmwpcTruthHit_list;
   FmwpcHitList m_fmwpcHit_list;
};

typedef HDDM_ElementList<FmwpcChamber> FmwpcChamberList;
typedef HDDM_ElementLink<FmwpcChamber> FmwpcChamberLink;

class FmwpcTruthPoint: public HDDM_Element {
 public:
   ~FmwpcTruthPoint();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getE() const;
   void setE(float E);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   bool getPrimary() const;
   void setPrimary(bool primary);
   int getPtype() const;
   void setPtype(int ptype);
   float getPx() const;
   void setPx(float px);
   float getPy() const;
   void setPy(float py);
   float getPz() const;
   void setPz(float pz);
   float getT() const;
   void setT(float t);
   int getTrack() const;
   void setTrack(int track);
   float getX() const;
   void setX(float x);
   float getY() const;
   void setY(float y);
   float getZ() const;
   void setZ(float z);
   TrackID &getTrackID();
   TrackIDList &getTrackIDs();
   TrackIDList addTrackIDs(int count=1, int start=-1);
   void deleteTrackIDs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<FmwpcTruthPoint>;
   friend class HDDM_ElementLink<FmwpcTruthPoint>;
 private:
   FmwpcTruthPoint(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_E;
   int m_primary;
   int m_ptype;
   float m_px;
   float m_py;
   float m_pz;
   float m_t;
   int m_track;
   float m_x;
   float m_y;
   float m_z;
   TrackIDLink m_trackID_link;
};

typedef HDDM_ElementList<FmwpcTruthPoint> FmwpcTruthPointList;
typedef HDDM_ElementLink<FmwpcTruthPoint> FmwpcTruthPointLink;

class ForwardMWPC: public HDDM_Element {
 public:
   ~ForwardMWPC();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   FmwpcChamber &getFmwpcChamber(int index=0);
   FmwpcChamberList &getFmwpcChambers();
   FmwpcChamberList addFmwpcChambers(int count=1, int start=-1);
   void deleteFmwpcChambers(int count=-1, int start=0);
   FmwpcTruthPoint &getFmwpcTruthPoint(int index=0);
   FmwpcTruthPointList &getFmwpcTruthPoints();
   FmwpcTruthPointList addFmwpcTruthPoints(int count=1, int start=-1);
   void deleteFmwpcTruthPoints(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<ForwardMWPC>;
   friend class HDDM_ElementLink<ForwardMWPC>;
 private:
   ForwardMWPC(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   FmwpcChamberList m_fmwpcChamber_list;
   FmwpcTruthPointList m_fmwpcTruthPoint_list;
};

typedef HDDM_ElementList<ForwardMWPC> ForwardMWPCList;
typedef HDDM_ElementLink<ForwardMWPC> ForwardMWPCLink;

class HitView: public HDDM_Element {
 public:
   ~HitView();
   std::string getClass() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   float getVersion() const;
   CentralDC &getCentralDC();
   CentralDCList &getCentralDCs();
   CentralDCList addCentralDCs(int count=1, int start=-1);
   void deleteCentralDCs(int count=-1, int start=0);
   ForwardDC &getForwardDC();
   ForwardDCList &getForwardDCs();
   ForwardDCList addForwardDCs(int count=1, int start=-1);
   void deleteForwardDCs(int count=-1, int start=0);
   StartCntr &getStartCntr();
   StartCntrList &getStartCntrs();
   StartCntrList addStartCntrs(int count=1, int start=-1);
   void deleteStartCntrs(int count=-1, int start=0);
   BarrelEMcal &getBarrelEMcal();
   BarrelEMcalList &getBarrelEMcals();
   BarrelEMcalList addBarrelEMcals(int count=1, int start=-1);
   void deleteBarrelEMcals(int count=-1, int start=0);
   GapEMcal &getGapEMcal();
   GapEMcalList &getGapEMcals();
   GapEMcalList addGapEMcals(int count=1, int start=-1);
   void deleteGapEMcals(int count=-1, int start=0);
   Cerenkov &getCerenkov();
   CerenkovList &getCerenkovs();
   CerenkovList addCerenkovs(int count=1, int start=-1);
   void deleteCerenkovs(int count=-1, int start=0);
   RICH &getRICH();
   RICHList &getRICHs();
   RICHList addRICHs(int count=1, int start=-1);
   void deleteRICHs(int count=-1, int start=0);
   DIRC &getDIRC();
   DIRCList &getDIRCs();
   DIRCList addDIRCs(int count=1, int start=-1);
   void deleteDIRCs(int count=-1, int start=0);
   ForwardTOF &getForwardTOF();
   ForwardTOFList &getForwardTOFs();
   ForwardTOFList addForwardTOFs(int count=1, int start=-1);
   void deleteForwardTOFs(int count=-1, int start=0);
   ForwardEMcal &getForwardEMcal();
   ForwardEMcalList &getForwardEMcals();
   ForwardEMcalList addForwardEMcals(int count=1, int start=-1);
   void deleteForwardEMcals(int count=-1, int start=0);
   ComptonEMcal &getComptonEMcal();
   ComptonEMcalList &getComptonEMcals();
   ComptonEMcalList addComptonEMcals(int count=1, int start=-1);
   void deleteComptonEMcals(int count=-1, int start=0);
   UpstreamEMveto &getUpstreamEMveto();
   UpstreamEMvetoList &getUpstreamEMvetos();
   UpstreamEMvetoList addUpstreamEMvetos(int count=1, int start=-1);
   void deleteUpstreamEMvetos(int count=-1, int start=0);
   Tagger &getTagger();
   TaggerList &getTaggers();
   TaggerList addTaggers(int count=1, int start=-1);
   void deleteTaggers(int count=-1, int start=0);
   PairSpectrometerFine &getPairSpectrometerFine();
   PairSpectrometerFineList &getPairSpectrometerFines();
   PairSpectrometerFineList addPairSpectrometerFines(int count=1, int start=-1);
   void deletePairSpectrometerFines(int count=-1, int start=0);
   PairSpectrometerCoarse &getPairSpectrometerCoarse();
   PairSpectrometerCoarseList &getPairSpectrometerCoarses();
   PairSpectrometerCoarseList addPairSpectrometerCoarses(int count=1, int start=-1);
   void deletePairSpectrometerCoarses(int count=-1, int start=0);
   TripletPolarimeter &getTripletPolarimeter();
   TripletPolarimeterList &getTripletPolarimeters();
   TripletPolarimeterList addTripletPolarimeters(int count=1, int start=-1);
   void deleteTripletPolarimeters(int count=-1, int start=0);
   McTrajectory &getMcTrajectory();
   McTrajectoryList &getMcTrajectorys();
   McTrajectoryList addMcTrajectorys(int count=1, int start=-1);
   void deleteMcTrajectorys(int count=-1, int start=0);
   RFtime &getRFtime();
   RFtimeList &getRFtimes();
   RFtimeList addRFtimes(int count=1, int start=-1);
   void deleteRFtimes(int count=-1, int start=0);
   ForwardMWPC &getForwardMWPC();
   ForwardMWPCList &getForwardMWPCs();
   ForwardMWPCList addForwardMWPCs(int count=1, int start=-1);
   void deleteForwardMWPCs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<HitView>;
   friend class HDDM_ElementLink<HitView>;
 private:
   HitView(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   CentralDCLink m_centralDC_link;
   ForwardDCLink m_forwardDC_link;
   StartCntrLink m_startCntr_link;
   BarrelEMcalLink m_barrelEMcal_link;
   GapEMcalLink m_gapEMcal_link;
   CerenkovLink m_Cerenkov_link;
   RICHLink m_RICH_link;
   DIRCLink m_DIRC_link;
   ForwardTOFLink m_forwardTOF_link;
   ForwardEMcalLink m_forwardEMcal_link;
   ComptonEMcalLink m_ComptonEMcal_link;
   UpstreamEMvetoLink m_upstreamEMveto_link;
   TaggerLink m_tagger_link;
   PairSpectrometerFineLink m_pairSpectrometerFine_link;
   PairSpectrometerCoarseLink m_pairSpectrometerCoarse_link;
   TripletPolarimeterLink m_tripletPolarimeter_link;
   McTrajectoryLink m_mcTrajectory_link;
   RFtimeLink m_RFtime_link;
   ForwardMWPCLink m_forwardMWPC_link;
};

typedef HDDM_ElementList<HitView> HitViewList;
typedef HDDM_ElementLink<HitView> HitViewLink;

class ErrorMatrix: public HDDM_Element {
 public:
   ~ErrorMatrix();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   float getFOM() const;
   int getNdof() const;
   int getCandidateid() const;
   float getChisq() const;
   int getId() const;
   int getTrackid() const;
   int getNcols() const;
   void setNcols(int Ncols);
   int getNrows() const;
   void setNrows(int Nrows);
   std::string getType() const;
   void setType(const std::string &type);
   std::string getVals() const;
   void setVals(const std::string &vals);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<ErrorMatrix>;
   friend class HDDM_ElementLink<ErrorMatrix>;
 private:
   ErrorMatrix(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_Ncols;
   int m_Nrows;
   std::string m_type;
   std::string m_vals;
};

typedef HDDM_ElementList<ErrorMatrix> ErrorMatrixList;
typedef HDDM_ElementLink<ErrorMatrix> ErrorMatrixLink;

class TrackingErrorMatrix: public HDDM_Element {
 public:
   ~TrackingErrorMatrix();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   float getFOM() const;
   int getNdof() const;
   int getCandidateid() const;
   float getChisq() const;
   int getId() const;
   int getTrackid() const;
   int getNcols() const;
   void setNcols(int Ncols);
   int getNrows() const;
   void setNrows(int Nrows);
   std::string getType() const;
   void setType(const std::string &type);
   std::string getVals() const;
   void setVals(const std::string &vals);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<TrackingErrorMatrix>;
   friend class HDDM_ElementLink<TrackingErrorMatrix>;
 private:
   TrackingErrorMatrix(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_Ncols;
   int m_Nrows;
   std::string m_type;
   std::string m_vals;
};

typedef HDDM_ElementList<TrackingErrorMatrix> TrackingErrorMatrixList;
typedef HDDM_ElementLink<TrackingErrorMatrix> TrackingErrorMatrixLink;

class Tracktimebased: public HDDM_Element {
 public:
   ~Tracktimebased();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   int getRunNo() const;
   float getFOM() const;
   void setFOM(float FOM);
   int getNdof() const;
   void setNdof(int Ndof);
   int getCandidateid() const;
   void setCandidateid(int candidateid);
   float getChisq() const;
   void setChisq(float chisq);
   int getId() const;
   void setId(int id);
   std::string getMaxOccurs() const;
   int getMinOccurs() const;
   int getTrackid() const;
   void setTrackid(int trackid);
   Momentum &getMomentum();
   MomentumList &getMomenta();
   MomentumList addMomenta(int count=1, int start=-1);
   void deleteMomenta(int count=-1, int start=0);
   Properties &getProperties();
   PropertiesList &getPropertiesList();
   PropertiesList addPropertiesList(int count=1, int start=-1);
   void deletePropertiesList(int count=-1, int start=0);
   Origin &getOrigin();
   OriginList &getOrigins();
   OriginList addOrigins(int count=1, int start=-1);
   void deleteOrigins(int count=-1, int start=0);
   ErrorMatrix &getErrorMatrix();
   ErrorMatrixList &getErrorMatrixs();
   ErrorMatrixList addErrorMatrixs(int count=1, int start=-1);
   void deleteErrorMatrixs(int count=-1, int start=0);
   TrackingErrorMatrix &getTrackingErrorMatrix();
   TrackingErrorMatrixList &getTrackingErrorMatrixs();
   TrackingErrorMatrixList addTrackingErrorMatrixs(int count=1, int start=-1);
   void deleteTrackingErrorMatrixs(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<Tracktimebased>;
   friend class HDDM_ElementLink<Tracktimebased>;
 private:
   Tracktimebased(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   float m_FOM;
   int m_Ndof;
   int m_candidateid;
   float m_chisq;
   int m_id;
   int m_trackid;
   MomentumLink m_momentum_link;
   PropertiesLink m_properties_link;
   OriginLink m_origin_link;
   ErrorMatrixLink m_errorMatrix_link;
   TrackingErrorMatrixLink m_TrackingErrorMatrix_link;
};

typedef HDDM_ElementList<Tracktimebased> TracktimebasedList;
typedef HDDM_ElementLink<Tracktimebased> TracktimebasedLink;

class ReconView: public HDDM_Element {
 public:
   ~ReconView();
   std::string getClass() const;
   std::string getXmlns() const;
   int getEventNo() const;
   std::string getMaxOccurs() const;
   int getRunNo() const;
   int getMinOccurs() const;
   float getVersion() const;
   Tracktimebased &getTracktimebased(int index=0);
   TracktimebasedList &getTracktimebaseds();
   TracktimebasedList addTracktimebaseds(int count=1, int start=-1);
   void deleteTracktimebaseds(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<ReconView>;
   friend class HDDM_ElementLink<ReconView>;
 private:
   ReconView(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   TracktimebasedList m_tracktimebased_list;
};

typedef HDDM_ElementList<ReconView> ReconViewList;
typedef HDDM_ElementLink<ReconView> ReconViewLink;

class PhysicsEvent: public HDDM_Element {
 public:
   ~PhysicsEvent();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   int getEventNo() const;
   void setEventNo(int eventNo);
   std::string getMaxOccurs() const;
   int getRunNo() const;
   void setRunNo(int runNo);
   DataVersionString &getDataVersionString(int index=0);
   DataVersionStringList &getDataVersionStrings();
   DataVersionStringList addDataVersionStrings(int count=1, int start=-1);
   void deleteDataVersionStrings(int count=-1, int start=0);
   CcdbContext &getCcdbContext(int index=0);
   CcdbContextList &getCcdbContexts();
   CcdbContextList addCcdbContexts(int count=1, int start=-1);
   void deleteCcdbContexts(int count=-1, int start=0);
   Reaction &getReaction(int index=0);
   ReactionList &getReactions();
   ReactionList addReactions(int count=1, int start=-1);
   void deleteReactions(int count=-1, int start=0);
   HitView &getHitView();
   HitViewList &getHitViews();
   HitViewList addHitViews(int count=1, int start=-1);
   void deleteHitViews(int count=-1, int start=0);
   ReconView &getReconView();
   ReconViewList &getReconViews();
   ReconViewList addReconViews(int count=1, int start=-1);
   void deleteReconViews(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   friend class HDDM_ElementList<PhysicsEvent>;
   friend class HDDM_ElementLink<PhysicsEvent>;
 private:
   PhysicsEvent(HDDM_Element *parent=0);
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   int m_eventNo;
   int m_runNo;
   DataVersionStringList m_dataVersionString_list;
   CcdbContextList m_ccdbContext_list;
   ReactionList m_reaction_list;
   HitViewLink m_hitView_link;
   ReconViewLink m_reconView_link;
};

typedef HDDM_ElementList<PhysicsEvent> PhysicsEventList;
typedef HDDM_ElementLink<PhysicsEvent> PhysicsEventLink;

class HDDM: public HDDM_Element {
 public:
   HDDM();
   ~HDDM();
   std::string getClass() const;
   float getVersion() const;
   std::string getXmlns() const;
   CerenkovList getCerenkovs();
   ComptonEMcalList getComptonEMcals();
   DIRCList getDIRCs();
   RFsubsystemList getRFsubsystems();
   RFtimeList getRFtimes();
   RICHList getRICHs();
   TrackingErrorMatrixList getTrackingErrorMatrixs();
   BarrelEMcalList getBarrelEMcals();
   BcalCellList getBcalCells();
   BcalSiPMDownHitList getBcalSiPMDownHits();
   BcalSiPMSpectrumList getBcalSiPMSpectrums();
   BcalSiPMTruthList getBcalSiPMTruths();
   BcalSiPMUpHitList getBcalSiPMUpHits();
   BcalTDCDigiHitList getBcalTDCDigiHits();
   BcalTDCHitList getBcalTDCHits();
   BcalTruthHitList getBcalTruthHits();
   BcalTruthIncidentParticleList getBcalTruthIncidentParticles();
   BcalTruthShowerList getBcalTruthShowers();
   BcalfADCDigiHitList getBcalfADCDigiHits();
   BcalfADCHitList getBcalfADCHits();
   BcalfADCPeakList getBcalfADCPeaks();
   BeamList getBeams();
   CcalBlockList getCcalBlocks();
   CcalHitList getCcalHits();
   CcalTruthHitList getCcalTruthHits();
   CcalTruthShowerList getCcalTruthShowers();
   CcdbContextList getCcdbContexts();
   CdcDigihitList getCdcDigihits();
   CdcHitQFList getCdcHitQFs();
   CdcStrawList getCdcStraws();
   CdcStrawHitList getCdcStrawHits();
   CdcStrawTruthHitList getCdcStrawTruthHits();
   CdcTruthPointList getCdcTruthPoints();
   CentralDCList getCentralDCs();
   CereHitList getCereHits();
   CereSectionList getCereSections();
   CereTruthHitList getCereTruthHits();
   CereTruthPointList getCereTruthPoints();
   DataVersionStringList getDataVersionStrings();
   DircPmtHitList getDircPmtHits();
   DircTruthBarHitList getDircTruthBarHits();
   DircTruthPmtHitList getDircTruthPmtHits();
   DircTruthPmtHitExtraList getDircTruthPmtHitExtras();
   ErrorMatrixList getErrorMatrixs();
   FcalBlockList getFcalBlocks();
   FcalDigihitList getFcalDigihits();
   FcalHitList getFcalHits();
   FcalTruthHitList getFcalTruthHits();
   FcalTruthLightGuideList getFcalTruthLightGuides();
   FcalTruthShowerList getFcalTruthShowers();
   FdcAnodeHitList getFdcAnodeHits();
   FdcAnodeTruthHitList getFdcAnodeTruthHits();
   FdcAnodeWireList getFdcAnodeWires();
   FdcCathodeHitList getFdcCathodeHits();
   FdcCathodeStripList getFdcCathodeStrips();
   FdcCathodeTruthHitList getFdcCathodeTruthHits();
   FdcChamberList getFdcChambers();
   FdcDigihitList getFdcDigihits();
   FdcTruthPointList getFdcTruthPoints();
   FmwpcChamberList getFmwpcChambers();
   FmwpcHitList getFmwpcHits();
   FmwpcTruthHitList getFmwpcTruthHits();
   FmwpcTruthPointList getFmwpcTruthPoints();
   ForwardDCList getForwardDCs();
   ForwardEMcalList getForwardEMcals();
   ForwardMWPCList getForwardMWPCs();
   ForwardTOFList getForwardTOFs();
   FtofCounterList getFtofCounters();
   FtofDigihitList getFtofDigihits();
   FtofHitList getFtofHits();
   FtofTruthExtraList getFtofTruthExtras();
   FtofTruthHitList getFtofTruthHits();
   FtofTruthPointList getFtofTruthPoints();
   GapEMcalList getGapEMcals();
   GcalCellList getGcalCells();
   GcalHitList getGcalHits();
   GcalTruthHitList getGcalTruthHits();
   GcalTruthShowerList getGcalTruthShowers();
   HitViewList getHitViews();
   HodoChannelList getHodoChannels();
   McTrajectoryList getMcTrajectorys();
   McTrajectoryPointList getMcTrajectoryPoints();
   MicroChannelList getMicroChannels();
   MomentumList getMomenta();
   OriginList getOrigins();
   PairSpectrometerCoarseList getPairSpectrometerCoarses();
   PairSpectrometerFineList getPairSpectrometerFines();
   PolarizationList getPolarizations();
   ProductList getProducts();
   PropertiesList getPropertiesList();
   PsHitList getPsHits();
   PsTileList getPsTiles();
   PsTruthHitList getPsTruthHits();
   PsTruthPointList getPsTruthPoints();
   PscHitList getPscHits();
   PscPaddleList getPscPaddles();
   PscTruthHitList getPscTruthHits();
   PscTruthPointList getPscTruthPoints();
   RandomList getRandoms();
   ReactionList getReactions();
   ReconViewList getReconViews();
   RichTruthHitList getRichTruthHits();
   RichTruthPointList getRichTruthPoints();
   StartCntrList getStartCntrs();
   StcDigihitList getStcDigihits();
   StcHitList getStcHits();
   StcPaddleList getStcPaddles();
   StcTruthHitList getStcTruthHits();
   StcTruthPointList getStcTruthPoints();
   TaggerList getTaggers();
   TaggerHitList getTaggerHits();
   TaggerTruthHitList getTaggerTruthHits();
   TargetList getTargets();
   TpolHitList getTpolHits();
   TpolSectorList getTpolSectors();
   TpolTruthHitList getTpolTruthHits();
   TpolTruthPointList getTpolTruthPoints();
   TrackIDList getTrackIDs();
   TracktimebasedList getTracktimebaseds();
   TripletPolarimeterList getTripletPolarimeters();
   UpstreamEMvetoList getUpstreamEMvetos();
   UpvHitList getUpvHits();
   UpvPaddleList getUpvPaddles();
   UpvTruthHitList getUpvTruthHits();
   UpvTruthShowerList getUpvTruthShowers();
   UserDataList getUserDatas();
   UserDataFloatList getUserDataFloats();
   UserDataIntList getUserDataInts();
   VertexList getVertices();
   Geometry &getGeometry();
   GeometryList &getGeometrys();
   GeometryList addGeometrys(int count=1, int start=-1);
   void deleteGeometrys(int count=-1, int start=0);
   PhysicsEvent &getPhysicsEvent(int index=0);
   PhysicsEventList &getPhysicsEvents();
   PhysicsEventList addPhysicsEvents(int count=1, int start=-1);
   void deletePhysicsEvents(int count=-1, int start=0);
   const void *getAttribute(const std::string &name, hddm_type *atype=0) const;
   std::string toString(int indent=0);
   std::string toXML(int indent=0);
   void clear();
   friend class Cerenkov;
   friend class ComptonEMcal;
   friend class DIRC;
   friend class RFsubsystem;
   friend class RFtime;
   friend class RICH;
   friend class TrackingErrorMatrix;
   friend class BarrelEMcal;
   friend class BcalCell;
   friend class BcalSiPMDownHit;
   friend class BcalSiPMSpectrum;
   friend class BcalSiPMTruth;
   friend class BcalSiPMUpHit;
   friend class BcalTDCDigiHit;
   friend class BcalTDCHit;
   friend class BcalTruthHit;
   friend class BcalTruthIncidentParticle;
   friend class BcalTruthShower;
   friend class BcalfADCDigiHit;
   friend class BcalfADCHit;
   friend class BcalfADCPeak;
   friend class Beam;
   friend class CcalBlock;
   friend class CcalHit;
   friend class CcalTruthHit;
   friend class CcalTruthShower;
   friend class CcdbContext;
   friend class CdcDigihit;
   friend class CdcHitQF;
   friend class CdcStraw;
   friend class CdcStrawHit;
   friend class CdcStrawTruthHit;
   friend class CdcTruthPoint;
   friend class CentralDC;
   friend class CereHit;
   friend class CereSection;
   friend class CereTruthHit;
   friend class CereTruthPoint;
   friend class DataVersionString;
   friend class DircPmtHit;
   friend class DircTruthBarHit;
   friend class DircTruthPmtHit;
   friend class DircTruthPmtHitExtra;
   friend class ErrorMatrix;
   friend class FcalBlock;
   friend class FcalDigihit;
   friend class FcalHit;
   friend class FcalTruthHit;
   friend class FcalTruthLightGuide;
   friend class FcalTruthShower;
   friend class FdcAnodeHit;
   friend class FdcAnodeTruthHit;
   friend class FdcAnodeWire;
   friend class FdcCathodeHit;
   friend class FdcCathodeStrip;
   friend class FdcCathodeTruthHit;
   friend class FdcChamber;
   friend class FdcDigihit;
   friend class FdcTruthPoint;
   friend class FmwpcChamber;
   friend class FmwpcHit;
   friend class FmwpcTruthHit;
   friend class FmwpcTruthPoint;
   friend class ForwardDC;
   friend class ForwardEMcal;
   friend class ForwardMWPC;
   friend class ForwardTOF;
   friend class FtofCounter;
   friend class FtofDigihit;
   friend class FtofHit;
   friend class FtofTruthExtra;
   friend class FtofTruthHit;
   friend class FtofTruthPoint;
   friend class GapEMcal;
   friend class GcalCell;
   friend class GcalHit;
   friend class GcalTruthHit;
   friend class GcalTruthShower;
   friend class Geometry;
   friend class HitView;
   friend class HodoChannel;
   friend class McTrajectory;
   friend class McTrajectoryPoint;
   friend class MicroChannel;
   friend class Momentum;
   friend class Origin;
   friend class PairSpectrometerCoarse;
   friend class PairSpectrometerFine;
   friend class PhysicsEvent;
   friend class Polarization;
   friend class Product;
   friend class Properties;
   friend class PsHit;
   friend class PsTile;
   friend class PsTruthHit;
   friend class PsTruthPoint;
   friend class PscHit;
   friend class PscPaddle;
   friend class PscTruthHit;
   friend class PscTruthPoint;
   friend class Random;
   friend class Reaction;
   friend class ReconView;
   friend class RichTruthHit;
   friend class RichTruthPoint;
   friend class StartCntr;
   friend class StcDigihit;
   friend class StcHit;
   friend class StcPaddle;
   friend class StcTruthHit;
   friend class StcTruthPoint;
   friend class Tagger;
   friend class TaggerHit;
   friend class TaggerTruthHit;
   friend class Target;
   friend class TpolHit;
   friend class TpolSector;
   friend class TpolTruthHit;
   friend class TpolTruthPoint;
   friend class TrackID;
   friend class Tracktimebased;
   friend class TripletPolarimeter;
   friend class UpstreamEMveto;
   friend class UpvHit;
   friend class UpvPaddle;
   friend class UpvTruthHit;
   friend class UpvTruthShower;
   friend class UserData;
   friend class UserDataFloat;
   friend class UserDataInt;
   friend class Vertex;
   static std::string DocumentString();
 private:
   void streamer(istream &istr);
   void streamer(ostream &ostr);
   std::list<Cerenkov*> m_Cerenkov_plist;
   std::list<ComptonEMcal*> m_ComptonEMcal_plist;
   std::list<DIRC*> m_DIRC_plist;
   std::list<RFsubsystem*> m_RFsubsystem_plist;
   std::list<RFtime*> m_RFtime_plist;
   std::list<RICH*> m_RICH_plist;
   std::list<TrackingErrorMatrix*> m_TrackingErrorMatrix_plist;
   std::list<BarrelEMcal*> m_barrelEMcal_plist;
   std::list<BcalCell*> m_bcalCell_plist;
   std::list<BcalSiPMDownHit*> m_bcalSiPMDownHit_plist;
   std::list<BcalSiPMSpectrum*> m_bcalSiPMSpectrum_plist;
   std::list<BcalSiPMTruth*> m_bcalSiPMTruth_plist;
   std::list<BcalSiPMUpHit*> m_bcalSiPMUpHit_plist;
   std::list<BcalTDCDigiHit*> m_bcalTDCDigiHit_plist;
   std::list<BcalTDCHit*> m_bcalTDCHit_plist;
   std::list<BcalTruthHit*> m_bcalTruthHit_plist;
   std::list<BcalTruthIncidentParticle*> m_bcalTruthIncidentParticle_plist;
   std::list<BcalTruthShower*> m_bcalTruthShower_plist;
   std::list<BcalfADCDigiHit*> m_bcalfADCDigiHit_plist;
   std::list<BcalfADCHit*> m_bcalfADCHit_plist;
   std::list<BcalfADCPeak*> m_bcalfADCPeak_plist;
   std::list<Beam*> m_beam_plist;
   std::list<CcalBlock*> m_ccalBlock_plist;
   std::list<CcalHit*> m_ccalHit_plist;
   std::list<CcalTruthHit*> m_ccalTruthHit_plist;
   std::list<CcalTruthShower*> m_ccalTruthShower_plist;
   std::list<CcdbContext*> m_ccdbContext_plist;
   std::list<CdcDigihit*> m_cdcDigihit_plist;
   std::list<CdcHitQF*> m_cdcHitQF_plist;
   std::list<CdcStraw*> m_cdcStraw_plist;
   std::list<CdcStrawHit*> m_cdcStrawHit_plist;
   std::list<CdcStrawTruthHit*> m_cdcStrawTruthHit_plist;
   std::list<CdcTruthPoint*> m_cdcTruthPoint_plist;
   std::list<CentralDC*> m_centralDC_plist;
   std::list<CereHit*> m_cereHit_plist;
   std::list<CereSection*> m_cereSection_plist;
   std::list<CereTruthHit*> m_cereTruthHit_plist;
   std::list<CereTruthPoint*> m_cereTruthPoint_plist;
   std::list<DataVersionString*> m_dataVersionString_plist;
   std::list<DircPmtHit*> m_dircPmtHit_plist;
   std::list<DircTruthBarHit*> m_dircTruthBarHit_plist;
   std::list<DircTruthPmtHit*> m_dircTruthPmtHit_plist;
   std::list<DircTruthPmtHitExtra*> m_dircTruthPmtHitExtra_plist;
   std::list<ErrorMatrix*> m_errorMatrix_plist;
   std::list<FcalBlock*> m_fcalBlock_plist;
   std::list<FcalDigihit*> m_fcalDigihit_plist;
   std::list<FcalHit*> m_fcalHit_plist;
   std::list<FcalTruthHit*> m_fcalTruthHit_plist;
   std::list<FcalTruthLightGuide*> m_fcalTruthLightGuide_plist;
   std::list<FcalTruthShower*> m_fcalTruthShower_plist;
   std::list<FdcAnodeHit*> m_fdcAnodeHit_plist;
   std::list<FdcAnodeTruthHit*> m_fdcAnodeTruthHit_plist;
   std::list<FdcAnodeWire*> m_fdcAnodeWire_plist;
   std::list<FdcCathodeHit*> m_fdcCathodeHit_plist;
   std::list<FdcCathodeStrip*> m_fdcCathodeStrip_plist;
   std::list<FdcCathodeTruthHit*> m_fdcCathodeTruthHit_plist;
   std::list<FdcChamber*> m_fdcChamber_plist;
   std::list<FdcDigihit*> m_fdcDigihit_plist;
   std::list<FdcTruthPoint*> m_fdcTruthPoint_plist;
   std::list<FmwpcChamber*> m_fmwpcChamber_plist;
   std::list<FmwpcHit*> m_fmwpcHit_plist;
   std::list<FmwpcTruthHit*> m_fmwpcTruthHit_plist;
   std::list<FmwpcTruthPoint*> m_fmwpcTruthPoint_plist;
   std::list<ForwardDC*> m_forwardDC_plist;
   std::list<ForwardEMcal*> m_forwardEMcal_plist;
   std::list<ForwardMWPC*> m_forwardMWPC_plist;
   std::list<ForwardTOF*> m_forwardTOF_plist;
   std::list<FtofCounter*> m_ftofCounter_plist;
   std::list<FtofDigihit*> m_ftofDigihit_plist;
   std::list<FtofHit*> m_ftofHit_plist;
   std::list<FtofTruthExtra*> m_ftofTruthExtra_plist;
   std::list<FtofTruthHit*> m_ftofTruthHit_plist;
   std::list<FtofTruthPoint*> m_ftofTruthPoint_plist;
   std::list<GapEMcal*> m_gapEMcal_plist;
   std::list<GcalCell*> m_gcalCell_plist;
   std::list<GcalHit*> m_gcalHit_plist;
   std::list<GcalTruthHit*> m_gcalTruthHit_plist;
   std::list<GcalTruthShower*> m_gcalTruthShower_plist;
   std::list<Geometry*> m_geometry_plist;
   std::list<HitView*> m_hitView_plist;
   std::list<HodoChannel*> m_hodoChannel_plist;
   std::list<McTrajectory*> m_mcTrajectory_plist;
   std::list<McTrajectoryPoint*> m_mcTrajectoryPoint_plist;
   std::list<MicroChannel*> m_microChannel_plist;
   std::list<Momentum*> m_momentum_plist;
   std::list<Origin*> m_origin_plist;
   std::list<PairSpectrometerCoarse*> m_pairSpectrometerCoarse_plist;
   std::list<PairSpectrometerFine*> m_pairSpectrometerFine_plist;
   std::list<PhysicsEvent*> m_physicsEvent_plist;
   std::list<Polarization*> m_polarization_plist;
   std::list<Product*> m_product_plist;
   std::list<Properties*> m_properties_plist;
   std::list<PsHit*> m_psHit_plist;
   std::list<PsTile*> m_psTile_plist;
   std::list<PsTruthHit*> m_psTruthHit_plist;
   std::list<PsTruthPoint*> m_psTruthPoint_plist;
   std::list<PscHit*> m_pscHit_plist;
   std::list<PscPaddle*> m_pscPaddle_plist;
   std::list<PscTruthHit*> m_pscTruthHit_plist;
   std::list<PscTruthPoint*> m_pscTruthPoint_plist;
   std::list<Random*> m_random_plist;
   std::list<Reaction*> m_reaction_plist;
   std::list<ReconView*> m_reconView_plist;
   std::list<RichTruthHit*> m_richTruthHit_plist;
   std::list<RichTruthPoint*> m_richTruthPoint_plist;
   std::list<StartCntr*> m_startCntr_plist;
   std::list<StcDigihit*> m_stcDigihit_plist;
   std::list<StcHit*> m_stcHit_plist;
   std::list<StcPaddle*> m_stcPaddle_plist;
   std::list<StcTruthHit*> m_stcTruthHit_plist;
   std::list<StcTruthPoint*> m_stcTruthPoint_plist;
   std::list<Tagger*> m_tagger_plist;
   std::list<TaggerHit*> m_taggerHit_plist;
   std::list<TaggerTruthHit*> m_taggerTruthHit_plist;
   std::list<Target*> m_target_plist;
   std::list<TpolHit*> m_tpolHit_plist;
   std::list<TpolSector*> m_tpolSector_plist;
   std::list<TpolTruthHit*> m_tpolTruthHit_plist;
   std::list<TpolTruthPoint*> m_tpolTruthPoint_plist;
   std::list<TrackID*> m_trackID_plist;
   std::list<Tracktimebased*> m_tracktimebased_plist;
   std::list<TripletPolarimeter*> m_tripletPolarimeter_plist;
   std::list<UpstreamEMveto*> m_upstreamEMveto_plist;
   std::list<UpvHit*> m_upvHit_plist;
   std::list<UpvPaddle*> m_upvPaddle_plist;
   std::list<UpvTruthHit*> m_upvTruthHit_plist;
   std::list<UpvTruthShower*> m_upvTruthShower_plist;
   std::list<UserData*> m_userData_plist;
   std::list<UserDataFloat*> m_userDataFloat_plist;
   std::list<UserDataInt*> m_userDataInt_plist;
   std::list<Vertex*> m_vertex_plist;
   GeometryLink m_geometry_link;
   PhysicsEventList m_physicsEvent_list;
};

inline istream::thread_private_data *istream::lookup_private_data() {
   thread_private_data *my_private = my_thread_private[threads::getID()];
   if (my_private != 0)
      return my_private;
   init_private_data();
   return my_thread_private[threads::ID];
}

inline ostream::thread_private_data *ostream::lookup_private_data() {
   thread_private_data *my_private = my_thread_private[threads::getID()];
   if (my_private != 0)
      return my_private;
   init_private_data();
   return my_thread_private[threads::ID];
}

inline void istream::skip(int count) {
   MY_SETUP
   MY(events_to_skip) += count;
}

inline bool istream::eof() {
   MY_SETUP
   return MY(hit_eof);
}

inline bool istream::operator!() {
   return eof();
}

inline istream::operator void*() {
   MY_SETUP
   if (MY(hit_eof))
      return NULL;
   else
      return this;
}

inline int istream::getCompression() const {
   return (int)m_status_bits & k_bits_compression;
}

inline int ostream::getCompression() const {
   return (int)m_status_bits & k_bits_compression;
}

inline int istream::getIntegrityChecks() const {
   return (int)m_status_bits & k_bits_integrity;
}

inline int istream::getBytesRead() const {
   int bytes = 0;
   for (int i=1; i < threads::max_threads; ++i)
      if (my_thread_private[i])
         bytes += my_thread_private[i]->m_bytes_read;
   return bytes;
}

inline int istream::getRecordsRead() const {
   int records = 0;
   for (int i=1; i < threads::max_threads; ++i)
      if (my_thread_private[i])
         records += my_thread_private[i]->m_records_read;
   return records;
}

inline int ostream::getIntegrityChecks() const {
   return (int)m_status_bits & k_bits_integrity;
}

inline int ostream::getBytesWritten() const {
   int bytes = 0;
   for (int i=1; i < threads::max_threads; ++i)
      if (my_thread_private[i])
         bytes += my_thread_private[i]->m_bytes_written;
   return bytes;
}

inline int ostream::getRecordsWritten() const {
   int records = 0;
   for (int i=1; i < threads::max_threads; ++i)
      if (my_thread_private[i])
         records += my_thread_private[i]->m_records_written;
   return records;
}

inline istream &istream::operator>>(streamable &object) {
   MY_SETUP
   if (MY(sequencing)) {
      MY(codon)->m_target.push_back(&object);
   }
   else {
      int size;
      *MY(xstr) >> size;
      if (size > 0) {
         std::streampos start = MY(sbuf)->tellg();
         sequencer(object);
         MY(sbuf)->seekg(start+(std::streamoff)size);
      }
   }
   return *this;
}

inline void istream::reset_sequencer() {
   MY_SETUP
   MY(sequencing) = 0;
}

inline void istream::sequencer(streamable &object) {
   MY_SETUP
   MY(sequencing) = 1;
   MY(codon)->m_target.clear();
   object.streamer(*this);
   if (MY(sequencing)) {
      MY(sequencing) = 0;
      codon &gene = *MY(codon);
      streamable null_streamable;
      gene.m_target.push_front(&null_streamable);
      chromosome::iterator iter;
      for (iter = gene.m_sequence.begin();
           iter != gene.m_sequence.end();
           ++iter)
      {
         MY(codon) = &(*iter);
         *this >> *gene.m_target[iter->m_order];
      }
      MY(codon) = &gene;
   }
}

inline ostream &ostream::operator<<(HDDM &record) {
   MY_SETUP
   MY(sbuf)->reset();
   *this << (streamable&)record;
   while (MY(sbuf)->size() == MY(event_buffer_size)) {
      delete MY(xstr);
      delete MY(sbuf);
      char *newbuf = new char[MY(event_buffer_size) *= 2];
      MY(sbuf) = new ostreambuffer(newbuf, MY(event_buffer_size));
      MY(xstr) = new xstream::xdr::ostream(MY(sbuf));
      delete [] MY(event_buffer);
      MY(event_buffer) = newbuf;
      *this << (streamable&)record;
   }
   lock_streambufs();
   update_streambufs();
   if ((MY(status_bits) & k_crc32_integrity) != 0) {
      xstream::digest::crc32 crc;
      std::ostream out(&crc);
      out.write(MY(sbuf)->getbuf(),MY(sbuf)->size());
      out.flush();
      unsigned int crc32 = crc.digest();
      *MY(xstr) << crc32;
   }
   MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());
   if (!MY(ostr)->good()) {
      unlock_streambufs();
      throw std::runtime_error("hddm_s::ostream::operator<< error - "
                               "write error on event output!");
   }
   if (MY(status_bits) & k_bz2_compression) {
      MY(last_start) = ((xstream::bz::ostreambuf*)MY(xcmp))->get_block_start();
      MY(last_offset) = ((xstream::bz::ostreambuf*)MY(xcmp))->get_block_offset();
   }
   else if (MY(status_bits) & k_z_compression) {
      MY(last_start) = ((xstream::z::ostreambuf*)MY(xcmp))->get_block_start();
      MY(last_offset) = ((xstream::z::ostreambuf*)MY(xcmp))->get_block_offset();
   }
   else {
      MY(last_start) = m_ostr.tellp();
      MY(last_offset) = 0;
   }
   unlock_streambufs();
   MY(bytes_written) += MY(sbuf)->size();
   MY(records_written)++;
   return *this;
}

inline ostream &ostream::operator<<(streamable &object) {
   MY_SETUP
   *MY(xstr) << 0;
   std::streampos start = MY(sbuf)->tellp();
   object.streamer(*this);
   std::streampos end = MY(sbuf)->tellp();
   MY(sbuf)->seekp(start-std::streamoff(4));
   *MY(xstr) << (int)(end-start);
   MY(sbuf)->seekp(end);
   return *this;
}

inline Geometry::Geometry(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_md5reconstruction(""),
   m_md5simulation(""),
   m_md5smear("")
{}

inline Geometry::~Geometry() {}

inline std::string Geometry::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Geometry::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Geometry::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Geometry::getMaxOccurs() const {
   return 1;
}

inline std::string Geometry::getMd5reconstruction() const {
   return m_md5reconstruction;
}

inline void Geometry::setMd5reconstruction(const std::string &md5reconstruction) {
   m_md5reconstruction = md5reconstruction;
}

inline std::string Geometry::getMd5simulation() const {
   return m_md5simulation;
}

inline void Geometry::setMd5simulation(const std::string &md5simulation) {
   m_md5simulation = md5simulation;
}

inline std::string Geometry::getMd5smear() const {
   return m_md5smear;
}

inline void Geometry::setMd5smear(const std::string &md5smear) {
   m_md5smear = md5smear;
}

inline int Geometry::getMinOccurs() const {
   return 0;
}

inline const void *Geometry::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "md5reconstruction") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_md5reconstruction;
   }
   if (name == "md5simulation") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_md5simulation;
   }
   if (name == "md5smear") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_md5smear;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline DataVersionString::DataVersionString(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_text("")
{}

inline DataVersionString::~DataVersionString() {}

inline std::string DataVersionString::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float DataVersionString::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string DataVersionString::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int DataVersionString::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int DataVersionString::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string DataVersionString::getMaxOccurs() const {
   return "unbounded";
}

inline int DataVersionString::getMinOccurs() const {
   return 0;
}

inline std::string DataVersionString::getText() const {
   return m_text;
}

inline void DataVersionString::setText(const std::string &text) {
   m_text = text;
}

inline const void *DataVersionString::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "text") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_text;
   }
   return m_parent->getAttribute(name, atype);
}

inline CcdbContext::CcdbContext(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_text("")
{}

inline CcdbContext::~CcdbContext() {}

inline std::string CcdbContext::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CcdbContext::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CcdbContext::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CcdbContext::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CcdbContext::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string CcdbContext::getMaxOccurs() const {
   return "unbounded";
}

inline int CcdbContext::getMinOccurs() const {
   return 0;
}

inline std::string CcdbContext::getText() const {
   return m_text;
}

inline void CcdbContext::setText(const std::string &text) {
   m_text = text;
}

inline const void *CcdbContext::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "text") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_text;
   }
   return m_parent->getAttribute(name, atype);
}

inline Momentum::Momentum(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_px(0),
   m_py(0),
   m_pz(0)
{}

inline Momentum::~Momentum() {}

inline std::string Momentum::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Momentum::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Momentum::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Momentum::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string Momentum::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int Momentum::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Momentum::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline float Momentum::getFOM() const {
   return *(float*)m_parent->getAttribute("FOM");
}

inline int Momentum::getNdof() const {
   return *(int*)m_parent->getAttribute("Ndof");
}

inline int Momentum::getCandidateid() const {
   return *(int*)m_parent->getAttribute("candidateid");
}

inline float Momentum::getChisq() const {
   return *(float*)m_parent->getAttribute("chisq");
}

inline int Momentum::getId() const {
   return *(int*)m_parent->getAttribute("id");
}

inline int Momentum::getTrackid() const {
   return *(int*)m_parent->getAttribute("trackid");
}

inline int Momentum::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float Momentum::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline int Momentum::getDecayVertex() const {
   return *(int*)m_parent->getAttribute("decayVertex");
}

inline int Momentum::getMech() const {
   return *(int*)m_parent->getAttribute("mech");
}

inline int Momentum::getParentid() const {
   return *(int*)m_parent->getAttribute("parentid");
}

inline int Momentum::getPdgtype() const {
   return *(int*)m_parent->getAttribute("pdgtype");
}

inline float Momentum::getE() const {
   return m_E;
}

inline void Momentum::setE(float E) {
   m_E = E;
}

inline float Momentum::getPx() const {
   return m_px;
}

inline void Momentum::setPx(float px) {
   m_px = px;
}

inline float Momentum::getPy() const {
   return m_py;
}

inline void Momentum::setPy(float py) {
   m_py = py;
}

inline float Momentum::getPz() const {
   return m_pz;
}

inline void Momentum::setPz(float pz) {
   m_pz = pz;
}

inline const void *Momentum::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   return m_parent->getAttribute(name, atype);
}

inline Polarization::Polarization(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_Px(0),
   m_Py(0),
   m_Pz(0)
{}

inline Polarization::~Polarization() {}

inline std::string Polarization::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Polarization::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Polarization::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Polarization::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string Polarization::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int Polarization::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Polarization::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float Polarization::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline int Polarization::getDecayVertex() const {
   return *(int*)m_parent->getAttribute("decayVertex");
}

inline int Polarization::getId() const {
   return *(int*)m_parent->getAttribute("id");
}

inline int Polarization::getMech() const {
   return *(int*)m_parent->getAttribute("mech");
}

inline int Polarization::getParentid() const {
   return *(int*)m_parent->getAttribute("parentid");
}

inline int Polarization::getPdgtype() const {
   return *(int*)m_parent->getAttribute("pdgtype");
}

inline float Polarization::getPx() const {
   return m_Px;
}

inline void Polarization::setPx(float Px) {
   m_Px = Px;
}

inline float Polarization::getPy() const {
   return m_Py;
}

inline void Polarization::setPy(float Py) {
   m_Py = Py;
}

inline float Polarization::getPz() const {
   return m_Pz;
}

inline void Polarization::setPz(float Pz) {
   m_Pz = Pz;
}

inline int Polarization::getMinOccurs() const {
   return 0;
}

inline const void *Polarization::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "Px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_Px;
   }
   if (name == "Py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_Py;
   }
   if (name == "Pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_Pz;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline Properties::Properties(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_charge(0),
   m_mass(0)
{}

inline Properties::~Properties() {}

inline std::string Properties::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Properties::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Properties::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Properties::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string Properties::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int Properties::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Properties::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline float Properties::getFOM() const {
   return *(float*)m_parent->getAttribute("FOM");
}

inline int Properties::getNdof() const {
   return *(int*)m_parent->getAttribute("Ndof");
}

inline int Properties::getCandidateid() const {
   return *(int*)m_parent->getAttribute("candidateid");
}

inline float Properties::getChisq() const {
   return *(float*)m_parent->getAttribute("chisq");
}

inline int Properties::getId() const {
   return *(int*)m_parent->getAttribute("id");
}

inline int Properties::getTrackid() const {
   return *(int*)m_parent->getAttribute("trackid");
}

inline int Properties::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float Properties::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline int Properties::getDecayVertex() const {
   return *(int*)m_parent->getAttribute("decayVertex");
}

inline int Properties::getMech() const {
   return *(int*)m_parent->getAttribute("mech");
}

inline int Properties::getParentid() const {
   return *(int*)m_parent->getAttribute("parentid");
}

inline int Properties::getPdgtype() const {
   return *(int*)m_parent->getAttribute("pdgtype");
}

inline int Properties::getCharge() const {
   return m_charge;
}

inline void Properties::setCharge(int charge) {
   m_charge = charge;
}

inline float Properties::getMass() const {
   return m_mass;
}

inline void Properties::setMass(float mass) {
   m_mass = mass;
}

inline const void *Properties::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "charge") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_charge;
   }
   if (name == "mass") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_mass;
   }
   return m_parent->getAttribute(name, atype);
}

inline Beam::Beam(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_type(0),
   m_momentum_link(&m_host->m_momentum_plist,
               m_host->m_momentum_plist.end(),
               m_host->m_momentum_plist.end(),
               this),
   m_polarization_link(&m_host->m_polarization_plist,
               m_host->m_polarization_plist.end(),
               m_host->m_polarization_plist.end(),
               this),
   m_properties_link(&m_host->m_properties_plist,
               m_host->m_properties_plist.end(),
               m_host->m_properties_plist.end(),
               this)
{}

inline Beam::~Beam() {
   deleteMomenta();
   deletePolarizations();
   deletePropertiesList();
}

inline std::string Beam::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Beam::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Beam::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Beam::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string Beam::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int Beam::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float Beam::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline int Beam::getMinOccurs() const {
   return 0;
}

inline Particle_t Beam::getType() const {
   return (Particle_t)m_type;
}

inline void Beam::setType(Particle_t type) {
   m_type = type;
}

inline const void *Beam::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "type") {
      if (atype != 0)
         *atype = k_hddm_Particle_t;
      return &m_type;
   }
   return m_parent->getAttribute(name, atype);
}

inline Momentum &Beam::getMomentum() {
   return m_momentum_link.front();
}

inline MomentumList &Beam::getMomenta() {
   return m_momentum_link;
}

inline MomentumList Beam::addMomenta(int count, int start) {
   return m_momentum_link.add(count,start);
}

inline void Beam::deleteMomenta(int count, int start) {
   m_momentum_link.del(count,start);
}

inline Polarization &Beam::getPolarization() {
   return m_polarization_link.front();
}

inline PolarizationList &Beam::getPolarizations() {
   return m_polarization_link;
}

inline PolarizationList Beam::addPolarizations(int count, int start) {
   return m_polarization_link.add(count,start);
}

inline void Beam::deletePolarizations(int count, int start) {
   m_polarization_link.del(count,start);
}

inline Properties &Beam::getProperties() {
   return m_properties_link.front();
}

inline PropertiesList &Beam::getPropertiesList() {
   return m_properties_link;
}

inline PropertiesList Beam::addPropertiesList(int count, int start) {
   return m_properties_link.add(count,start);
}

inline void Beam::deletePropertiesList(int count, int start) {
   m_properties_link.del(count,start);
}

inline Target::Target(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_type(0),
   m_momentum_link(&m_host->m_momentum_plist,
               m_host->m_momentum_plist.end(),
               m_host->m_momentum_plist.end(),
               this),
   m_polarization_link(&m_host->m_polarization_plist,
               m_host->m_polarization_plist.end(),
               m_host->m_polarization_plist.end(),
               this),
   m_properties_link(&m_host->m_properties_plist,
               m_host->m_properties_plist.end(),
               m_host->m_properties_plist.end(),
               this)
{}

inline Target::~Target() {
   deleteMomenta();
   deletePolarizations();
   deletePropertiesList();
}

inline std::string Target::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Target::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Target::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Target::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string Target::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int Target::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float Target::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline int Target::getMinOccurs() const {
   return 0;
}

inline Particle_t Target::getType() const {
   return (Particle_t)m_type;
}

inline void Target::setType(Particle_t type) {
   m_type = type;
}

inline const void *Target::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "type") {
      if (atype != 0)
         *atype = k_hddm_Particle_t;
      return &m_type;
   }
   return m_parent->getAttribute(name, atype);
}

inline Momentum &Target::getMomentum() {
   return m_momentum_link.front();
}

inline MomentumList &Target::getMomenta() {
   return m_momentum_link;
}

inline MomentumList Target::addMomenta(int count, int start) {
   return m_momentum_link.add(count,start);
}

inline void Target::deleteMomenta(int count, int start) {
   m_momentum_link.del(count,start);
}

inline Polarization &Target::getPolarization() {
   return m_polarization_link.front();
}

inline PolarizationList &Target::getPolarizations() {
   return m_polarization_link;
}

inline PolarizationList Target::addPolarizations(int count, int start) {
   return m_polarization_link.add(count,start);
}

inline void Target::deletePolarizations(int count, int start) {
   m_polarization_link.del(count,start);
}

inline Properties &Target::getProperties() {
   return m_properties_link.front();
}

inline PropertiesList &Target::getPropertiesList() {
   return m_properties_link;
}

inline PropertiesList Target::addPropertiesList(int count, int start) {
   return m_properties_link.add(count,start);
}

inline void Target::deletePropertiesList(int count, int start) {
   m_properties_link.del(count,start);
}

inline Product::Product(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_decayVertex(0),
   m_id(0),
   m_mech(0),
   m_parentid(0),
   m_pdgtype(0),
   m_type(0),
   m_momentum_link(&m_host->m_momentum_plist,
               m_host->m_momentum_plist.end(),
               m_host->m_momentum_plist.end(),
               this),
   m_polarization_link(&m_host->m_polarization_plist,
               m_host->m_polarization_plist.end(),
               m_host->m_polarization_plist.end(),
               this),
   m_properties_link(&m_host->m_properties_plist,
               m_host->m_properties_plist.end(),
               m_host->m_properties_plist.end(),
               this)
{}

inline Product::~Product() {
   deleteMomenta();
   deletePolarizations();
   deletePropertiesList();
}

inline std::string Product::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Product::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Product::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Product::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int Product::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Product::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline float Product::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline int Product::getDecayVertex() const {
   return m_decayVertex;
}

inline void Product::setDecayVertex(int decayVertex) {
   m_decayVertex = decayVertex;
}

inline int Product::getId() const {
   return m_id;
}

inline void Product::setId(int id) {
   m_id = id;
}

inline std::string Product::getMaxOccurs() const {
   return "unbounded";
}

inline int Product::getMech() const {
   return m_mech;
}

inline void Product::setMech(int mech) {
   m_mech = mech;
}

inline int Product::getParentid() const {
   return m_parentid;
}

inline void Product::setParentid(int parentid) {
   m_parentid = parentid;
}

inline int Product::getPdgtype() const {
   return m_pdgtype;
}

inline void Product::setPdgtype(int pdgtype) {
   m_pdgtype = pdgtype;
}

inline Particle_t Product::getType() const {
   return (Particle_t)m_type;
}

inline void Product::setType(Particle_t type) {
   m_type = type;
}

inline const void *Product::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "decayVertex") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_decayVertex;
   }
   if (name == "id") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_id;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "mech") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_mech;
   }
   if (name == "parentid") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_parentid;
   }
   if (name == "pdgtype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_pdgtype;
   }
   if (name == "type") {
      if (atype != 0)
         *atype = k_hddm_Particle_t;
      return &m_type;
   }
   return m_parent->getAttribute(name, atype);
}

inline Momentum &Product::getMomentum() {
   return m_momentum_link.front();
}

inline MomentumList &Product::getMomenta() {
   return m_momentum_link;
}

inline MomentumList Product::addMomenta(int count, int start) {
   return m_momentum_link.add(count,start);
}

inline void Product::deleteMomenta(int count, int start) {
   m_momentum_link.del(count,start);
}

inline Polarization &Product::getPolarization() {
   return m_polarization_link.front();
}

inline PolarizationList &Product::getPolarizations() {
   return m_polarization_link;
}

inline PolarizationList Product::addPolarizations(int count, int start) {
   return m_polarization_link.add(count,start);
}

inline void Product::deletePolarizations(int count, int start) {
   m_polarization_link.del(count,start);
}

inline Properties &Product::getProperties() {
   return m_properties_link.front();
}

inline PropertiesList &Product::getPropertiesList() {
   return m_properties_link;
}

inline PropertiesList Product::addPropertiesList(int count, int start) {
   return m_properties_link.add(count,start);
}

inline void Product::deletePropertiesList(int count, int start) {
   m_properties_link.del(count,start);
}

inline Origin::Origin(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_t(0),
   m_vx(0),
   m_vy(0),
   m_vz(0)
{}

inline Origin::~Origin() {}

inline std::string Origin::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Origin::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Origin::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Origin::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string Origin::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int Origin::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Origin::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline float Origin::getFOM() const {
   return *(float*)m_parent->getAttribute("FOM");
}

inline int Origin::getNdof() const {
   return *(int*)m_parent->getAttribute("Ndof");
}

inline int Origin::getCandidateid() const {
   return *(int*)m_parent->getAttribute("candidateid");
}

inline float Origin::getChisq() const {
   return *(float*)m_parent->getAttribute("chisq");
}

inline int Origin::getId() const {
   return *(int*)m_parent->getAttribute("id");
}

inline int Origin::getTrackid() const {
   return *(int*)m_parent->getAttribute("trackid");
}

inline int Origin::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float Origin::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline float Origin::getT() const {
   return m_t;
}

inline void Origin::setT(float t) {
   m_t = t;
}

inline float Origin::getVx() const {
   return m_vx;
}

inline void Origin::setVx(float vx) {
   m_vx = vx;
}

inline float Origin::getVy() const {
   return m_vy;
}

inline void Origin::setVy(float vy) {
   m_vy = vy;
}

inline float Origin::getVz() const {
   return m_vz;
}

inline void Origin::setVz(float vz) {
   m_vz = vz;
}

inline const void *Origin::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "vx") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_vx;
   }
   if (name == "vy") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_vy;
   }
   if (name == "vz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_vz;
   }
   return m_parent->getAttribute(name, atype);
}

inline Vertex::Vertex(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_product_list(&m_host->m_product_plist,
               m_host->m_product_plist.end(),
               m_host->m_product_plist.end(),
               this),
   m_origin_link(&m_host->m_origin_plist,
               m_host->m_origin_plist.end(),
               m_host->m_origin_plist.end(),
               this)
{}

inline Vertex::~Vertex() {
   deleteProducts();
   deleteOrigins();
}

inline std::string Vertex::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Vertex::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Vertex::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Vertex::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int Vertex::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Vertex::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int Vertex::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float Vertex::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline std::string Vertex::getMaxOccurs() const {
   return "unbounded";
}

inline const void *Vertex::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline Product &Vertex::getProduct(int index) {
   return m_product_list(index);
}

inline ProductList &Vertex::getProducts() {
   return m_product_list;
}

inline ProductList Vertex::addProducts(int count, int start) {
   return m_product_list.add(count,start);
}

inline void Vertex::deleteProducts(int count, int start) {
   m_product_list.del(count,start);
}

inline Origin &Vertex::getOrigin() {
   return m_origin_link.front();
}

inline OriginList &Vertex::getOrigins() {
   return m_origin_link;
}

inline OriginList Vertex::addOrigins(int count, int start) {
   return m_origin_link.add(count,start);
}

inline void Vertex::deleteOrigins(int count, int start) {
   m_origin_link.del(count,start);
}

inline Random::Random(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_seed1(0),
   m_seed2(0),
   m_seed3(0),
   m_seed4(0)
{}

inline Random::~Random() {}

inline std::string Random::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Random::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Random::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Random::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int Random::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Random::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float Random::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline int Random::getMaxOccurs() const {
   return 1;
}

inline int Random::getMinOccurs() const {
   return 0;
}

inline int Random::getSeed1() const {
   return m_seed1;
}

inline void Random::setSeed1(int seed1) {
   m_seed1 = seed1;
}

inline int Random::getSeed2() const {
   return m_seed2;
}

inline void Random::setSeed2(int seed2) {
   m_seed2 = seed2;
}

inline int Random::getSeed3() const {
   return m_seed3;
}

inline void Random::setSeed3(int seed3) {
   m_seed3 = seed3;
}

inline int Random::getSeed4() const {
   return m_seed4;
}

inline void Random::setSeed4(int seed4) {
   m_seed4 = seed4;
}

inline const void *Random::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "seed1") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_seed1;
   }
   if (name == "seed2") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_seed2;
   }
   if (name == "seed3") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_seed3;
   }
   if (name == "seed4") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_seed4;
   }
   return m_parent->getAttribute(name, atype);
}

inline UserDataFloat::UserDataFloat(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_data(0),
   m_meaning("")
{}

inline UserDataFloat::~UserDataFloat() {}

inline std::string UserDataFloat::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float UserDataFloat::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string UserDataFloat::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int UserDataFloat::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int UserDataFloat::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int UserDataFloat::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float UserDataFloat::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline std::string UserDataFloat::getDescription() const {
   return *(const std::string*)m_parent->getAttribute("description");
}

inline float UserDataFloat::getData() const {
   return m_data;
}

inline void UserDataFloat::setData(float data) {
   m_data = data;
}

inline std::string UserDataFloat::getMaxOccurs() const {
   return "unbounded";
}

inline std::string UserDataFloat::getMeaning() const {
   return m_meaning;
}

inline void UserDataFloat::setMeaning(const std::string &meaning) {
   m_meaning = meaning;
}

inline int UserDataFloat::getMinOccurs() const {
   return 0;
}

inline const void *UserDataFloat::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "data") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_data;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "meaning") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_meaning;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline UserDataInt::UserDataInt(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_data(0),
   m_meaning("")
{}

inline UserDataInt::~UserDataInt() {}

inline std::string UserDataInt::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float UserDataInt::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string UserDataInt::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int UserDataInt::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int UserDataInt::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int UserDataInt::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float UserDataInt::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline std::string UserDataInt::getDescription() const {
   return *(const std::string*)m_parent->getAttribute("description");
}

inline int UserDataInt::getData() const {
   return m_data;
}

inline void UserDataInt::setData(int data) {
   m_data = data;
}

inline std::string UserDataInt::getMaxOccurs() const {
   return "unbounded";
}

inline std::string UserDataInt::getMeaning() const {
   return m_meaning;
}

inline void UserDataInt::setMeaning(const std::string &meaning) {
   m_meaning = meaning;
}

inline int UserDataInt::getMinOccurs() const {
   return 0;
}

inline const void *UserDataInt::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "data") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_data;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "meaning") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_meaning;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline UserData::UserData(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_description(""),
   m_userDataFloat_list(&m_host->m_userDataFloat_plist,
               m_host->m_userDataFloat_plist.end(),
               m_host->m_userDataFloat_plist.end(),
               this),
   m_userDataInt_list(&m_host->m_userDataInt_plist,
               m_host->m_userDataInt_plist.end(),
               m_host->m_userDataInt_plist.end(),
               this)
{}

inline UserData::~UserData() {
   deleteUserDataFloats();
   deleteUserDataInts();
}

inline std::string UserData::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float UserData::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string UserData::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int UserData::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int UserData::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int UserData::getType() const {
   return *(int*)m_parent->getAttribute("type");
}

inline float UserData::getWeight() const {
   return *(float*)m_parent->getAttribute("weight");
}

inline std::string UserData::getDescription() const {
   return m_description;
}

inline void UserData::setDescription(const std::string &description) {
   m_description = description;
}

inline std::string UserData::getMaxOccurs() const {
   return "unbounded";
}

inline int UserData::getMinOccurs() const {
   return 0;
}

inline const void *UserData::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "description") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_description;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline UserDataFloat &UserData::getUserDataFloat(int index) {
   return m_userDataFloat_list(index);
}

inline UserDataFloatList &UserData::getUserDataFloats() {
   return m_userDataFloat_list;
}

inline UserDataFloatList UserData::addUserDataFloats(int count, int start) {
   return m_userDataFloat_list.add(count,start);
}

inline void UserData::deleteUserDataFloats(int count, int start) {
   m_userDataFloat_list.del(count,start);
}

inline UserDataInt &UserData::getUserDataInt(int index) {
   return m_userDataInt_list(index);
}

inline UserDataIntList &UserData::getUserDataInts() {
   return m_userDataInt_list;
}

inline UserDataIntList UserData::addUserDataInts(int count, int start) {
   return m_userDataInt_list.add(count,start);
}

inline void UserData::deleteUserDataInts(int count, int start) {
   m_userDataInt_list.del(count,start);
}

inline Reaction::Reaction(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_type(0),
   m_weight(0),
   m_beam_link(&m_host->m_beam_plist,
               m_host->m_beam_plist.end(),
               m_host->m_beam_plist.end(),
               this),
   m_target_link(&m_host->m_target_plist,
               m_host->m_target_plist.end(),
               m_host->m_target_plist.end(),
               this),
   m_vertex_list(&m_host->m_vertex_plist,
               m_host->m_vertex_plist.end(),
               m_host->m_vertex_plist.end(),
               this),
   m_random_link(&m_host->m_random_plist,
               m_host->m_random_plist.end(),
               m_host->m_random_plist.end(),
               this),
   m_userData_list(&m_host->m_userData_plist,
               m_host->m_userData_plist.end(),
               m_host->m_userData_plist.end(),
               this)
{}

inline Reaction::~Reaction() {
   deleteBeams();
   deleteTargets();
   deleteVertices();
   deleteRandoms();
   deleteUserDatas();
}

inline std::string Reaction::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Reaction::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Reaction::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Reaction::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int Reaction::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string Reaction::getMaxOccurs() const {
   return "unbounded";
}

inline int Reaction::getMinOccurs() const {
   return 0;
}

inline int Reaction::getType() const {
   return m_type;
}

inline void Reaction::setType(int type) {
   m_type = type;
}

inline float Reaction::getWeight() const {
   return m_weight;
}

inline void Reaction::setWeight(float weight) {
   m_weight = weight;
}

inline const void *Reaction::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "type") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_type;
   }
   if (name == "weight") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_weight;
   }
   return m_parent->getAttribute(name, atype);
}

inline Beam &Reaction::getBeam() {
   return m_beam_link.front();
}

inline BeamList &Reaction::getBeams() {
   return m_beam_link;
}

inline BeamList Reaction::addBeams(int count, int start) {
   return m_beam_link.add(count,start);
}

inline void Reaction::deleteBeams(int count, int start) {
   m_beam_link.del(count,start);
}

inline Target &Reaction::getTarget() {
   return m_target_link.front();
}

inline TargetList &Reaction::getTargets() {
   return m_target_link;
}

inline TargetList Reaction::addTargets(int count, int start) {
   return m_target_link.add(count,start);
}

inline void Reaction::deleteTargets(int count, int start) {
   m_target_link.del(count,start);
}

inline Vertex &Reaction::getVertex(int index) {
   return m_vertex_list(index);
}

inline VertexList &Reaction::getVertices() {
   return m_vertex_list;
}

inline VertexList Reaction::addVertices(int count, int start) {
   return m_vertex_list.add(count,start);
}

inline void Reaction::deleteVertices(int count, int start) {
   m_vertex_list.del(count,start);
}

inline Random &Reaction::getRandom() {
   return m_random_link.front();
}

inline RandomList &Reaction::getRandoms() {
   return m_random_link;
}

inline RandomList Reaction::addRandoms(int count, int start) {
   return m_random_link.add(count,start);
}

inline void Reaction::deleteRandoms(int count, int start) {
   m_random_link.del(count,start);
}

inline UserData &Reaction::getUserData(int index) {
   return m_userData_list(index);
}

inline UserDataList &Reaction::getUserDatas() {
   return m_userData_list;
}

inline UserDataList Reaction::addUserDatas(int count, int start) {
   return m_userData_list.add(count,start);
}

inline void Reaction::deleteUserDatas(int count, int start) {
   m_userData_list.del(count,start);
}

inline CdcDigihit::CdcDigihit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_peakAmp(0)
{}

inline CdcDigihit::~CdcDigihit() {}

inline std::string CdcDigihit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CdcDigihit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CdcDigihit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CdcDigihit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string CdcDigihit::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int CdcDigihit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CdcDigihit::getRing() const {
   return *(int*)m_parent->getAttribute("ring");
}

inline int CdcDigihit::getStraw() const {
   return *(int*)m_parent->getAttribute("straw");
}

inline float CdcDigihit::getQ() const {
   return *(float*)m_parent->getAttribute("q");
}

inline float CdcDigihit::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline int CdcDigihit::getMinOccurs() const {
   return 0;
}

inline float CdcDigihit::getPeakAmp() const {
   return m_peakAmp;
}

inline void CdcDigihit::setPeakAmp(float peakAmp) {
   m_peakAmp = peakAmp;
}

inline const void *CdcDigihit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "peakAmp") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_peakAmp;
   }
   return m_parent->getAttribute(name, atype);
}

inline CdcHitQF::CdcHitQF(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_QF(0)
{}

inline CdcHitQF::~CdcHitQF() {}

inline std::string CdcHitQF::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CdcHitQF::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CdcHitQF::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CdcHitQF::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string CdcHitQF::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int CdcHitQF::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CdcHitQF::getRing() const {
   return *(int*)m_parent->getAttribute("ring");
}

inline int CdcHitQF::getStraw() const {
   return *(int*)m_parent->getAttribute("straw");
}

inline float CdcHitQF::getQ() const {
   return *(float*)m_parent->getAttribute("q");
}

inline float CdcHitQF::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline float CdcHitQF::getQF() const {
   return m_QF;
}

inline void CdcHitQF::setQF(float QF) {
   m_QF = QF;
}

inline int CdcHitQF::getMinOccurs() const {
   return 0;
}

inline const void *CdcHitQF::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "QF") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_QF;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline CdcStrawHit::CdcStrawHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_q(0),
   m_t(0),
   m_cdcDigihit_link(&m_host->m_cdcDigihit_plist,
               m_host->m_cdcDigihit_plist.end(),
               m_host->m_cdcDigihit_plist.end(),
               this),
   m_cdcHitQF_link(&m_host->m_cdcHitQF_plist,
               m_host->m_cdcHitQF_plist.end(),
               m_host->m_cdcHitQF_plist.end(),
               this)
{}

inline CdcStrawHit::~CdcStrawHit() {
   deleteCdcDigihits();
   deleteCdcHitQFs();
}

inline std::string CdcStrawHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CdcStrawHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CdcStrawHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CdcStrawHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CdcStrawHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CdcStrawHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int CdcStrawHit::getRing() const {
   return *(int*)m_parent->getAttribute("ring");
}

inline int CdcStrawHit::getStraw() const {
   return *(int*)m_parent->getAttribute("straw");
}

inline std::string CdcStrawHit::getMaxOccurs() const {
   return "unbounded";
}

inline float CdcStrawHit::getQ() const {
   return m_q;
}

inline void CdcStrawHit::setQ(float q) {
   m_q = q;
}

inline float CdcStrawHit::getT() const {
   return m_t;
}

inline void CdcStrawHit::setT(float t) {
   m_t = t;
}

inline const void *CdcStrawHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "q") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_q;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline CdcDigihit &CdcStrawHit::getCdcDigihit() {
   return m_cdcDigihit_link.front();
}

inline CdcDigihitList &CdcStrawHit::getCdcDigihits() {
   return m_cdcDigihit_link;
}

inline CdcDigihitList CdcStrawHit::addCdcDigihits(int count, int start) {
   return m_cdcDigihit_link.add(count,start);
}

inline void CdcStrawHit::deleteCdcDigihits(int count, int start) {
   m_cdcDigihit_link.del(count,start);
}

inline CdcHitQF &CdcStrawHit::getCdcHitQF() {
   return m_cdcHitQF_link.front();
}

inline CdcHitQFList &CdcStrawHit::getCdcHitQFs() {
   return m_cdcHitQF_link;
}

inline CdcHitQFList CdcStrawHit::addCdcHitQFs(int count, int start) {
   return m_cdcHitQF_link.add(count,start);
}

inline void CdcStrawHit::deleteCdcHitQFs(int count, int start) {
   m_cdcHitQF_link.del(count,start);
}

inline CdcStrawTruthHit::CdcStrawTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_d(0),
   m_itrack(0),
   m_ptype(0),
   m_q(0),
   m_t(0)
{}

inline CdcStrawTruthHit::~CdcStrawTruthHit() {}

inline std::string CdcStrawTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CdcStrawTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CdcStrawTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CdcStrawTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CdcStrawTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CdcStrawTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int CdcStrawTruthHit::getRing() const {
   return *(int*)m_parent->getAttribute("ring");
}

inline int CdcStrawTruthHit::getStraw() const {
   return *(int*)m_parent->getAttribute("straw");
}

inline float CdcStrawTruthHit::getD() const {
   return m_d;
}

inline void CdcStrawTruthHit::setD(float d) {
   m_d = d;
}

inline int CdcStrawTruthHit::getItrack() const {
   return m_itrack;
}

inline void CdcStrawTruthHit::setItrack(int itrack) {
   m_itrack = itrack;
}

inline std::string CdcStrawTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int CdcStrawTruthHit::getPtype() const {
   return m_ptype;
}

inline void CdcStrawTruthHit::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float CdcStrawTruthHit::getQ() const {
   return m_q;
}

inline void CdcStrawTruthHit::setQ(float q) {
   m_q = q;
}

inline float CdcStrawTruthHit::getT() const {
   return m_t;
}

inline void CdcStrawTruthHit::setT(float t) {
   m_t = t;
}

inline const void *CdcStrawTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "d") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_d;
   }
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "q") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_q;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline CdcStraw::CdcStraw(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_ring(0),
   m_straw(0),
   m_cdcStrawHit_list(&m_host->m_cdcStrawHit_plist,
               m_host->m_cdcStrawHit_plist.end(),
               m_host->m_cdcStrawHit_plist.end(),
               this),
   m_cdcStrawTruthHit_list(&m_host->m_cdcStrawTruthHit_plist,
               m_host->m_cdcStrawTruthHit_plist.end(),
               m_host->m_cdcStrawTruthHit_plist.end(),
               this)
{}

inline CdcStraw::~CdcStraw() {
   deleteCdcStrawHits();
   deleteCdcStrawTruthHits();
}

inline std::string CdcStraw::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CdcStraw::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CdcStraw::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CdcStraw::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CdcStraw::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string CdcStraw::getMaxOccurs() const {
   return "unbounded";
}

inline int CdcStraw::getMinOccurs() const {
   return 0;
}

inline int CdcStraw::getRing() const {
   return m_ring;
}

inline void CdcStraw::setRing(int ring) {
   m_ring = ring;
}

inline int CdcStraw::getStraw() const {
   return m_straw;
}

inline void CdcStraw::setStraw(int straw) {
   m_straw = straw;
}

inline const void *CdcStraw::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "ring") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ring;
   }
   if (name == "straw") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_straw;
   }
   return m_parent->getAttribute(name, atype);
}

inline CdcStrawHit &CdcStraw::getCdcStrawHit(int index) {
   return m_cdcStrawHit_list(index);
}

inline CdcStrawHitList &CdcStraw::getCdcStrawHits() {
   return m_cdcStrawHit_list;
}

inline CdcStrawHitList CdcStraw::addCdcStrawHits(int count, int start) {
   return m_cdcStrawHit_list.add(count,start);
}

inline void CdcStraw::deleteCdcStrawHits(int count, int start) {
   m_cdcStrawHit_list.del(count,start);
}

inline CdcStrawTruthHit &CdcStraw::getCdcStrawTruthHit(int index) {
   return m_cdcStrawTruthHit_list(index);
}

inline CdcStrawTruthHitList &CdcStraw::getCdcStrawTruthHits() {
   return m_cdcStrawTruthHit_list;
}

inline CdcStrawTruthHitList CdcStraw::addCdcStrawTruthHits(int count, int start) {
   return m_cdcStrawTruthHit_list.add(count,start);
}

inline void CdcStraw::deleteCdcStrawTruthHits(int count, int start) {
   m_cdcStrawTruthHit_list.del(count,start);
}

inline TrackID::TrackID(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_itrack(0)
{}

inline TrackID::~TrackID() {}

inline std::string TrackID::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TrackID::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TrackID::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TrackID::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string TrackID::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int TrackID::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float TrackID::getE() const {
   return *(float*)m_parent->getAttribute("E");
}

inline bool TrackID::getPrimary() const {
   return *(bool*)m_parent->getAttribute("primary");
}

inline int TrackID::getPtype() const {
   return *(int*)m_parent->getAttribute("ptype");
}

inline float TrackID::getPx() const {
   return *(float*)m_parent->getAttribute("px");
}

inline float TrackID::getPy() const {
   return *(float*)m_parent->getAttribute("py");
}

inline float TrackID::getPz() const {
   return *(float*)m_parent->getAttribute("pz");
}

inline float TrackID::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline int TrackID::getTrack() const {
   return *(int*)m_parent->getAttribute("track");
}

inline float TrackID::getX() const {
   return *(float*)m_parent->getAttribute("x");
}

inline float TrackID::getY() const {
   return *(float*)m_parent->getAttribute("y");
}

inline float TrackID::getZ() const {
   return *(float*)m_parent->getAttribute("z");
}

inline float TrackID::getDEdx() const {
   return *(float*)m_parent->getAttribute("dEdx");
}

inline float TrackID::getPhi() const {
   return *(float*)m_parent->getAttribute("phi");
}

inline float TrackID::getR() const {
   return *(float*)m_parent->getAttribute("r");
}

inline int TrackID::getArm() const {
   return *(int*)m_parent->getAttribute("arm");
}

inline int TrackID::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int TrackID::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int TrackID::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline int TrackID::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline float TrackID::getDradius() const {
   return *(float*)m_parent->getAttribute("dradius");
}

inline int TrackID::getItrack() const {
   return m_itrack;
}

inline void TrackID::setItrack(int itrack) {
   m_itrack = itrack;
}

inline int TrackID::getMinOccurs() const {
   return 0;
}

inline const void *TrackID::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline CdcTruthPoint::CdcTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dEdx(0),
   m_dradius(0),
   m_phi(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_r(0),
   m_t(0),
   m_track(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline CdcTruthPoint::~CdcTruthPoint() {
   deleteTrackIDs();
}

inline std::string CdcTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CdcTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CdcTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CdcTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CdcTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float CdcTruthPoint::getDEdx() const {
   return m_dEdx;
}

inline void CdcTruthPoint::setDEdx(float dEdx) {
   m_dEdx = dEdx;
}

inline float CdcTruthPoint::getDradius() const {
   return m_dradius;
}

inline void CdcTruthPoint::setDradius(float dradius) {
   m_dradius = dradius;
}

inline std::string CdcTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int CdcTruthPoint::getMinOccurs() const {
   return 0;
}

inline float CdcTruthPoint::getPhi() const {
   return m_phi;
}

inline void CdcTruthPoint::setPhi(float phi) {
   m_phi = phi;
}

inline bool CdcTruthPoint::getPrimary() const {
   return m_primary;
}

inline void CdcTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int CdcTruthPoint::getPtype() const {
   return m_ptype;
}

inline void CdcTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float CdcTruthPoint::getPx() const {
   return m_px;
}

inline void CdcTruthPoint::setPx(float px) {
   m_px = px;
}

inline float CdcTruthPoint::getPy() const {
   return m_py;
}

inline void CdcTruthPoint::setPy(float py) {
   m_py = py;
}

inline float CdcTruthPoint::getPz() const {
   return m_pz;
}

inline void CdcTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float CdcTruthPoint::getR() const {
   return m_r;
}

inline void CdcTruthPoint::setR(float r) {
   m_r = r;
}

inline float CdcTruthPoint::getT() const {
   return m_t;
}

inline void CdcTruthPoint::setT(float t) {
   m_t = t;
}

inline int CdcTruthPoint::getTrack() const {
   return m_track;
}

inline void CdcTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float CdcTruthPoint::getZ() const {
   return m_z;
}

inline void CdcTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *CdcTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dEdx") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dEdx;
   }
   if (name == "dradius") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dradius;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "phi") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_phi;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "r") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_r;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &CdcTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &CdcTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList CdcTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void CdcTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline CentralDC::CentralDC(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_cdcStraw_list(&m_host->m_cdcStraw_plist,
               m_host->m_cdcStraw_plist.end(),
               m_host->m_cdcStraw_plist.end(),
               this),
   m_cdcTruthPoint_list(&m_host->m_cdcTruthPoint_plist,
               m_host->m_cdcTruthPoint_plist.end(),
               m_host->m_cdcTruthPoint_plist.end(),
               this)
{}

inline CentralDC::~CentralDC() {
   deleteCdcStraws();
   deleteCdcTruthPoints();
}

inline std::string CentralDC::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CentralDC::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CentralDC::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CentralDC::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string CentralDC::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int CentralDC::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CentralDC::getMinOccurs() const {
   return 0;
}

inline const void *CentralDC::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline CdcStraw &CentralDC::getCdcStraw(int index) {
   return m_cdcStraw_list(index);
}

inline CdcStrawList &CentralDC::getCdcStraws() {
   return m_cdcStraw_list;
}

inline CdcStrawList CentralDC::addCdcStraws(int count, int start) {
   return m_cdcStraw_list.add(count,start);
}

inline void CentralDC::deleteCdcStraws(int count, int start) {
   m_cdcStraw_list.del(count,start);
}

inline CdcTruthPoint &CentralDC::getCdcTruthPoint(int index) {
   return m_cdcTruthPoint_list(index);
}

inline CdcTruthPointList &CentralDC::getCdcTruthPoints() {
   return m_cdcTruthPoint_list;
}

inline CdcTruthPointList CentralDC::addCdcTruthPoints(int count, int start) {
   return m_cdcTruthPoint_list.add(count,start);
}

inline void CentralDC::deleteCdcTruthPoints(int count, int start) {
   m_cdcTruthPoint_list.del(count,start);
}

inline FdcAnodeHit::FdcAnodeHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_t(0)
{}

inline FdcAnodeHit::~FdcAnodeHit() {}

inline std::string FdcAnodeHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcAnodeHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcAnodeHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcAnodeHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FdcAnodeHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcAnodeHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FdcAnodeHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FdcAnodeHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int FdcAnodeHit::getWire() const {
   return *(int*)m_parent->getAttribute("wire");
}

inline float FdcAnodeHit::getDE() const {
   return m_dE;
}

inline void FdcAnodeHit::setDE(float dE) {
   m_dE = dE;
}

inline std::string FdcAnodeHit::getMaxOccurs() const {
   return "unbounded";
}

inline float FdcAnodeHit::getT() const {
   return m_t;
}

inline void FdcAnodeHit::setT(float t) {
   m_t = t;
}

inline const void *FdcAnodeHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcAnodeTruthHit::FdcAnodeTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_d(0),
   m_dE(0),
   m_itrack(0),
   m_ptype(0),
   m_t(0),
   m_t_unsmeared(0)
{}

inline FdcAnodeTruthHit::~FdcAnodeTruthHit() {}

inline std::string FdcAnodeTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcAnodeTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcAnodeTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcAnodeTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FdcAnodeTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcAnodeTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FdcAnodeTruthHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FdcAnodeTruthHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int FdcAnodeTruthHit::getWire() const {
   return *(int*)m_parent->getAttribute("wire");
}

inline float FdcAnodeTruthHit::getD() const {
   return m_d;
}

inline void FdcAnodeTruthHit::setD(float d) {
   m_d = d;
}

inline float FdcAnodeTruthHit::getDE() const {
   return m_dE;
}

inline void FdcAnodeTruthHit::setDE(float dE) {
   m_dE = dE;
}

inline int FdcAnodeTruthHit::getItrack() const {
   return m_itrack;
}

inline void FdcAnodeTruthHit::setItrack(int itrack) {
   m_itrack = itrack;
}

inline std::string FdcAnodeTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int FdcAnodeTruthHit::getPtype() const {
   return m_ptype;
}

inline void FdcAnodeTruthHit::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float FdcAnodeTruthHit::getT() const {
   return m_t;
}

inline void FdcAnodeTruthHit::setT(float t) {
   m_t = t;
}

inline float FdcAnodeTruthHit::getT_unsmeared() const {
   return m_t_unsmeared;
}

inline void FdcAnodeTruthHit::setT_unsmeared(float t_unsmeared) {
   m_t_unsmeared = t_unsmeared;
}

inline const void *FdcAnodeTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "d") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_d;
   }
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "t_unsmeared") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t_unsmeared;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcAnodeWire::FdcAnodeWire(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_wire(0),
   m_fdcAnodeHit_list(&m_host->m_fdcAnodeHit_plist,
               m_host->m_fdcAnodeHit_plist.end(),
               m_host->m_fdcAnodeHit_plist.end(),
               this),
   m_fdcAnodeTruthHit_list(&m_host->m_fdcAnodeTruthHit_plist,
               m_host->m_fdcAnodeTruthHit_plist.end(),
               m_host->m_fdcAnodeTruthHit_plist.end(),
               this)
{}

inline FdcAnodeWire::~FdcAnodeWire() {
   deleteFdcAnodeHits();
   deleteFdcAnodeTruthHits();
}

inline std::string FdcAnodeWire::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcAnodeWire::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcAnodeWire::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcAnodeWire::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FdcAnodeWire::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcAnodeWire::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FdcAnodeWire::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline std::string FdcAnodeWire::getMaxOccurs() const {
   return "unbounded";
}

inline int FdcAnodeWire::getMinOccurs() const {
   return 0;
}

inline int FdcAnodeWire::getWire() const {
   return m_wire;
}

inline void FdcAnodeWire::setWire(int wire) {
   m_wire = wire;
}

inline const void *FdcAnodeWire::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "wire") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_wire;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcAnodeHit &FdcAnodeWire::getFdcAnodeHit(int index) {
   return m_fdcAnodeHit_list(index);
}

inline FdcAnodeHitList &FdcAnodeWire::getFdcAnodeHits() {
   return m_fdcAnodeHit_list;
}

inline FdcAnodeHitList FdcAnodeWire::addFdcAnodeHits(int count, int start) {
   return m_fdcAnodeHit_list.add(count,start);
}

inline void FdcAnodeWire::deleteFdcAnodeHits(int count, int start) {
   m_fdcAnodeHit_list.del(count,start);
}

inline FdcAnodeTruthHit &FdcAnodeWire::getFdcAnodeTruthHit(int index) {
   return m_fdcAnodeTruthHit_list(index);
}

inline FdcAnodeTruthHitList &FdcAnodeWire::getFdcAnodeTruthHits() {
   return m_fdcAnodeTruthHit_list;
}

inline FdcAnodeTruthHitList FdcAnodeWire::addFdcAnodeTruthHits(int count, int start) {
   return m_fdcAnodeTruthHit_list.add(count,start);
}

inline void FdcAnodeWire::deleteFdcAnodeTruthHits(int count, int start) {
   m_fdcAnodeTruthHit_list.del(count,start);
}

inline FdcDigihit::FdcDigihit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_peakAmp(0)
{}

inline FdcDigihit::~FdcDigihit() {}

inline std::string FdcDigihit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcDigihit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcDigihit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcDigihit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string FdcDigihit::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int FdcDigihit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcDigihit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FdcDigihit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int FdcDigihit::getPlane() const {
   return *(int*)m_parent->getAttribute("plane");
}

inline int FdcDigihit::getStrip() const {
   return *(int*)m_parent->getAttribute("strip");
}

inline float FdcDigihit::getQ() const {
   return *(float*)m_parent->getAttribute("q");
}

inline float FdcDigihit::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline int FdcDigihit::getMinOccurs() const {
   return 0;
}

inline float FdcDigihit::getPeakAmp() const {
   return m_peakAmp;
}

inline void FdcDigihit::setPeakAmp(float peakAmp) {
   m_peakAmp = peakAmp;
}

inline const void *FdcDigihit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "peakAmp") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_peakAmp;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcCathodeHit::FdcCathodeHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_q(0),
   m_t(0),
   m_fdcDigihit_link(&m_host->m_fdcDigihit_plist,
               m_host->m_fdcDigihit_plist.end(),
               m_host->m_fdcDigihit_plist.end(),
               this)
{}

inline FdcCathodeHit::~FdcCathodeHit() {
   deleteFdcDigihits();
}

inline std::string FdcCathodeHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcCathodeHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcCathodeHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcCathodeHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FdcCathodeHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcCathodeHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FdcCathodeHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FdcCathodeHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int FdcCathodeHit::getPlane() const {
   return *(int*)m_parent->getAttribute("plane");
}

inline int FdcCathodeHit::getStrip() const {
   return *(int*)m_parent->getAttribute("strip");
}

inline std::string FdcCathodeHit::getMaxOccurs() const {
   return "unbounded";
}

inline float FdcCathodeHit::getQ() const {
   return m_q;
}

inline void FdcCathodeHit::setQ(float q) {
   m_q = q;
}

inline float FdcCathodeHit::getT() const {
   return m_t;
}

inline void FdcCathodeHit::setT(float t) {
   m_t = t;
}

inline const void *FdcCathodeHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "q") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_q;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcDigihit &FdcCathodeHit::getFdcDigihit() {
   return m_fdcDigihit_link.front();
}

inline FdcDigihitList &FdcCathodeHit::getFdcDigihits() {
   return m_fdcDigihit_link;
}

inline FdcDigihitList FdcCathodeHit::addFdcDigihits(int count, int start) {
   return m_fdcDigihit_link.add(count,start);
}

inline void FdcCathodeHit::deleteFdcDigihits(int count, int start) {
   m_fdcDigihit_link.del(count,start);
}

inline FdcCathodeTruthHit::FdcCathodeTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_itrack(0),
   m_ptype(0),
   m_q(0),
   m_t(0)
{}

inline FdcCathodeTruthHit::~FdcCathodeTruthHit() {}

inline std::string FdcCathodeTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcCathodeTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcCathodeTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcCathodeTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FdcCathodeTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcCathodeTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FdcCathodeTruthHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FdcCathodeTruthHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int FdcCathodeTruthHit::getPlane() const {
   return *(int*)m_parent->getAttribute("plane");
}

inline int FdcCathodeTruthHit::getStrip() const {
   return *(int*)m_parent->getAttribute("strip");
}

inline int FdcCathodeTruthHit::getItrack() const {
   return m_itrack;
}

inline void FdcCathodeTruthHit::setItrack(int itrack) {
   m_itrack = itrack;
}

inline std::string FdcCathodeTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int FdcCathodeTruthHit::getPtype() const {
   return m_ptype;
}

inline void FdcCathodeTruthHit::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float FdcCathodeTruthHit::getQ() const {
   return m_q;
}

inline void FdcCathodeTruthHit::setQ(float q) {
   m_q = q;
}

inline float FdcCathodeTruthHit::getT() const {
   return m_t;
}

inline void FdcCathodeTruthHit::setT(float t) {
   m_t = t;
}

inline const void *FdcCathodeTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "q") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_q;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcCathodeStrip::FdcCathodeStrip(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_plane(0),
   m_strip(0),
   m_fdcCathodeHit_list(&m_host->m_fdcCathodeHit_plist,
               m_host->m_fdcCathodeHit_plist.end(),
               m_host->m_fdcCathodeHit_plist.end(),
               this),
   m_fdcCathodeTruthHit_list(&m_host->m_fdcCathodeTruthHit_plist,
               m_host->m_fdcCathodeTruthHit_plist.end(),
               m_host->m_fdcCathodeTruthHit_plist.end(),
               this)
{}

inline FdcCathodeStrip::~FdcCathodeStrip() {
   deleteFdcCathodeHits();
   deleteFdcCathodeTruthHits();
}

inline std::string FdcCathodeStrip::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcCathodeStrip::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcCathodeStrip::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcCathodeStrip::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FdcCathodeStrip::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcCathodeStrip::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FdcCathodeStrip::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline std::string FdcCathodeStrip::getMaxOccurs() const {
   return "unbounded";
}

inline int FdcCathodeStrip::getMinOccurs() const {
   return 0;
}

inline int FdcCathodeStrip::getPlane() const {
   return m_plane;
}

inline void FdcCathodeStrip::setPlane(int plane) {
   m_plane = plane;
}

inline int FdcCathodeStrip::getStrip() const {
   return m_strip;
}

inline void FdcCathodeStrip::setStrip(int strip) {
   m_strip = strip;
}

inline const void *FdcCathodeStrip::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "plane") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_plane;
   }
   if (name == "strip") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_strip;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcCathodeHit &FdcCathodeStrip::getFdcCathodeHit(int index) {
   return m_fdcCathodeHit_list(index);
}

inline FdcCathodeHitList &FdcCathodeStrip::getFdcCathodeHits() {
   return m_fdcCathodeHit_list;
}

inline FdcCathodeHitList FdcCathodeStrip::addFdcCathodeHits(int count, int start) {
   return m_fdcCathodeHit_list.add(count,start);
}

inline void FdcCathodeStrip::deleteFdcCathodeHits(int count, int start) {
   m_fdcCathodeHit_list.del(count,start);
}

inline FdcCathodeTruthHit &FdcCathodeStrip::getFdcCathodeTruthHit(int index) {
   return m_fdcCathodeTruthHit_list(index);
}

inline FdcCathodeTruthHitList &FdcCathodeStrip::getFdcCathodeTruthHits() {
   return m_fdcCathodeTruthHit_list;
}

inline FdcCathodeTruthHitList FdcCathodeStrip::addFdcCathodeTruthHits(int count, int start) {
   return m_fdcCathodeTruthHit_list.add(count,start);
}

inline void FdcCathodeStrip::deleteFdcCathodeTruthHits(int count, int start) {
   m_fdcCathodeTruthHit_list.del(count,start);
}

inline FdcTruthPoint::FdcTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_dEdx(0),
   m_dradius(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline FdcTruthPoint::~FdcTruthPoint() {
   deleteTrackIDs();
}

inline std::string FdcTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FdcTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcTruthPoint::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FdcTruthPoint::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline float FdcTruthPoint::getE() const {
   return m_E;
}

inline void FdcTruthPoint::setE(float E) {
   m_E = E;
}

inline float FdcTruthPoint::getDEdx() const {
   return m_dEdx;
}

inline void FdcTruthPoint::setDEdx(float dEdx) {
   m_dEdx = dEdx;
}

inline float FdcTruthPoint::getDradius() const {
   return m_dradius;
}

inline void FdcTruthPoint::setDradius(float dradius) {
   m_dradius = dradius;
}

inline std::string FdcTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int FdcTruthPoint::getMinOccurs() const {
   return 0;
}

inline bool FdcTruthPoint::getPrimary() const {
   return m_primary;
}

inline void FdcTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int FdcTruthPoint::getPtype() const {
   return m_ptype;
}

inline void FdcTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float FdcTruthPoint::getPx() const {
   return m_px;
}

inline void FdcTruthPoint::setPx(float px) {
   m_px = px;
}

inline float FdcTruthPoint::getPy() const {
   return m_py;
}

inline void FdcTruthPoint::setPy(float py) {
   m_py = py;
}

inline float FdcTruthPoint::getPz() const {
   return m_pz;
}

inline void FdcTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float FdcTruthPoint::getT() const {
   return m_t;
}

inline void FdcTruthPoint::setT(float t) {
   m_t = t;
}

inline int FdcTruthPoint::getTrack() const {
   return m_track;
}

inline void FdcTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float FdcTruthPoint::getX() const {
   return m_x;
}

inline void FdcTruthPoint::setX(float x) {
   m_x = x;
}

inline float FdcTruthPoint::getY() const {
   return m_y;
}

inline void FdcTruthPoint::setY(float y) {
   m_y = y;
}

inline float FdcTruthPoint::getZ() const {
   return m_z;
}

inline void FdcTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *FdcTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "dEdx") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dEdx;
   }
   if (name == "dradius") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dradius;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &FdcTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &FdcTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList FdcTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void FdcTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline FdcChamber::FdcChamber(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_layer(0),
   m_module(0),
   m_fdcAnodeWire_list(&m_host->m_fdcAnodeWire_plist,
               m_host->m_fdcAnodeWire_plist.end(),
               m_host->m_fdcAnodeWire_plist.end(),
               this),
   m_fdcCathodeStrip_list(&m_host->m_fdcCathodeStrip_plist,
               m_host->m_fdcCathodeStrip_plist.end(),
               m_host->m_fdcCathodeStrip_plist.end(),
               this),
   m_fdcTruthPoint_list(&m_host->m_fdcTruthPoint_plist,
               m_host->m_fdcTruthPoint_plist.end(),
               m_host->m_fdcTruthPoint_plist.end(),
               this)
{}

inline FdcChamber::~FdcChamber() {
   deleteFdcAnodeWires();
   deleteFdcCathodeStrips();
   deleteFdcTruthPoints();
}

inline std::string FdcChamber::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FdcChamber::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FdcChamber::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FdcChamber::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FdcChamber::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FdcChamber::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FdcChamber::getLayer() const {
   return m_layer;
}

inline void FdcChamber::setLayer(int layer) {
   m_layer = layer;
}

inline std::string FdcChamber::getMaxOccurs() const {
   return "unbounded";
}

inline int FdcChamber::getModule() const {
   return m_module;
}

inline void FdcChamber::setModule(int module) {
   m_module = module;
}

inline const void *FdcChamber::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "layer") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_layer;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "module") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_module;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcAnodeWire &FdcChamber::getFdcAnodeWire(int index) {
   return m_fdcAnodeWire_list(index);
}

inline FdcAnodeWireList &FdcChamber::getFdcAnodeWires() {
   return m_fdcAnodeWire_list;
}

inline FdcAnodeWireList FdcChamber::addFdcAnodeWires(int count, int start) {
   return m_fdcAnodeWire_list.add(count,start);
}

inline void FdcChamber::deleteFdcAnodeWires(int count, int start) {
   m_fdcAnodeWire_list.del(count,start);
}

inline FdcCathodeStrip &FdcChamber::getFdcCathodeStrip(int index) {
   return m_fdcCathodeStrip_list(index);
}

inline FdcCathodeStripList &FdcChamber::getFdcCathodeStrips() {
   return m_fdcCathodeStrip_list;
}

inline FdcCathodeStripList FdcChamber::addFdcCathodeStrips(int count, int start) {
   return m_fdcCathodeStrip_list.add(count,start);
}

inline void FdcChamber::deleteFdcCathodeStrips(int count, int start) {
   m_fdcCathodeStrip_list.del(count,start);
}

inline FdcTruthPoint &FdcChamber::getFdcTruthPoint(int index) {
   return m_fdcTruthPoint_list(index);
}

inline FdcTruthPointList &FdcChamber::getFdcTruthPoints() {
   return m_fdcTruthPoint_list;
}

inline FdcTruthPointList FdcChamber::addFdcTruthPoints(int count, int start) {
   return m_fdcTruthPoint_list.add(count,start);
}

inline void FdcChamber::deleteFdcTruthPoints(int count, int start) {
   m_fdcTruthPoint_list.del(count,start);
}

inline ForwardDC::ForwardDC(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_fdcChamber_list(&m_host->m_fdcChamber_plist,
               m_host->m_fdcChamber_plist.end(),
               m_host->m_fdcChamber_plist.end(),
               this)
{}

inline ForwardDC::~ForwardDC() {
   deleteFdcChambers();
}

inline std::string ForwardDC::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float ForwardDC::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string ForwardDC::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int ForwardDC::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string ForwardDC::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int ForwardDC::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int ForwardDC::getMinOccurs() const {
   return 0;
}

inline const void *ForwardDC::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline FdcChamber &ForwardDC::getFdcChamber(int index) {
   return m_fdcChamber_list(index);
}

inline FdcChamberList &ForwardDC::getFdcChambers() {
   return m_fdcChamber_list;
}

inline FdcChamberList ForwardDC::addFdcChambers(int count, int start) {
   return m_fdcChamber_list.add(count,start);
}

inline void ForwardDC::deleteFdcChambers(int count, int start) {
   m_fdcChamber_list.del(count,start);
}

inline StcDigihit::StcDigihit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_peakAmp(0)
{}

inline StcDigihit::~StcDigihit() {}

inline std::string StcDigihit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float StcDigihit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string StcDigihit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int StcDigihit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string StcDigihit::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int StcDigihit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int StcDigihit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float StcDigihit::getDE() const {
   return *(float*)m_parent->getAttribute("dE");
}

inline float StcDigihit::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline int StcDigihit::getMinOccurs() const {
   return 0;
}

inline float StcDigihit::getPeakAmp() const {
   return m_peakAmp;
}

inline void StcDigihit::setPeakAmp(float peakAmp) {
   m_peakAmp = peakAmp;
}

inline const void *StcDigihit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "peakAmp") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_peakAmp;
   }
   return m_parent->getAttribute(name, atype);
}

inline StcHit::StcHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_t(0),
   m_stcDigihit_link(&m_host->m_stcDigihit_plist,
               m_host->m_stcDigihit_plist.end(),
               m_host->m_stcDigihit_plist.end(),
               this)
{}

inline StcHit::~StcHit() {
   deleteStcDigihits();
}

inline std::string StcHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float StcHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string StcHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int StcHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int StcHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int StcHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int StcHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float StcHit::getDE() const {
   return m_dE;
}

inline void StcHit::setDE(float dE) {
   m_dE = dE;
}

inline std::string StcHit::getMaxOccurs() const {
   return "unbounded";
}

inline float StcHit::getT() const {
   return m_t;
}

inline void StcHit::setT(float t) {
   m_t = t;
}

inline const void *StcHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline StcDigihit &StcHit::getStcDigihit() {
   return m_stcDigihit_link.front();
}

inline StcDigihitList &StcHit::getStcDigihits() {
   return m_stcDigihit_link;
}

inline StcDigihitList StcHit::addStcDigihits(int count, int start) {
   return m_stcDigihit_link.add(count,start);
}

inline void StcHit::deleteStcDigihits(int count, int start) {
   m_stcDigihit_link.del(count,start);
}

inline StcTruthHit::StcTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_itrack(0),
   m_ptype(0),
   m_t(0)
{}

inline StcTruthHit::~StcTruthHit() {}

inline std::string StcTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float StcTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string StcTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int StcTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int StcTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int StcTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int StcTruthHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float StcTruthHit::getDE() const {
   return m_dE;
}

inline void StcTruthHit::setDE(float dE) {
   m_dE = dE;
}

inline int StcTruthHit::getItrack() const {
   return m_itrack;
}

inline void StcTruthHit::setItrack(int itrack) {
   m_itrack = itrack;
}

inline std::string StcTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int StcTruthHit::getPtype() const {
   return m_ptype;
}

inline void StcTruthHit::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float StcTruthHit::getT() const {
   return m_t;
}

inline void StcTruthHit::setT(float t) {
   m_t = t;
}

inline const void *StcTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline StcPaddle::StcPaddle(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_sector(0),
   m_stcHit_list(&m_host->m_stcHit_plist,
               m_host->m_stcHit_plist.end(),
               m_host->m_stcHit_plist.end(),
               this),
   m_stcTruthHit_list(&m_host->m_stcTruthHit_plist,
               m_host->m_stcTruthHit_plist.end(),
               m_host->m_stcTruthHit_plist.end(),
               this)
{}

inline StcPaddle::~StcPaddle() {
   deleteStcHits();
   deleteStcTruthHits();
}

inline std::string StcPaddle::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float StcPaddle::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string StcPaddle::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int StcPaddle::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int StcPaddle::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string StcPaddle::getMaxOccurs() const {
   return "unbounded";
}

inline int StcPaddle::getMinOccurs() const {
   return 0;
}

inline int StcPaddle::getSector() const {
   return m_sector;
}

inline void StcPaddle::setSector(int sector) {
   m_sector = sector;
}

inline const void *StcPaddle::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "sector") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_sector;
   }
   return m_parent->getAttribute(name, atype);
}

inline StcHit &StcPaddle::getStcHit(int index) {
   return m_stcHit_list(index);
}

inline StcHitList &StcPaddle::getStcHits() {
   return m_stcHit_list;
}

inline StcHitList StcPaddle::addStcHits(int count, int start) {
   return m_stcHit_list.add(count,start);
}

inline void StcPaddle::deleteStcHits(int count, int start) {
   m_stcHit_list.del(count,start);
}

inline StcTruthHit &StcPaddle::getStcTruthHit(int index) {
   return m_stcTruthHit_list(index);
}

inline StcTruthHitList &StcPaddle::getStcTruthHits() {
   return m_stcTruthHit_list;
}

inline StcTruthHitList StcPaddle::addStcTruthHits(int count, int start) {
   return m_stcTruthHit_list.add(count,start);
}

inline void StcPaddle::deleteStcTruthHits(int count, int start) {
   m_stcTruthHit_list.del(count,start);
}

inline StcTruthPoint::StcTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_dEdx(0),
   m_phi(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_r(0),
   m_sector(0),
   m_t(0),
   m_track(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline StcTruthPoint::~StcTruthPoint() {
   deleteTrackIDs();
}

inline std::string StcTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float StcTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string StcTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int StcTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int StcTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float StcTruthPoint::getE() const {
   return m_E;
}

inline void StcTruthPoint::setE(float E) {
   m_E = E;
}

inline float StcTruthPoint::getDEdx() const {
   return m_dEdx;
}

inline void StcTruthPoint::setDEdx(float dEdx) {
   m_dEdx = dEdx;
}

inline std::string StcTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int StcTruthPoint::getMinOccurs() const {
   return 0;
}

inline float StcTruthPoint::getPhi() const {
   return m_phi;
}

inline void StcTruthPoint::setPhi(float phi) {
   m_phi = phi;
}

inline bool StcTruthPoint::getPrimary() const {
   return m_primary;
}

inline void StcTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int StcTruthPoint::getPtype() const {
   return m_ptype;
}

inline void StcTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float StcTruthPoint::getPx() const {
   return m_px;
}

inline void StcTruthPoint::setPx(float px) {
   m_px = px;
}

inline float StcTruthPoint::getPy() const {
   return m_py;
}

inline void StcTruthPoint::setPy(float py) {
   m_py = py;
}

inline float StcTruthPoint::getPz() const {
   return m_pz;
}

inline void StcTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float StcTruthPoint::getR() const {
   return m_r;
}

inline void StcTruthPoint::setR(float r) {
   m_r = r;
}

inline int StcTruthPoint::getSector() const {
   return m_sector;
}

inline void StcTruthPoint::setSector(int sector) {
   m_sector = sector;
}

inline float StcTruthPoint::getT() const {
   return m_t;
}

inline void StcTruthPoint::setT(float t) {
   m_t = t;
}

inline int StcTruthPoint::getTrack() const {
   return m_track;
}

inline void StcTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float StcTruthPoint::getZ() const {
   return m_z;
}

inline void StcTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *StcTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "dEdx") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dEdx;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "phi") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_phi;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "r") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_r;
   }
   if (name == "sector") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_sector;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &StcTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &StcTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList StcTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void StcTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline StartCntr::StartCntr(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_stcPaddle_list(&m_host->m_stcPaddle_plist,
               m_host->m_stcPaddle_plist.end(),
               m_host->m_stcPaddle_plist.end(),
               this),
   m_stcTruthPoint_list(&m_host->m_stcTruthPoint_plist,
               m_host->m_stcTruthPoint_plist.end(),
               m_host->m_stcTruthPoint_plist.end(),
               this)
{}

inline StartCntr::~StartCntr() {
   deleteStcPaddles();
   deleteStcTruthPoints();
}

inline std::string StartCntr::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float StartCntr::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string StartCntr::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int StartCntr::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string StartCntr::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int StartCntr::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int StartCntr::getMinOccurs() const {
   return 0;
}

inline const void *StartCntr::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline StcPaddle &StartCntr::getStcPaddle(int index) {
   return m_stcPaddle_list(index);
}

inline StcPaddleList &StartCntr::getStcPaddles() {
   return m_stcPaddle_list;
}

inline StcPaddleList StartCntr::addStcPaddles(int count, int start) {
   return m_stcPaddle_list.add(count,start);
}

inline void StartCntr::deleteStcPaddles(int count, int start) {
   m_stcPaddle_list.del(count,start);
}

inline StcTruthPoint &StartCntr::getStcTruthPoint(int index) {
   return m_stcTruthPoint_list(index);
}

inline StcTruthPointList &StartCntr::getStcTruthPoints() {
   return m_stcTruthPoint_list;
}

inline StcTruthPointList StartCntr::addStcTruthPoints(int count, int start) {
   return m_stcTruthPoint_list.add(count,start);
}

inline void StartCntr::deleteStcTruthPoints(int count, int start) {
   m_stcTruthPoint_list.del(count,start);
}

inline BcalSiPMUpHit::BcalSiPMUpHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_t(0)
{}

inline BcalSiPMUpHit::~BcalSiPMUpHit() {}

inline std::string BcalSiPMUpHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalSiPMUpHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalSiPMUpHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalSiPMUpHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalSiPMUpHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalSiPMUpHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalSiPMUpHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalSiPMUpHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float BcalSiPMUpHit::getE() const {
   return m_E;
}

inline void BcalSiPMUpHit::setE(float E) {
   m_E = E;
}

inline std::string BcalSiPMUpHit::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalSiPMUpHit::getMinOccurs() const {
   return 0;
}

inline float BcalSiPMUpHit::getT() const {
   return m_t;
}

inline void BcalSiPMUpHit::setT(float t) {
   m_t = t;
}

inline const void *BcalSiPMUpHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalSiPMDownHit::BcalSiPMDownHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_t(0)
{}

inline BcalSiPMDownHit::~BcalSiPMDownHit() {}

inline std::string BcalSiPMDownHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalSiPMDownHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalSiPMDownHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalSiPMDownHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalSiPMDownHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalSiPMDownHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalSiPMDownHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalSiPMDownHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float BcalSiPMDownHit::getE() const {
   return m_E;
}

inline void BcalSiPMDownHit::setE(float E) {
   m_E = E;
}

inline std::string BcalSiPMDownHit::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalSiPMDownHit::getMinOccurs() const {
   return 0;
}

inline float BcalSiPMDownHit::getT() const {
   return m_t;
}

inline void BcalSiPMDownHit::setT(float t) {
   m_t = t;
}

inline const void *BcalSiPMDownHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalSiPMTruth::BcalSiPMTruth(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_incident_id(0)
{}

inline BcalSiPMTruth::~BcalSiPMTruth() {}

inline std::string BcalSiPMTruth::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalSiPMTruth::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalSiPMTruth::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalSiPMTruth::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string BcalSiPMTruth::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int BcalSiPMTruth::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalSiPMTruth::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalSiPMTruth::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalSiPMTruth::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float BcalSiPMTruth::getBin_width() const {
   return *(float*)m_parent->getAttribute("bin_width");
}

inline int BcalSiPMTruth::getEnd() const {
   return *(int*)m_parent->getAttribute("end");
}

inline float BcalSiPMTruth::getTstart() const {
   return *(float*)m_parent->getAttribute("tstart");
}

inline std::string BcalSiPMTruth::getVals() const {
   return *(const std::string*)m_parent->getAttribute("vals");
}

inline float BcalSiPMTruth::getE() const {
   return m_E;
}

inline void BcalSiPMTruth::setE(float E) {
   m_E = E;
}

inline int BcalSiPMTruth::getIncident_id() const {
   return m_incident_id;
}

inline void BcalSiPMTruth::setIncident_id(int incident_id) {
   m_incident_id = incident_id;
}

inline int BcalSiPMTruth::getMinOccurs() const {
   return 0;
}

inline const void *BcalSiPMTruth::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "incident_id") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_incident_id;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalSiPMSpectrum::BcalSiPMSpectrum(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_bin_width(0),
   m_end(0),
   m_tstart(0),
   m_vals(""),
   m_bcalSiPMTruth_link(&m_host->m_bcalSiPMTruth_plist,
               m_host->m_bcalSiPMTruth_plist.end(),
               m_host->m_bcalSiPMTruth_plist.end(),
               this)
{}

inline BcalSiPMSpectrum::~BcalSiPMSpectrum() {
   deleteBcalSiPMTruths();
}

inline std::string BcalSiPMSpectrum::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalSiPMSpectrum::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalSiPMSpectrum::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalSiPMSpectrum::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalSiPMSpectrum::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalSiPMSpectrum::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalSiPMSpectrum::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalSiPMSpectrum::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float BcalSiPMSpectrum::getBin_width() const {
   return m_bin_width;
}

inline void BcalSiPMSpectrum::setBin_width(float bin_width) {
   m_bin_width = bin_width;
}

inline int BcalSiPMSpectrum::getEnd() const {
   return m_end;
}

inline void BcalSiPMSpectrum::setEnd(int end) {
   m_end = end;
}

inline std::string BcalSiPMSpectrum::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalSiPMSpectrum::getMinOccurs() const {
   return 0;
}

inline float BcalSiPMSpectrum::getTstart() const {
   return m_tstart;
}

inline void BcalSiPMSpectrum::setTstart(float tstart) {
   m_tstart = tstart;
}

inline std::string BcalSiPMSpectrum::getVals() const {
   return m_vals;
}

inline void BcalSiPMSpectrum::setVals(const std::string &vals) {
   m_vals = vals;
}

inline const void *BcalSiPMSpectrum::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "bin_width") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_bin_width;
   }
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "tstart") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_tstart;
   }
   if (name == "vals") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_vals;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalSiPMTruth &BcalSiPMSpectrum::getBcalSiPMTruth() {
   return m_bcalSiPMTruth_link.front();
}

inline BcalSiPMTruthList &BcalSiPMSpectrum::getBcalSiPMTruths() {
   return m_bcalSiPMTruth_link;
}

inline BcalSiPMTruthList BcalSiPMSpectrum::addBcalSiPMTruths(int count, int start) {
   return m_bcalSiPMTruth_link.add(count,start);
}

inline void BcalSiPMSpectrum::deleteBcalSiPMTruths(int count, int start) {
   m_bcalSiPMTruth_link.del(count,start);
}

inline BcalfADCHit::BcalfADCHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_end(0),
   m_t(0)
{}

inline BcalfADCHit::~BcalfADCHit() {}

inline std::string BcalfADCHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalfADCHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalfADCHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalfADCHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalfADCHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalfADCHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalfADCHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalfADCHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float BcalfADCHit::getE() const {
   return m_E;
}

inline void BcalfADCHit::setE(float E) {
   m_E = E;
}

inline int BcalfADCHit::getEnd() const {
   return m_end;
}

inline void BcalfADCHit::setEnd(int end) {
   m_end = end;
}

inline std::string BcalfADCHit::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalfADCHit::getMinOccurs() const {
   return 0;
}

inline float BcalfADCHit::getT() const {
   return m_t;
}

inline void BcalfADCHit::setT(float t) {
   m_t = t;
}

inline const void *BcalfADCHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalfADCPeak::BcalfADCPeak(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_peakAmp(0)
{}

inline BcalfADCPeak::~BcalfADCPeak() {}

inline std::string BcalfADCPeak::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalfADCPeak::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalfADCPeak::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalfADCPeak::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string BcalfADCPeak::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int BcalfADCPeak::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalfADCPeak::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalfADCPeak::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalfADCPeak::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline int BcalfADCPeak::getEnd() const {
   return *(int*)m_parent->getAttribute("end");
}

inline int BcalfADCPeak::getPulse_integral() const {
   return *(int*)m_parent->getAttribute("pulse_integral");
}

inline int BcalfADCPeak::getPulse_time() const {
   return *(int*)m_parent->getAttribute("pulse_time");
}

inline int BcalfADCPeak::getMinOccurs() const {
   return 0;
}

inline float BcalfADCPeak::getPeakAmp() const {
   return m_peakAmp;
}

inline void BcalfADCPeak::setPeakAmp(float peakAmp) {
   m_peakAmp = peakAmp;
}

inline const void *BcalfADCPeak::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "peakAmp") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_peakAmp;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalfADCDigiHit::BcalfADCDigiHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_end(0),
   m_pulse_integral(0),
   m_pulse_time(0),
   m_bcalfADCPeak_link(&m_host->m_bcalfADCPeak_plist,
               m_host->m_bcalfADCPeak_plist.end(),
               m_host->m_bcalfADCPeak_plist.end(),
               this)
{}

inline BcalfADCDigiHit::~BcalfADCDigiHit() {
   deleteBcalfADCPeaks();
}

inline std::string BcalfADCDigiHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalfADCDigiHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalfADCDigiHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalfADCDigiHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalfADCDigiHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalfADCDigiHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalfADCDigiHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalfADCDigiHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline int BcalfADCDigiHit::getEnd() const {
   return m_end;
}

inline void BcalfADCDigiHit::setEnd(int end) {
   m_end = end;
}

inline std::string BcalfADCDigiHit::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalfADCDigiHit::getMinOccurs() const {
   return 0;
}

inline int BcalfADCDigiHit::getPulse_integral() const {
   return m_pulse_integral;
}

inline void BcalfADCDigiHit::setPulse_integral(int pulse_integral) {
   m_pulse_integral = pulse_integral;
}

inline int BcalfADCDigiHit::getPulse_time() const {
   return m_pulse_time;
}

inline void BcalfADCDigiHit::setPulse_time(int pulse_time) {
   m_pulse_time = pulse_time;
}

inline const void *BcalfADCDigiHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "pulse_integral") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_pulse_integral;
   }
   if (name == "pulse_time") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_pulse_time;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalfADCPeak &BcalfADCDigiHit::getBcalfADCPeak() {
   return m_bcalfADCPeak_link.front();
}

inline BcalfADCPeakList &BcalfADCDigiHit::getBcalfADCPeaks() {
   return m_bcalfADCPeak_link;
}

inline BcalfADCPeakList BcalfADCDigiHit::addBcalfADCPeaks(int count, int start) {
   return m_bcalfADCPeak_link.add(count,start);
}

inline void BcalfADCDigiHit::deleteBcalfADCPeaks(int count, int start) {
   m_bcalfADCPeak_link.del(count,start);
}

inline BcalTDCHit::BcalTDCHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_end(0),
   m_t(0)
{}

inline BcalTDCHit::~BcalTDCHit() {}

inline std::string BcalTDCHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalTDCHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalTDCHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalTDCHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalTDCHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalTDCHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalTDCHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalTDCHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline int BcalTDCHit::getEnd() const {
   return m_end;
}

inline void BcalTDCHit::setEnd(int end) {
   m_end = end;
}

inline std::string BcalTDCHit::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalTDCHit::getMinOccurs() const {
   return 0;
}

inline float BcalTDCHit::getT() const {
   return m_t;
}

inline void BcalTDCHit::setT(float t) {
   m_t = t;
}

inline const void *BcalTDCHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalTDCDigiHit::BcalTDCDigiHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_end(0),
   m_time(0)
{}

inline BcalTDCDigiHit::~BcalTDCDigiHit() {}

inline std::string BcalTDCDigiHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalTDCDigiHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalTDCDigiHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalTDCDigiHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalTDCDigiHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalTDCDigiHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalTDCDigiHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalTDCDigiHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline int BcalTDCDigiHit::getEnd() const {
   return m_end;
}

inline void BcalTDCDigiHit::setEnd(int end) {
   m_end = end;
}

inline std::string BcalTDCDigiHit::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalTDCDigiHit::getMinOccurs() const {
   return 0;
}

inline float BcalTDCDigiHit::getTime() const {
   return m_time;
}

inline void BcalTDCDigiHit::setTime(float time) {
   m_time = time;
}

inline const void *BcalTDCDigiHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "time") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_time;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalTruthHit::BcalTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_incident_id(0),
   m_t(0),
   m_zLocal(0)
{}

inline BcalTruthHit::~BcalTruthHit() {}

inline std::string BcalTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalTruthHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int BcalTruthHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline int BcalTruthHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float BcalTruthHit::getE() const {
   return m_E;
}

inline void BcalTruthHit::setE(float E) {
   m_E = E;
}

inline int BcalTruthHit::getIncident_id() const {
   return m_incident_id;
}

inline void BcalTruthHit::setIncident_id(int incident_id) {
   m_incident_id = incident_id;
}

inline std::string BcalTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalTruthHit::getMinOccurs() const {
   return 0;
}

inline float BcalTruthHit::getT() const {
   return m_t;
}

inline void BcalTruthHit::setT(float t) {
   m_t = t;
}

inline float BcalTruthHit::getZLocal() const {
   return m_zLocal;
}

inline void BcalTruthHit::setZLocal(float zLocal) {
   m_zLocal = zLocal;
}

inline const void *BcalTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "incident_id") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_incident_id;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "zLocal") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_zLocal;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalCell::BcalCell(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_layer(0),
   m_module(0),
   m_sector(0),
   m_bcalSiPMUpHit_list(&m_host->m_bcalSiPMUpHit_plist,
               m_host->m_bcalSiPMUpHit_plist.end(),
               m_host->m_bcalSiPMUpHit_plist.end(),
               this),
   m_bcalSiPMDownHit_list(&m_host->m_bcalSiPMDownHit_plist,
               m_host->m_bcalSiPMDownHit_plist.end(),
               m_host->m_bcalSiPMDownHit_plist.end(),
               this),
   m_bcalSiPMSpectrum_list(&m_host->m_bcalSiPMSpectrum_plist,
               m_host->m_bcalSiPMSpectrum_plist.end(),
               m_host->m_bcalSiPMSpectrum_plist.end(),
               this),
   m_bcalfADCHit_list(&m_host->m_bcalfADCHit_plist,
               m_host->m_bcalfADCHit_plist.end(),
               m_host->m_bcalfADCHit_plist.end(),
               this),
   m_bcalfADCDigiHit_list(&m_host->m_bcalfADCDigiHit_plist,
               m_host->m_bcalfADCDigiHit_plist.end(),
               m_host->m_bcalfADCDigiHit_plist.end(),
               this),
   m_bcalTDCHit_list(&m_host->m_bcalTDCHit_plist,
               m_host->m_bcalTDCHit_plist.end(),
               m_host->m_bcalTDCHit_plist.end(),
               this),
   m_bcalTDCDigiHit_list(&m_host->m_bcalTDCDigiHit_plist,
               m_host->m_bcalTDCDigiHit_plist.end(),
               m_host->m_bcalTDCDigiHit_plist.end(),
               this),
   m_bcalTruthHit_list(&m_host->m_bcalTruthHit_plist,
               m_host->m_bcalTruthHit_plist.end(),
               m_host->m_bcalTruthHit_plist.end(),
               this)
{}

inline BcalCell::~BcalCell() {
   deleteBcalSiPMUpHits();
   deleteBcalSiPMDownHits();
   deleteBcalSiPMSpectrums();
   deleteBcalfADCHits();
   deleteBcalfADCDigiHits();
   deleteBcalTDCHits();
   deleteBcalTDCDigiHits();
   deleteBcalTruthHits();
}

inline std::string BcalCell::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalCell::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalCell::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalCell::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalCell::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalCell::getLayer() const {
   return m_layer;
}

inline void BcalCell::setLayer(int layer) {
   m_layer = layer;
}

inline std::string BcalCell::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalCell::getMinOccurs() const {
   return 0;
}

inline int BcalCell::getModule() const {
   return m_module;
}

inline void BcalCell::setModule(int module) {
   m_module = module;
}

inline int BcalCell::getSector() const {
   return m_sector;
}

inline void BcalCell::setSector(int sector) {
   m_sector = sector;
}

inline const void *BcalCell::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "layer") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_layer;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "module") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_module;
   }
   if (name == "sector") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_sector;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalSiPMUpHit &BcalCell::getBcalSiPMUpHit(int index) {
   return m_bcalSiPMUpHit_list(index);
}

inline BcalSiPMUpHitList &BcalCell::getBcalSiPMUpHits() {
   return m_bcalSiPMUpHit_list;
}

inline BcalSiPMUpHitList BcalCell::addBcalSiPMUpHits(int count, int start) {
   return m_bcalSiPMUpHit_list.add(count,start);
}

inline void BcalCell::deleteBcalSiPMUpHits(int count, int start) {
   m_bcalSiPMUpHit_list.del(count,start);
}

inline BcalSiPMDownHit &BcalCell::getBcalSiPMDownHit(int index) {
   return m_bcalSiPMDownHit_list(index);
}

inline BcalSiPMDownHitList &BcalCell::getBcalSiPMDownHits() {
   return m_bcalSiPMDownHit_list;
}

inline BcalSiPMDownHitList BcalCell::addBcalSiPMDownHits(int count, int start) {
   return m_bcalSiPMDownHit_list.add(count,start);
}

inline void BcalCell::deleteBcalSiPMDownHits(int count, int start) {
   m_bcalSiPMDownHit_list.del(count,start);
}

inline BcalSiPMSpectrum &BcalCell::getBcalSiPMSpectrum(int index) {
   return m_bcalSiPMSpectrum_list(index);
}

inline BcalSiPMSpectrumList &BcalCell::getBcalSiPMSpectrums() {
   return m_bcalSiPMSpectrum_list;
}

inline BcalSiPMSpectrumList BcalCell::addBcalSiPMSpectrums(int count, int start) {
   return m_bcalSiPMSpectrum_list.add(count,start);
}

inline void BcalCell::deleteBcalSiPMSpectrums(int count, int start) {
   m_bcalSiPMSpectrum_list.del(count,start);
}

inline BcalfADCHit &BcalCell::getBcalfADCHit(int index) {
   return m_bcalfADCHit_list(index);
}

inline BcalfADCHitList &BcalCell::getBcalfADCHits() {
   return m_bcalfADCHit_list;
}

inline BcalfADCHitList BcalCell::addBcalfADCHits(int count, int start) {
   return m_bcalfADCHit_list.add(count,start);
}

inline void BcalCell::deleteBcalfADCHits(int count, int start) {
   m_bcalfADCHit_list.del(count,start);
}

inline BcalfADCDigiHit &BcalCell::getBcalfADCDigiHit(int index) {
   return m_bcalfADCDigiHit_list(index);
}

inline BcalfADCDigiHitList &BcalCell::getBcalfADCDigiHits() {
   return m_bcalfADCDigiHit_list;
}

inline BcalfADCDigiHitList BcalCell::addBcalfADCDigiHits(int count, int start) {
   return m_bcalfADCDigiHit_list.add(count,start);
}

inline void BcalCell::deleteBcalfADCDigiHits(int count, int start) {
   m_bcalfADCDigiHit_list.del(count,start);
}

inline BcalTDCHit &BcalCell::getBcalTDCHit(int index) {
   return m_bcalTDCHit_list(index);
}

inline BcalTDCHitList &BcalCell::getBcalTDCHits() {
   return m_bcalTDCHit_list;
}

inline BcalTDCHitList BcalCell::addBcalTDCHits(int count, int start) {
   return m_bcalTDCHit_list.add(count,start);
}

inline void BcalCell::deleteBcalTDCHits(int count, int start) {
   m_bcalTDCHit_list.del(count,start);
}

inline BcalTDCDigiHit &BcalCell::getBcalTDCDigiHit(int index) {
   return m_bcalTDCDigiHit_list(index);
}

inline BcalTDCDigiHitList &BcalCell::getBcalTDCDigiHits() {
   return m_bcalTDCDigiHit_list;
}

inline BcalTDCDigiHitList BcalCell::addBcalTDCDigiHits(int count, int start) {
   return m_bcalTDCDigiHit_list.add(count,start);
}

inline void BcalCell::deleteBcalTDCDigiHits(int count, int start) {
   m_bcalTDCDigiHit_list.del(count,start);
}

inline BcalTruthHit &BcalCell::getBcalTruthHit(int index) {
   return m_bcalTruthHit_list(index);
}

inline BcalTruthHitList &BcalCell::getBcalTruthHits() {
   return m_bcalTruthHit_list;
}

inline BcalTruthHitList BcalCell::addBcalTruthHits(int count, int start) {
   return m_bcalTruthHit_list.add(count,start);
}

inline void BcalCell::deleteBcalTruthHits(int count, int start) {
   m_bcalTruthHit_list.del(count,start);
}

inline BcalTruthIncidentParticle::BcalTruthIncidentParticle(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_id(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_x(0),
   m_y(0),
   m_z(0)
{}

inline BcalTruthIncidentParticle::~BcalTruthIncidentParticle() {}

inline std::string BcalTruthIncidentParticle::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalTruthIncidentParticle::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalTruthIncidentParticle::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalTruthIncidentParticle::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalTruthIncidentParticle::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BcalTruthIncidentParticle::getId() const {
   return m_id;
}

inline void BcalTruthIncidentParticle::setId(int id) {
   m_id = id;
}

inline std::string BcalTruthIncidentParticle::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalTruthIncidentParticle::getMinOccurs() const {
   return 0;
}

inline int BcalTruthIncidentParticle::getPtype() const {
   return m_ptype;
}

inline void BcalTruthIncidentParticle::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float BcalTruthIncidentParticle::getPx() const {
   return m_px;
}

inline void BcalTruthIncidentParticle::setPx(float px) {
   m_px = px;
}

inline float BcalTruthIncidentParticle::getPy() const {
   return m_py;
}

inline void BcalTruthIncidentParticle::setPy(float py) {
   m_py = py;
}

inline float BcalTruthIncidentParticle::getPz() const {
   return m_pz;
}

inline void BcalTruthIncidentParticle::setPz(float pz) {
   m_pz = pz;
}

inline float BcalTruthIncidentParticle::getX() const {
   return m_x;
}

inline void BcalTruthIncidentParticle::setX(float x) {
   m_x = x;
}

inline float BcalTruthIncidentParticle::getY() const {
   return m_y;
}

inline void BcalTruthIncidentParticle::setY(float y) {
   m_y = y;
}

inline float BcalTruthIncidentParticle::getZ() const {
   return m_z;
}

inline void BcalTruthIncidentParticle::setZ(float z) {
   m_z = z;
}

inline const void *BcalTruthIncidentParticle::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "id") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_id;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalTruthShower::BcalTruthShower(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_phi(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_r(0),
   m_t(0),
   m_track(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline BcalTruthShower::~BcalTruthShower() {
   deleteTrackIDs();
}

inline std::string BcalTruthShower::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BcalTruthShower::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BcalTruthShower::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BcalTruthShower::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int BcalTruthShower::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float BcalTruthShower::getE() const {
   return m_E;
}

inline void BcalTruthShower::setE(float E) {
   m_E = E;
}

inline std::string BcalTruthShower::getMaxOccurs() const {
   return "unbounded";
}

inline int BcalTruthShower::getMinOccurs() const {
   return 0;
}

inline float BcalTruthShower::getPhi() const {
   return m_phi;
}

inline void BcalTruthShower::setPhi(float phi) {
   m_phi = phi;
}

inline bool BcalTruthShower::getPrimary() const {
   return m_primary;
}

inline void BcalTruthShower::setPrimary(bool primary) {
   m_primary = primary;
}

inline int BcalTruthShower::getPtype() const {
   return m_ptype;
}

inline void BcalTruthShower::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float BcalTruthShower::getPx() const {
   return m_px;
}

inline void BcalTruthShower::setPx(float px) {
   m_px = px;
}

inline float BcalTruthShower::getPy() const {
   return m_py;
}

inline void BcalTruthShower::setPy(float py) {
   m_py = py;
}

inline float BcalTruthShower::getPz() const {
   return m_pz;
}

inline void BcalTruthShower::setPz(float pz) {
   m_pz = pz;
}

inline float BcalTruthShower::getR() const {
   return m_r;
}

inline void BcalTruthShower::setR(float r) {
   m_r = r;
}

inline float BcalTruthShower::getT() const {
   return m_t;
}

inline void BcalTruthShower::setT(float t) {
   m_t = t;
}

inline int BcalTruthShower::getTrack() const {
   return m_track;
}

inline void BcalTruthShower::setTrack(int track) {
   m_track = track;
}

inline float BcalTruthShower::getZ() const {
   return m_z;
}

inline void BcalTruthShower::setZ(float z) {
   m_z = z;
}

inline const void *BcalTruthShower::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "phi") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_phi;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "r") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_r;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &BcalTruthShower::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &BcalTruthShower::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList BcalTruthShower::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void BcalTruthShower::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline BarrelEMcal::BarrelEMcal(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_bcalCell_list(&m_host->m_bcalCell_plist,
               m_host->m_bcalCell_plist.end(),
               m_host->m_bcalCell_plist.end(),
               this),
   m_bcalTruthIncidentParticle_list(&m_host->m_bcalTruthIncidentParticle_plist,
               m_host->m_bcalTruthIncidentParticle_plist.end(),
               m_host->m_bcalTruthIncidentParticle_plist.end(),
               this),
   m_bcalTruthShower_list(&m_host->m_bcalTruthShower_plist,
               m_host->m_bcalTruthShower_plist.end(),
               m_host->m_bcalTruthShower_plist.end(),
               this)
{}

inline BarrelEMcal::~BarrelEMcal() {
   deleteBcalCells();
   deleteBcalTruthIncidentParticles();
   deleteBcalTruthShowers();
}

inline std::string BarrelEMcal::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float BarrelEMcal::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string BarrelEMcal::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int BarrelEMcal::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string BarrelEMcal::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int BarrelEMcal::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int BarrelEMcal::getMinOccurs() const {
   return 0;
}

inline const void *BarrelEMcal::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline BcalCell &BarrelEMcal::getBcalCell(int index) {
   return m_bcalCell_list(index);
}

inline BcalCellList &BarrelEMcal::getBcalCells() {
   return m_bcalCell_list;
}

inline BcalCellList BarrelEMcal::addBcalCells(int count, int start) {
   return m_bcalCell_list.add(count,start);
}

inline void BarrelEMcal::deleteBcalCells(int count, int start) {
   m_bcalCell_list.del(count,start);
}

inline BcalTruthIncidentParticle &BarrelEMcal::getBcalTruthIncidentParticle(int index) {
   return m_bcalTruthIncidentParticle_list(index);
}

inline BcalTruthIncidentParticleList &BarrelEMcal::getBcalTruthIncidentParticles() {
   return m_bcalTruthIncidentParticle_list;
}

inline BcalTruthIncidentParticleList BarrelEMcal::addBcalTruthIncidentParticles(int count, int start) {
   return m_bcalTruthIncidentParticle_list.add(count,start);
}

inline void BarrelEMcal::deleteBcalTruthIncidentParticles(int count, int start) {
   m_bcalTruthIncidentParticle_list.del(count,start);
}

inline BcalTruthShower &BarrelEMcal::getBcalTruthShower(int index) {
   return m_bcalTruthShower_list(index);
}

inline BcalTruthShowerList &BarrelEMcal::getBcalTruthShowers() {
   return m_bcalTruthShower_list;
}

inline BcalTruthShowerList BarrelEMcal::addBcalTruthShowers(int count, int start) {
   return m_bcalTruthShower_list.add(count,start);
}

inline void BarrelEMcal::deleteBcalTruthShowers(int count, int start) {
   m_bcalTruthShower_list.del(count,start);
}

inline GcalHit::GcalHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_t(0),
   m_zLocal(0)
{}

inline GcalHit::~GcalHit() {}

inline std::string GcalHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float GcalHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string GcalHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int GcalHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int GcalHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int GcalHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline float GcalHit::getE() const {
   return m_E;
}

inline void GcalHit::setE(float E) {
   m_E = E;
}

inline std::string GcalHit::getMaxOccurs() const {
   return "unbounded";
}

inline int GcalHit::getMinOccurs() const {
   return 0;
}

inline float GcalHit::getT() const {
   return m_t;
}

inline void GcalHit::setT(float t) {
   m_t = t;
}

inline float GcalHit::getZLocal() const {
   return m_zLocal;
}

inline void GcalHit::setZLocal(float zLocal) {
   m_zLocal = zLocal;
}

inline const void *GcalHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "zLocal") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_zLocal;
   }
   return m_parent->getAttribute(name, atype);
}

inline GcalTruthHit::GcalTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_t(0),
   m_zLocal(0)
{}

inline GcalTruthHit::~GcalTruthHit() {}

inline std::string GcalTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float GcalTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string GcalTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int GcalTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int GcalTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int GcalTruthHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline float GcalTruthHit::getE() const {
   return m_E;
}

inline void GcalTruthHit::setE(float E) {
   m_E = E;
}

inline std::string GcalTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int GcalTruthHit::getMinOccurs() const {
   return 0;
}

inline float GcalTruthHit::getT() const {
   return m_t;
}

inline void GcalTruthHit::setT(float t) {
   m_t = t;
}

inline float GcalTruthHit::getZLocal() const {
   return m_zLocal;
}

inline void GcalTruthHit::setZLocal(float zLocal) {
   m_zLocal = zLocal;
}

inline const void *GcalTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "zLocal") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_zLocal;
   }
   return m_parent->getAttribute(name, atype);
}

inline GcalCell::GcalCell(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_module(0),
   m_gcalHit_list(&m_host->m_gcalHit_plist,
               m_host->m_gcalHit_plist.end(),
               m_host->m_gcalHit_plist.end(),
               this),
   m_gcalTruthHit_list(&m_host->m_gcalTruthHit_plist,
               m_host->m_gcalTruthHit_plist.end(),
               m_host->m_gcalTruthHit_plist.end(),
               this)
{}

inline GcalCell::~GcalCell() {
   deleteGcalHits();
   deleteGcalTruthHits();
}

inline std::string GcalCell::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float GcalCell::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string GcalCell::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int GcalCell::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int GcalCell::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int GcalCell::getMaxOccurs() const {
   return 48;
}

inline int GcalCell::getMinOccurs() const {
   return 0;
}

inline int GcalCell::getModule() const {
   return m_module;
}

inline void GcalCell::setModule(int module) {
   m_module = module;
}

inline const void *GcalCell::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "module") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_module;
   }
   return m_parent->getAttribute(name, atype);
}

inline GcalHit &GcalCell::getGcalHit(int index) {
   return m_gcalHit_list(index);
}

inline GcalHitList &GcalCell::getGcalHits() {
   return m_gcalHit_list;
}

inline GcalHitList GcalCell::addGcalHits(int count, int start) {
   return m_gcalHit_list.add(count,start);
}

inline void GcalCell::deleteGcalHits(int count, int start) {
   m_gcalHit_list.del(count,start);
}

inline GcalTruthHit &GcalCell::getGcalTruthHit(int index) {
   return m_gcalTruthHit_list(index);
}

inline GcalTruthHitList &GcalCell::getGcalTruthHits() {
   return m_gcalTruthHit_list;
}

inline GcalTruthHitList GcalCell::addGcalTruthHits(int count, int start) {
   return m_gcalTruthHit_list.add(count,start);
}

inline void GcalCell::deleteGcalTruthHits(int count, int start) {
   m_gcalTruthHit_list.del(count,start);
}

inline GcalTruthShower::GcalTruthShower(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_phi(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_r(0),
   m_t(0),
   m_track(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline GcalTruthShower::~GcalTruthShower() {
   deleteTrackIDs();
}

inline std::string GcalTruthShower::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float GcalTruthShower::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string GcalTruthShower::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int GcalTruthShower::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int GcalTruthShower::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float GcalTruthShower::getE() const {
   return m_E;
}

inline void GcalTruthShower::setE(float E) {
   m_E = E;
}

inline std::string GcalTruthShower::getMaxOccurs() const {
   return "unbounded";
}

inline int GcalTruthShower::getMinOccurs() const {
   return 0;
}

inline float GcalTruthShower::getPhi() const {
   return m_phi;
}

inline void GcalTruthShower::setPhi(float phi) {
   m_phi = phi;
}

inline bool GcalTruthShower::getPrimary() const {
   return m_primary;
}

inline void GcalTruthShower::setPrimary(bool primary) {
   m_primary = primary;
}

inline int GcalTruthShower::getPtype() const {
   return m_ptype;
}

inline void GcalTruthShower::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float GcalTruthShower::getPx() const {
   return m_px;
}

inline void GcalTruthShower::setPx(float px) {
   m_px = px;
}

inline float GcalTruthShower::getPy() const {
   return m_py;
}

inline void GcalTruthShower::setPy(float py) {
   m_py = py;
}

inline float GcalTruthShower::getPz() const {
   return m_pz;
}

inline void GcalTruthShower::setPz(float pz) {
   m_pz = pz;
}

inline float GcalTruthShower::getR() const {
   return m_r;
}

inline void GcalTruthShower::setR(float r) {
   m_r = r;
}

inline float GcalTruthShower::getT() const {
   return m_t;
}

inline void GcalTruthShower::setT(float t) {
   m_t = t;
}

inline int GcalTruthShower::getTrack() const {
   return m_track;
}

inline void GcalTruthShower::setTrack(int track) {
   m_track = track;
}

inline float GcalTruthShower::getZ() const {
   return m_z;
}

inline void GcalTruthShower::setZ(float z) {
   m_z = z;
}

inline const void *GcalTruthShower::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "phi") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_phi;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "r") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_r;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &GcalTruthShower::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &GcalTruthShower::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList GcalTruthShower::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void GcalTruthShower::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline GapEMcal::GapEMcal(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_gcalCell_list(&m_host->m_gcalCell_plist,
               m_host->m_gcalCell_plist.end(),
               m_host->m_gcalCell_plist.end(),
               this),
   m_gcalTruthShower_list(&m_host->m_gcalTruthShower_plist,
               m_host->m_gcalTruthShower_plist.end(),
               m_host->m_gcalTruthShower_plist.end(),
               this)
{}

inline GapEMcal::~GapEMcal() {
   deleteGcalCells();
   deleteGcalTruthShowers();
}

inline std::string GapEMcal::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float GapEMcal::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string GapEMcal::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int GapEMcal::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string GapEMcal::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int GapEMcal::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int GapEMcal::getMinOccurs() const {
   return 0;
}

inline const void *GapEMcal::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline GcalCell &GapEMcal::getGcalCell(int index) {
   return m_gcalCell_list(index);
}

inline GcalCellList &GapEMcal::getGcalCells() {
   return m_gcalCell_list;
}

inline GcalCellList GapEMcal::addGcalCells(int count, int start) {
   return m_gcalCell_list.add(count,start);
}

inline void GapEMcal::deleteGcalCells(int count, int start) {
   m_gcalCell_list.del(count,start);
}

inline GcalTruthShower &GapEMcal::getGcalTruthShower(int index) {
   return m_gcalTruthShower_list(index);
}

inline GcalTruthShowerList &GapEMcal::getGcalTruthShowers() {
   return m_gcalTruthShower_list;
}

inline GcalTruthShowerList GapEMcal::addGcalTruthShowers(int count, int start) {
   return m_gcalTruthShower_list.add(count,start);
}

inline void GapEMcal::deleteGcalTruthShowers(int count, int start) {
   m_gcalTruthShower_list.del(count,start);
}

inline CereHit::CereHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_pe(0),
   m_t(0)
{}

inline CereHit::~CereHit() {}

inline std::string CereHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CereHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CereHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CereHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CereHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CereHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int CereHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline std::string CereHit::getMaxOccurs() const {
   return "unbounded";
}

inline float CereHit::getPe() const {
   return m_pe;
}

inline void CereHit::setPe(float pe) {
   m_pe = pe;
}

inline float CereHit::getT() const {
   return m_t;
}

inline void CereHit::setT(float t) {
   m_t = t;
}

inline const void *CereHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "pe") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pe;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline CereTruthHit::CereTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_pe(0),
   m_t(0)
{}

inline CereTruthHit::~CereTruthHit() {}

inline std::string CereTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CereTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CereTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CereTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CereTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CereTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int CereTruthHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline std::string CereTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline float CereTruthHit::getPe() const {
   return m_pe;
}

inline void CereTruthHit::setPe(float pe) {
   m_pe = pe;
}

inline float CereTruthHit::getT() const {
   return m_t;
}

inline void CereTruthHit::setT(float t) {
   m_t = t;
}

inline const void *CereTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "pe") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pe;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline CereSection::CereSection(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_sector(0),
   m_cereHit_list(&m_host->m_cereHit_plist,
               m_host->m_cereHit_plist.end(),
               m_host->m_cereHit_plist.end(),
               this),
   m_cereTruthHit_list(&m_host->m_cereTruthHit_plist,
               m_host->m_cereTruthHit_plist.end(),
               m_host->m_cereTruthHit_plist.end(),
               this)
{}

inline CereSection::~CereSection() {
   deleteCereHits();
   deleteCereTruthHits();
}

inline std::string CereSection::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CereSection::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CereSection::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CereSection::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CereSection::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string CereSection::getMaxOccurs() const {
   return "unbounded";
}

inline int CereSection::getMinOccurs() const {
   return 0;
}

inline int CereSection::getSector() const {
   return m_sector;
}

inline void CereSection::setSector(int sector) {
   m_sector = sector;
}

inline const void *CereSection::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "sector") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_sector;
   }
   return m_parent->getAttribute(name, atype);
}

inline CereHit &CereSection::getCereHit(int index) {
   return m_cereHit_list(index);
}

inline CereHitList &CereSection::getCereHits() {
   return m_cereHit_list;
}

inline CereHitList CereSection::addCereHits(int count, int start) {
   return m_cereHit_list.add(count,start);
}

inline void CereSection::deleteCereHits(int count, int start) {
   m_cereHit_list.del(count,start);
}

inline CereTruthHit &CereSection::getCereTruthHit(int index) {
   return m_cereTruthHit_list(index);
}

inline CereTruthHitList &CereSection::getCereTruthHits() {
   return m_cereTruthHit_list;
}

inline CereTruthHitList CereSection::addCereTruthHits(int count, int start) {
   return m_cereTruthHit_list.add(count,start);
}

inline void CereSection::deleteCereTruthHits(int count, int start) {
   m_cereTruthHit_list.del(count,start);
}

inline CereTruthPoint::CereTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline CereTruthPoint::~CereTruthPoint() {
   deleteTrackIDs();
}

inline std::string CereTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CereTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CereTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CereTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CereTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float CereTruthPoint::getE() const {
   return m_E;
}

inline void CereTruthPoint::setE(float E) {
   m_E = E;
}

inline std::string CereTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int CereTruthPoint::getMinOccurs() const {
   return 0;
}

inline bool CereTruthPoint::getPrimary() const {
   return m_primary;
}

inline void CereTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int CereTruthPoint::getPtype() const {
   return m_ptype;
}

inline void CereTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float CereTruthPoint::getPx() const {
   return m_px;
}

inline void CereTruthPoint::setPx(float px) {
   m_px = px;
}

inline float CereTruthPoint::getPy() const {
   return m_py;
}

inline void CereTruthPoint::setPy(float py) {
   m_py = py;
}

inline float CereTruthPoint::getPz() const {
   return m_pz;
}

inline void CereTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float CereTruthPoint::getT() const {
   return m_t;
}

inline void CereTruthPoint::setT(float t) {
   m_t = t;
}

inline int CereTruthPoint::getTrack() const {
   return m_track;
}

inline void CereTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float CereTruthPoint::getX() const {
   return m_x;
}

inline void CereTruthPoint::setX(float x) {
   m_x = x;
}

inline float CereTruthPoint::getY() const {
   return m_y;
}

inline void CereTruthPoint::setY(float y) {
   m_y = y;
}

inline float CereTruthPoint::getZ() const {
   return m_z;
}

inline void CereTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *CereTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &CereTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &CereTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList CereTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void CereTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline Cerenkov::Cerenkov(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_cereSection_list(&m_host->m_cereSection_plist,
               m_host->m_cereSection_plist.end(),
               m_host->m_cereSection_plist.end(),
               this),
   m_cereTruthPoint_list(&m_host->m_cereTruthPoint_plist,
               m_host->m_cereTruthPoint_plist.end(),
               m_host->m_cereTruthPoint_plist.end(),
               this)
{}

inline Cerenkov::~Cerenkov() {
   deleteCereSections();
   deleteCereTruthPoints();
}

inline std::string Cerenkov::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Cerenkov::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Cerenkov::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Cerenkov::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string Cerenkov::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int Cerenkov::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Cerenkov::getMinOccurs() const {
   return 0;
}

inline const void *Cerenkov::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline CereSection &Cerenkov::getCereSection(int index) {
   return m_cereSection_list(index);
}

inline CereSectionList &Cerenkov::getCereSections() {
   return m_cereSection_list;
}

inline CereSectionList Cerenkov::addCereSections(int count, int start) {
   return m_cereSection_list.add(count,start);
}

inline void Cerenkov::deleteCereSections(int count, int start) {
   m_cereSection_list.del(count,start);
}

inline CereTruthPoint &Cerenkov::getCereTruthPoint(int index) {
   return m_cereTruthPoint_list(index);
}

inline CereTruthPointList &Cerenkov::getCereTruthPoints() {
   return m_cereTruthPoint_list;
}

inline CereTruthPointList Cerenkov::addCereTruthPoints(int count, int start) {
   return m_cereTruthPoint_list.add(count,start);
}

inline void Cerenkov::deleteCereTruthPoints(int count, int start) {
   m_cereTruthPoint_list.del(count,start);
}

inline RichTruthHit::RichTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_t(0),
   m_x(0),
   m_y(0),
   m_z(0)
{}

inline RichTruthHit::~RichTruthHit() {}

inline std::string RichTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float RichTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string RichTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int RichTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int RichTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string RichTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int RichTruthHit::getMinOccurs() const {
   return 0;
}

inline float RichTruthHit::getT() const {
   return m_t;
}

inline void RichTruthHit::setT(float t) {
   m_t = t;
}

inline float RichTruthHit::getX() const {
   return m_x;
}

inline void RichTruthHit::setX(float x) {
   m_x = x;
}

inline float RichTruthHit::getY() const {
   return m_y;
}

inline void RichTruthHit::setY(float y) {
   m_y = y;
}

inline float RichTruthHit::getZ() const {
   return m_z;
}

inline void RichTruthHit::setZ(float z) {
   m_z = z;
}

inline const void *RichTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline RichTruthPoint::RichTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline RichTruthPoint::~RichTruthPoint() {
   deleteTrackIDs();
}

inline std::string RichTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float RichTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string RichTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int RichTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int RichTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float RichTruthPoint::getE() const {
   return m_E;
}

inline void RichTruthPoint::setE(float E) {
   m_E = E;
}

inline std::string RichTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int RichTruthPoint::getMinOccurs() const {
   return 0;
}

inline bool RichTruthPoint::getPrimary() const {
   return m_primary;
}

inline void RichTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int RichTruthPoint::getPtype() const {
   return m_ptype;
}

inline void RichTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float RichTruthPoint::getPx() const {
   return m_px;
}

inline void RichTruthPoint::setPx(float px) {
   m_px = px;
}

inline float RichTruthPoint::getPy() const {
   return m_py;
}

inline void RichTruthPoint::setPy(float py) {
   m_py = py;
}

inline float RichTruthPoint::getPz() const {
   return m_pz;
}

inline void RichTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float RichTruthPoint::getT() const {
   return m_t;
}

inline void RichTruthPoint::setT(float t) {
   m_t = t;
}

inline int RichTruthPoint::getTrack() const {
   return m_track;
}

inline void RichTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float RichTruthPoint::getX() const {
   return m_x;
}

inline void RichTruthPoint::setX(float x) {
   m_x = x;
}

inline float RichTruthPoint::getY() const {
   return m_y;
}

inline void RichTruthPoint::setY(float y) {
   m_y = y;
}

inline float RichTruthPoint::getZ() const {
   return m_z;
}

inline void RichTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *RichTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &RichTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &RichTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList RichTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void RichTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline RICH::RICH(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_richTruthHit_list(&m_host->m_richTruthHit_plist,
               m_host->m_richTruthHit_plist.end(),
               m_host->m_richTruthHit_plist.end(),
               this),
   m_richTruthPoint_list(&m_host->m_richTruthPoint_plist,
               m_host->m_richTruthPoint_plist.end(),
               m_host->m_richTruthPoint_plist.end(),
               this)
{}

inline RICH::~RICH() {
   deleteRichTruthHits();
   deleteRichTruthPoints();
}

inline std::string RICH::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float RICH::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string RICH::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int RICH::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string RICH::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int RICH::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int RICH::getMinOccurs() const {
   return 0;
}

inline const void *RICH::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline RichTruthHit &RICH::getRichTruthHit(int index) {
   return m_richTruthHit_list(index);
}

inline RichTruthHitList &RICH::getRichTruthHits() {
   return m_richTruthHit_list;
}

inline RichTruthHitList RICH::addRichTruthHits(int count, int start) {
   return m_richTruthHit_list.add(count,start);
}

inline void RICH::deleteRichTruthHits(int count, int start) {
   m_richTruthHit_list.del(count,start);
}

inline RichTruthPoint &RICH::getRichTruthPoint(int index) {
   return m_richTruthPoint_list(index);
}

inline RichTruthPointList &RICH::getRichTruthPoints() {
   return m_richTruthPoint_list;
}

inline RichTruthPointList RICH::addRichTruthPoints(int count, int start) {
   return m_richTruthPoint_list.add(count,start);
}

inline void RICH::deleteRichTruthPoints(int count, int start) {
   m_richTruthPoint_list.del(count,start);
}

inline DircTruthBarHit::DircTruthBarHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_bar(0),
   m_pdg(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0)
{}

inline DircTruthBarHit::~DircTruthBarHit() {}

inline std::string DircTruthBarHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float DircTruthBarHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string DircTruthBarHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int DircTruthBarHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int DircTruthBarHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float DircTruthBarHit::getE() const {
   return m_E;
}

inline void DircTruthBarHit::setE(float E) {
   m_E = E;
}

inline int DircTruthBarHit::getBar() const {
   return m_bar;
}

inline void DircTruthBarHit::setBar(int bar) {
   m_bar = bar;
}

inline std::string DircTruthBarHit::getMaxOccurs() const {
   return "unbounded";
}

inline int DircTruthBarHit::getMinOccurs() const {
   return 0;
}

inline int DircTruthBarHit::getPdg() const {
   return m_pdg;
}

inline void DircTruthBarHit::setPdg(int pdg) {
   m_pdg = pdg;
}

inline float DircTruthBarHit::getPx() const {
   return m_px;
}

inline void DircTruthBarHit::setPx(float px) {
   m_px = px;
}

inline float DircTruthBarHit::getPy() const {
   return m_py;
}

inline void DircTruthBarHit::setPy(float py) {
   m_py = py;
}

inline float DircTruthBarHit::getPz() const {
   return m_pz;
}

inline void DircTruthBarHit::setPz(float pz) {
   m_pz = pz;
}

inline float DircTruthBarHit::getT() const {
   return m_t;
}

inline void DircTruthBarHit::setT(float t) {
   m_t = t;
}

inline int DircTruthBarHit::getTrack() const {
   return m_track;
}

inline void DircTruthBarHit::setTrack(int track) {
   m_track = track;
}

inline float DircTruthBarHit::getX() const {
   return m_x;
}

inline void DircTruthBarHit::setX(float x) {
   m_x = x;
}

inline float DircTruthBarHit::getY() const {
   return m_y;
}

inline void DircTruthBarHit::setY(float y) {
   m_y = y;
}

inline float DircTruthBarHit::getZ() const {
   return m_z;
}

inline void DircTruthBarHit::setZ(float z) {
   m_z = z;
}

inline const void *DircTruthBarHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "bar") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_bar;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "pdg") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_pdg;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline DircTruthPmtHitExtra::DircTruthPmtHitExtra(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_bbrefl(0),
   m_path(0),
   m_refl(0),
   m_t_fixed(0)
{}

inline DircTruthPmtHitExtra::~DircTruthPmtHitExtra() {}

inline std::string DircTruthPmtHitExtra::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float DircTruthPmtHitExtra::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string DircTruthPmtHitExtra::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int DircTruthPmtHitExtra::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int DircTruthPmtHitExtra::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float DircTruthPmtHitExtra::getE() const {
   return *(float*)m_parent->getAttribute("E");
}

inline int DircTruthPmtHitExtra::getCh() const {
   return *(int*)m_parent->getAttribute("ch");
}

inline int DircTruthPmtHitExtra::getKey_bar() const {
   return *(int*)m_parent->getAttribute("key_bar");
}

inline float DircTruthPmtHitExtra::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline float DircTruthPmtHitExtra::getX() const {
   return *(float*)m_parent->getAttribute("x");
}

inline float DircTruthPmtHitExtra::getY() const {
   return *(float*)m_parent->getAttribute("y");
}

inline float DircTruthPmtHitExtra::getZ() const {
   return *(float*)m_parent->getAttribute("z");
}

inline bool DircTruthPmtHitExtra::getBbrefl() const {
   return m_bbrefl;
}

inline void DircTruthPmtHitExtra::setBbrefl(bool bbrefl) {
   m_bbrefl = bbrefl;
}

inline std::string DircTruthPmtHitExtra::getMaxOccurs() const {
   return "unbounded";
}

inline int DircTruthPmtHitExtra::getMinOccurs() const {
   return 0;
}

inline int64_t DircTruthPmtHitExtra::getPath() const {
   return m_path;
}

inline void DircTruthPmtHitExtra::setPath(int64_t path) {
   m_path = path;
}

inline int DircTruthPmtHitExtra::getRefl() const {
   return m_refl;
}

inline void DircTruthPmtHitExtra::setRefl(int refl) {
   m_refl = refl;
}

inline float DircTruthPmtHitExtra::getT_fixed() const {
   return m_t_fixed;
}

inline void DircTruthPmtHitExtra::setT_fixed(float t_fixed) {
   m_t_fixed = t_fixed;
}

inline const void *DircTruthPmtHitExtra::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "bbrefl") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_bbrefl;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "path") {
      if (atype != 0)
         *atype = k_hddm_long;
      return &m_path;
   }
   if (name == "refl") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_refl;
   }
   if (name == "t_fixed") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t_fixed;
   }
   return m_parent->getAttribute(name, atype);
}

inline DircTruthPmtHit::DircTruthPmtHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_ch(0),
   m_key_bar(0),
   m_t(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_dircTruthPmtHitExtra_list(&m_host->m_dircTruthPmtHitExtra_plist,
               m_host->m_dircTruthPmtHitExtra_plist.end(),
               m_host->m_dircTruthPmtHitExtra_plist.end(),
               this)
{}

inline DircTruthPmtHit::~DircTruthPmtHit() {
   deleteDircTruthPmtHitExtras();
}

inline std::string DircTruthPmtHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float DircTruthPmtHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string DircTruthPmtHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int DircTruthPmtHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int DircTruthPmtHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float DircTruthPmtHit::getE() const {
   return m_E;
}

inline void DircTruthPmtHit::setE(float E) {
   m_E = E;
}

inline int DircTruthPmtHit::getCh() const {
   return m_ch;
}

inline void DircTruthPmtHit::setCh(int ch) {
   m_ch = ch;
}

inline int DircTruthPmtHit::getKey_bar() const {
   return m_key_bar;
}

inline void DircTruthPmtHit::setKey_bar(int key_bar) {
   m_key_bar = key_bar;
}

inline std::string DircTruthPmtHit::getMaxOccurs() const {
   return "unbounded";
}

inline int DircTruthPmtHit::getMinOccurs() const {
   return 0;
}

inline float DircTruthPmtHit::getT() const {
   return m_t;
}

inline void DircTruthPmtHit::setT(float t) {
   m_t = t;
}

inline float DircTruthPmtHit::getX() const {
   return m_x;
}

inline void DircTruthPmtHit::setX(float x) {
   m_x = x;
}

inline float DircTruthPmtHit::getY() const {
   return m_y;
}

inline void DircTruthPmtHit::setY(float y) {
   m_y = y;
}

inline float DircTruthPmtHit::getZ() const {
   return m_z;
}

inline void DircTruthPmtHit::setZ(float z) {
   m_z = z;
}

inline const void *DircTruthPmtHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "ch") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ch;
   }
   if (name == "key_bar") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_key_bar;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline DircTruthPmtHitExtra &DircTruthPmtHit::getDircTruthPmtHitExtra(int index) {
   return m_dircTruthPmtHitExtra_list(index);
}

inline DircTruthPmtHitExtraList &DircTruthPmtHit::getDircTruthPmtHitExtras() {
   return m_dircTruthPmtHitExtra_list;
}

inline DircTruthPmtHitExtraList DircTruthPmtHit::addDircTruthPmtHitExtras(int count, int start) {
   return m_dircTruthPmtHitExtra_list.add(count,start);
}

inline void DircTruthPmtHit::deleteDircTruthPmtHitExtras(int count, int start) {
   m_dircTruthPmtHitExtra_list.del(count,start);
}

inline DircPmtHit::DircPmtHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_ch(0),
   m_t(0)
{}

inline DircPmtHit::~DircPmtHit() {}

inline std::string DircPmtHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float DircPmtHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string DircPmtHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int DircPmtHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int DircPmtHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int DircPmtHit::getCh() const {
   return m_ch;
}

inline void DircPmtHit::setCh(int ch) {
   m_ch = ch;
}

inline std::string DircPmtHit::getMaxOccurs() const {
   return "unbounded";
}

inline int DircPmtHit::getMinOccurs() const {
   return 0;
}

inline float DircPmtHit::getT() const {
   return m_t;
}

inline void DircPmtHit::setT(float t) {
   m_t = t;
}

inline const void *DircPmtHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "ch") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ch;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline DIRC::DIRC(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dircTruthBarHit_list(&m_host->m_dircTruthBarHit_plist,
               m_host->m_dircTruthBarHit_plist.end(),
               m_host->m_dircTruthBarHit_plist.end(),
               this),
   m_dircTruthPmtHit_list(&m_host->m_dircTruthPmtHit_plist,
               m_host->m_dircTruthPmtHit_plist.end(),
               m_host->m_dircTruthPmtHit_plist.end(),
               this),
   m_dircPmtHit_list(&m_host->m_dircPmtHit_plist,
               m_host->m_dircPmtHit_plist.end(),
               m_host->m_dircPmtHit_plist.end(),
               this)
{}

inline DIRC::~DIRC() {
   deleteDircTruthBarHits();
   deleteDircTruthPmtHits();
   deleteDircPmtHits();
}

inline std::string DIRC::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float DIRC::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string DIRC::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int DIRC::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string DIRC::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int DIRC::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int DIRC::getMinOccurs() const {
   return 0;
}

inline const void *DIRC::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline DircTruthBarHit &DIRC::getDircTruthBarHit(int index) {
   return m_dircTruthBarHit_list(index);
}

inline DircTruthBarHitList &DIRC::getDircTruthBarHits() {
   return m_dircTruthBarHit_list;
}

inline DircTruthBarHitList DIRC::addDircTruthBarHits(int count, int start) {
   return m_dircTruthBarHit_list.add(count,start);
}

inline void DIRC::deleteDircTruthBarHits(int count, int start) {
   m_dircTruthBarHit_list.del(count,start);
}

inline DircTruthPmtHit &DIRC::getDircTruthPmtHit(int index) {
   return m_dircTruthPmtHit_list(index);
}

inline DircTruthPmtHitList &DIRC::getDircTruthPmtHits() {
   return m_dircTruthPmtHit_list;
}

inline DircTruthPmtHitList DIRC::addDircTruthPmtHits(int count, int start) {
   return m_dircTruthPmtHit_list.add(count,start);
}

inline void DIRC::deleteDircTruthPmtHits(int count, int start) {
   m_dircTruthPmtHit_list.del(count,start);
}

inline DircPmtHit &DIRC::getDircPmtHit(int index) {
   return m_dircPmtHit_list(index);
}

inline DircPmtHitList &DIRC::getDircPmtHits() {
   return m_dircPmtHit_list;
}

inline DircPmtHitList DIRC::addDircPmtHits(int count, int start) {
   return m_dircPmtHit_list.add(count,start);
}

inline void DIRC::deleteDircPmtHits(int count, int start) {
   m_dircPmtHit_list.del(count,start);
}

inline FtofDigihit::FtofDigihit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_peakAmp(0)
{}

inline FtofDigihit::~FtofDigihit() {}

inline std::string FtofDigihit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FtofDigihit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FtofDigihit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FtofDigihit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string FtofDigihit::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int FtofDigihit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FtofDigihit::getBar() const {
   return *(int*)m_parent->getAttribute("bar");
}

inline int FtofDigihit::getPlane() const {
   return *(int*)m_parent->getAttribute("plane");
}

inline float FtofDigihit::getDE() const {
   return *(float*)m_parent->getAttribute("dE");
}

inline int FtofDigihit::getEnd() const {
   return *(int*)m_parent->getAttribute("end");
}

inline float FtofDigihit::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline int FtofDigihit::getMinOccurs() const {
   return 0;
}

inline float FtofDigihit::getPeakAmp() const {
   return m_peakAmp;
}

inline void FtofDigihit::setPeakAmp(float peakAmp) {
   m_peakAmp = peakAmp;
}

inline const void *FtofDigihit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "peakAmp") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_peakAmp;
   }
   return m_parent->getAttribute(name, atype);
}

inline FtofHit::FtofHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_end(0),
   m_t(0),
   m_ftofDigihit_link(&m_host->m_ftofDigihit_plist,
               m_host->m_ftofDigihit_plist.end(),
               m_host->m_ftofDigihit_plist.end(),
               this)
{}

inline FtofHit::~FtofHit() {
   deleteFtofDigihits();
}

inline std::string FtofHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FtofHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FtofHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FtofHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FtofHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FtofHit::getBar() const {
   return *(int*)m_parent->getAttribute("bar");
}

inline int FtofHit::getPlane() const {
   return *(int*)m_parent->getAttribute("plane");
}

inline float FtofHit::getDE() const {
   return m_dE;
}

inline void FtofHit::setDE(float dE) {
   m_dE = dE;
}

inline int FtofHit::getEnd() const {
   return m_end;
}

inline void FtofHit::setEnd(int end) {
   m_end = end;
}

inline std::string FtofHit::getMaxOccurs() const {
   return "unbounded";
}

inline int FtofHit::getMinOccurs() const {
   return 0;
}

inline float FtofHit::getT() const {
   return m_t;
}

inline void FtofHit::setT(float t) {
   m_t = t;
}

inline const void *FtofHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FtofDigihit &FtofHit::getFtofDigihit() {
   return m_ftofDigihit_link.front();
}

inline FtofDigihitList &FtofHit::getFtofDigihits() {
   return m_ftofDigihit_link;
}

inline FtofDigihitList FtofHit::addFtofDigihits(int count, int start) {
   return m_ftofDigihit_link.add(count,start);
}

inline void FtofHit::deleteFtofDigihits(int count, int start) {
   m_ftofDigihit_link.del(count,start);
}

inline FtofTruthExtra::FtofTruthExtra(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_dist(0),
   m_itrack(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_x(0),
   m_y(0),
   m_z(0)
{}

inline FtofTruthExtra::~FtofTruthExtra() {}

inline std::string FtofTruthExtra::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FtofTruthExtra::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FtofTruthExtra::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FtofTruthExtra::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FtofTruthExtra::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FtofTruthExtra::getBar() const {
   return *(int*)m_parent->getAttribute("bar");
}

inline int FtofTruthExtra::getPlane() const {
   return *(int*)m_parent->getAttribute("plane");
}

inline float FtofTruthExtra::getDE() const {
   return *(float*)m_parent->getAttribute("dE");
}

inline int FtofTruthExtra::getEnd() const {
   return *(int*)m_parent->getAttribute("end");
}

inline float FtofTruthExtra::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline float FtofTruthExtra::getE() const {
   return m_E;
}

inline void FtofTruthExtra::setE(float E) {
   m_E = E;
}

inline float FtofTruthExtra::getDist() const {
   return m_dist;
}

inline void FtofTruthExtra::setDist(float dist) {
   m_dist = dist;
}

inline int FtofTruthExtra::getItrack() const {
   return m_itrack;
}

inline void FtofTruthExtra::setItrack(int itrack) {
   m_itrack = itrack;
}

inline std::string FtofTruthExtra::getMaxOccurs() const {
   return "unbounded";
}

inline int FtofTruthExtra::getMinOccurs() const {
   return 0;
}

inline int FtofTruthExtra::getPtype() const {
   return m_ptype;
}

inline void FtofTruthExtra::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float FtofTruthExtra::getPx() const {
   return m_px;
}

inline void FtofTruthExtra::setPx(float px) {
   m_px = px;
}

inline float FtofTruthExtra::getPy() const {
   return m_py;
}

inline void FtofTruthExtra::setPy(float py) {
   m_py = py;
}

inline float FtofTruthExtra::getPz() const {
   return m_pz;
}

inline void FtofTruthExtra::setPz(float pz) {
   m_pz = pz;
}

inline float FtofTruthExtra::getX() const {
   return m_x;
}

inline void FtofTruthExtra::setX(float x) {
   m_x = x;
}

inline float FtofTruthExtra::getY() const {
   return m_y;
}

inline void FtofTruthExtra::setY(float y) {
   m_y = y;
}

inline float FtofTruthExtra::getZ() const {
   return m_z;
}

inline void FtofTruthExtra::setZ(float z) {
   m_z = z;
}

inline const void *FtofTruthExtra::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "dist") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dist;
   }
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline FtofTruthHit::FtofTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_end(0),
   m_t(0),
   m_ftofTruthExtra_list(&m_host->m_ftofTruthExtra_plist,
               m_host->m_ftofTruthExtra_plist.end(),
               m_host->m_ftofTruthExtra_plist.end(),
               this)
{}

inline FtofTruthHit::~FtofTruthHit() {
   deleteFtofTruthExtras();
}

inline std::string FtofTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FtofTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FtofTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FtofTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FtofTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FtofTruthHit::getBar() const {
   return *(int*)m_parent->getAttribute("bar");
}

inline int FtofTruthHit::getPlane() const {
   return *(int*)m_parent->getAttribute("plane");
}

inline float FtofTruthHit::getDE() const {
   return m_dE;
}

inline void FtofTruthHit::setDE(float dE) {
   m_dE = dE;
}

inline int FtofTruthHit::getEnd() const {
   return m_end;
}

inline void FtofTruthHit::setEnd(int end) {
   m_end = end;
}

inline std::string FtofTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int FtofTruthHit::getMinOccurs() const {
   return 0;
}

inline float FtofTruthHit::getT() const {
   return m_t;
}

inline void FtofTruthHit::setT(float t) {
   m_t = t;
}

inline const void *FtofTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FtofTruthExtra &FtofTruthHit::getFtofTruthExtra(int index) {
   return m_ftofTruthExtra_list(index);
}

inline FtofTruthExtraList &FtofTruthHit::getFtofTruthExtras() {
   return m_ftofTruthExtra_list;
}

inline FtofTruthExtraList FtofTruthHit::addFtofTruthExtras(int count, int start) {
   return m_ftofTruthExtra_list.add(count,start);
}

inline void FtofTruthHit::deleteFtofTruthExtras(int count, int start) {
   m_ftofTruthExtra_list.del(count,start);
}

inline FtofCounter::FtofCounter(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_bar(0),
   m_plane(0),
   m_ftofHit_list(&m_host->m_ftofHit_plist,
               m_host->m_ftofHit_plist.end(),
               m_host->m_ftofHit_plist.end(),
               this),
   m_ftofTruthHit_list(&m_host->m_ftofTruthHit_plist,
               m_host->m_ftofTruthHit_plist.end(),
               m_host->m_ftofTruthHit_plist.end(),
               this)
{}

inline FtofCounter::~FtofCounter() {
   deleteFtofHits();
   deleteFtofTruthHits();
}

inline std::string FtofCounter::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FtofCounter::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FtofCounter::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FtofCounter::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FtofCounter::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FtofCounter::getBar() const {
   return m_bar;
}

inline void FtofCounter::setBar(int bar) {
   m_bar = bar;
}

inline std::string FtofCounter::getMaxOccurs() const {
   return "unbounded";
}

inline int FtofCounter::getMinOccurs() const {
   return 0;
}

inline int FtofCounter::getPlane() const {
   return m_plane;
}

inline void FtofCounter::setPlane(int plane) {
   m_plane = plane;
}

inline const void *FtofCounter::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "bar") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_bar;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "plane") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_plane;
   }
   return m_parent->getAttribute(name, atype);
}

inline FtofHit &FtofCounter::getFtofHit(int index) {
   return m_ftofHit_list(index);
}

inline FtofHitList &FtofCounter::getFtofHits() {
   return m_ftofHit_list;
}

inline FtofHitList FtofCounter::addFtofHits(int count, int start) {
   return m_ftofHit_list.add(count,start);
}

inline void FtofCounter::deleteFtofHits(int count, int start) {
   m_ftofHit_list.del(count,start);
}

inline FtofTruthHit &FtofCounter::getFtofTruthHit(int index) {
   return m_ftofTruthHit_list(index);
}

inline FtofTruthHitList &FtofCounter::getFtofTruthHits() {
   return m_ftofTruthHit_list;
}

inline FtofTruthHitList FtofCounter::addFtofTruthHits(int count, int start) {
   return m_ftofTruthHit_list.add(count,start);
}

inline void FtofCounter::deleteFtofTruthHits(int count, int start) {
   m_ftofTruthHit_list.del(count,start);
}

inline FtofTruthPoint::FtofTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline FtofTruthPoint::~FtofTruthPoint() {
   deleteTrackIDs();
}

inline std::string FtofTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FtofTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FtofTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FtofTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FtofTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float FtofTruthPoint::getE() const {
   return m_E;
}

inline void FtofTruthPoint::setE(float E) {
   m_E = E;
}

inline std::string FtofTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int FtofTruthPoint::getMinOccurs() const {
   return 0;
}

inline bool FtofTruthPoint::getPrimary() const {
   return m_primary;
}

inline void FtofTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int FtofTruthPoint::getPtype() const {
   return m_ptype;
}

inline void FtofTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float FtofTruthPoint::getPx() const {
   return m_px;
}

inline void FtofTruthPoint::setPx(float px) {
   m_px = px;
}

inline float FtofTruthPoint::getPy() const {
   return m_py;
}

inline void FtofTruthPoint::setPy(float py) {
   m_py = py;
}

inline float FtofTruthPoint::getPz() const {
   return m_pz;
}

inline void FtofTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float FtofTruthPoint::getT() const {
   return m_t;
}

inline void FtofTruthPoint::setT(float t) {
   m_t = t;
}

inline int FtofTruthPoint::getTrack() const {
   return m_track;
}

inline void FtofTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float FtofTruthPoint::getX() const {
   return m_x;
}

inline void FtofTruthPoint::setX(float x) {
   m_x = x;
}

inline float FtofTruthPoint::getY() const {
   return m_y;
}

inline void FtofTruthPoint::setY(float y) {
   m_y = y;
}

inline float FtofTruthPoint::getZ() const {
   return m_z;
}

inline void FtofTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *FtofTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &FtofTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &FtofTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList FtofTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void FtofTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline ForwardTOF::ForwardTOF(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_ftofCounter_list(&m_host->m_ftofCounter_plist,
               m_host->m_ftofCounter_plist.end(),
               m_host->m_ftofCounter_plist.end(),
               this),
   m_ftofTruthPoint_list(&m_host->m_ftofTruthPoint_plist,
               m_host->m_ftofTruthPoint_plist.end(),
               m_host->m_ftofTruthPoint_plist.end(),
               this)
{}

inline ForwardTOF::~ForwardTOF() {
   deleteFtofCounters();
   deleteFtofTruthPoints();
}

inline std::string ForwardTOF::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float ForwardTOF::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string ForwardTOF::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int ForwardTOF::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string ForwardTOF::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int ForwardTOF::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int ForwardTOF::getMinOccurs() const {
   return 0;
}

inline const void *ForwardTOF::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline FtofCounter &ForwardTOF::getFtofCounter(int index) {
   return m_ftofCounter_list(index);
}

inline FtofCounterList &ForwardTOF::getFtofCounters() {
   return m_ftofCounter_list;
}

inline FtofCounterList ForwardTOF::addFtofCounters(int count, int start) {
   return m_ftofCounter_list.add(count,start);
}

inline void ForwardTOF::deleteFtofCounters(int count, int start) {
   m_ftofCounter_list.del(count,start);
}

inline FtofTruthPoint &ForwardTOF::getFtofTruthPoint(int index) {
   return m_ftofTruthPoint_list(index);
}

inline FtofTruthPointList &ForwardTOF::getFtofTruthPoints() {
   return m_ftofTruthPoint_list;
}

inline FtofTruthPointList ForwardTOF::addFtofTruthPoints(int count, int start) {
   return m_ftofTruthPoint_list.add(count,start);
}

inline void ForwardTOF::deleteFtofTruthPoints(int count, int start) {
   m_ftofTruthPoint_list.del(count,start);
}

inline FcalDigihit::FcalDigihit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_integralOverPeak(0)
{}

inline FcalDigihit::~FcalDigihit() {}

inline std::string FcalDigihit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FcalDigihit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FcalDigihit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FcalDigihit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string FcalDigihit::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int FcalDigihit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FcalDigihit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int FcalDigihit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float FcalDigihit::getE() const {
   return *(float*)m_parent->getAttribute("E");
}

inline float FcalDigihit::getT() const {
   return *(float*)m_parent->getAttribute("t");
}

inline float FcalDigihit::getIntegralOverPeak() const {
   return m_integralOverPeak;
}

inline void FcalDigihit::setIntegralOverPeak(float integralOverPeak) {
   m_integralOverPeak = integralOverPeak;
}

inline int FcalDigihit::getMinOccurs() const {
   return 0;
}

inline const void *FcalDigihit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "integralOverPeak") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_integralOverPeak;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline FcalHit::FcalHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_t(0),
   m_fcalDigihit_link(&m_host->m_fcalDigihit_plist,
               m_host->m_fcalDigihit_plist.end(),
               m_host->m_fcalDigihit_plist.end(),
               this)
{}

inline FcalHit::~FcalHit() {
   deleteFcalDigihits();
}

inline std::string FcalHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FcalHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FcalHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FcalHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FcalHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FcalHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FcalHit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int FcalHit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float FcalHit::getE() const {
   return m_E;
}

inline void FcalHit::setE(float E) {
   m_E = E;
}

inline std::string FcalHit::getMaxOccurs() const {
   return "unbounded";
}

inline float FcalHit::getT() const {
   return m_t;
}

inline void FcalHit::setT(float t) {
   m_t = t;
}

inline const void *FcalHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FcalDigihit &FcalHit::getFcalDigihit() {
   return m_fcalDigihit_link.front();
}

inline FcalDigihitList &FcalHit::getFcalDigihits() {
   return m_fcalDigihit_link;
}

inline FcalDigihitList FcalHit::addFcalDigihits(int count, int start) {
   return m_fcalDigihit_link.add(count,start);
}

inline void FcalHit::deleteFcalDigihits(int count, int start) {
   m_fcalDigihit_link.del(count,start);
}

inline FcalTruthLightGuide::FcalTruthLightGuide(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_t(0)
{}

inline FcalTruthLightGuide::~FcalTruthLightGuide() {}

inline std::string FcalTruthLightGuide::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FcalTruthLightGuide::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FcalTruthLightGuide::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FcalTruthLightGuide::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FcalTruthLightGuide::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FcalTruthLightGuide::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FcalTruthLightGuide::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int FcalTruthLightGuide::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float FcalTruthLightGuide::getE() const {
   return *(float*)m_parent->getAttribute("E");
}

inline float FcalTruthLightGuide::getDE() const {
   return m_dE;
}

inline void FcalTruthLightGuide::setDE(float dE) {
   m_dE = dE;
}

inline std::string FcalTruthLightGuide::getMaxOccurs() const {
   return "unbounded";
}

inline float FcalTruthLightGuide::getT() const {
   return m_t;
}

inline void FcalTruthLightGuide::setT(float t) {
   m_t = t;
}

inline const void *FcalTruthLightGuide::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FcalTruthHit::FcalTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_t(0),
   m_fcalTruthLightGuide_list(&m_host->m_fcalTruthLightGuide_plist,
               m_host->m_fcalTruthLightGuide_plist.end(),
               m_host->m_fcalTruthLightGuide_plist.end(),
               this)
{}

inline FcalTruthHit::~FcalTruthHit() {
   deleteFcalTruthLightGuides();
}

inline std::string FcalTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FcalTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FcalTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FcalTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FcalTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FcalTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FcalTruthHit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int FcalTruthHit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float FcalTruthHit::getE() const {
   return m_E;
}

inline void FcalTruthHit::setE(float E) {
   m_E = E;
}

inline std::string FcalTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline float FcalTruthHit::getT() const {
   return m_t;
}

inline void FcalTruthHit::setT(float t) {
   m_t = t;
}

inline const void *FcalTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FcalTruthLightGuide &FcalTruthHit::getFcalTruthLightGuide(int index) {
   return m_fcalTruthLightGuide_list(index);
}

inline FcalTruthLightGuideList &FcalTruthHit::getFcalTruthLightGuides() {
   return m_fcalTruthLightGuide_list;
}

inline FcalTruthLightGuideList FcalTruthHit::addFcalTruthLightGuides(int count, int start) {
   return m_fcalTruthLightGuide_list.add(count,start);
}

inline void FcalTruthHit::deleteFcalTruthLightGuides(int count, int start) {
   m_fcalTruthLightGuide_list.del(count,start);
}

inline FcalBlock::FcalBlock(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_column(0),
   m_row(0),
   m_fcalHit_list(&m_host->m_fcalHit_plist,
               m_host->m_fcalHit_plist.end(),
               m_host->m_fcalHit_plist.end(),
               this),
   m_fcalTruthHit_list(&m_host->m_fcalTruthHit_plist,
               m_host->m_fcalTruthHit_plist.end(),
               m_host->m_fcalTruthHit_plist.end(),
               this)
{}

inline FcalBlock::~FcalBlock() {
   deleteFcalHits();
   deleteFcalTruthHits();
}

inline std::string FcalBlock::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FcalBlock::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FcalBlock::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FcalBlock::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FcalBlock::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FcalBlock::getColumn() const {
   return m_column;
}

inline void FcalBlock::setColumn(int column) {
   m_column = column;
}

inline std::string FcalBlock::getMaxOccurs() const {
   return "unbounded";
}

inline int FcalBlock::getMinOccurs() const {
   return 0;
}

inline int FcalBlock::getRow() const {
   return m_row;
}

inline void FcalBlock::setRow(int row) {
   m_row = row;
}

inline const void *FcalBlock::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "column") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_column;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "row") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_row;
   }
   return m_parent->getAttribute(name, atype);
}

inline FcalHit &FcalBlock::getFcalHit(int index) {
   return m_fcalHit_list(index);
}

inline FcalHitList &FcalBlock::getFcalHits() {
   return m_fcalHit_list;
}

inline FcalHitList FcalBlock::addFcalHits(int count, int start) {
   return m_fcalHit_list.add(count,start);
}

inline void FcalBlock::deleteFcalHits(int count, int start) {
   m_fcalHit_list.del(count,start);
}

inline FcalTruthHit &FcalBlock::getFcalTruthHit(int index) {
   return m_fcalTruthHit_list(index);
}

inline FcalTruthHitList &FcalBlock::getFcalTruthHits() {
   return m_fcalTruthHit_list;
}

inline FcalTruthHitList FcalBlock::addFcalTruthHits(int count, int start) {
   return m_fcalTruthHit_list.add(count,start);
}

inline void FcalBlock::deleteFcalTruthHits(int count, int start) {
   m_fcalTruthHit_list.del(count,start);
}

inline FcalTruthShower::FcalTruthShower(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline FcalTruthShower::~FcalTruthShower() {
   deleteTrackIDs();
}

inline std::string FcalTruthShower::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FcalTruthShower::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FcalTruthShower::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FcalTruthShower::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FcalTruthShower::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float FcalTruthShower::getE() const {
   return m_E;
}

inline void FcalTruthShower::setE(float E) {
   m_E = E;
}

inline std::string FcalTruthShower::getMaxOccurs() const {
   return "unbounded";
}

inline int FcalTruthShower::getMinOccurs() const {
   return 0;
}

inline bool FcalTruthShower::getPrimary() const {
   return m_primary;
}

inline void FcalTruthShower::setPrimary(bool primary) {
   m_primary = primary;
}

inline int FcalTruthShower::getPtype() const {
   return m_ptype;
}

inline void FcalTruthShower::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float FcalTruthShower::getPx() const {
   return m_px;
}

inline void FcalTruthShower::setPx(float px) {
   m_px = px;
}

inline float FcalTruthShower::getPy() const {
   return m_py;
}

inline void FcalTruthShower::setPy(float py) {
   m_py = py;
}

inline float FcalTruthShower::getPz() const {
   return m_pz;
}

inline void FcalTruthShower::setPz(float pz) {
   m_pz = pz;
}

inline float FcalTruthShower::getT() const {
   return m_t;
}

inline void FcalTruthShower::setT(float t) {
   m_t = t;
}

inline int FcalTruthShower::getTrack() const {
   return m_track;
}

inline void FcalTruthShower::setTrack(int track) {
   m_track = track;
}

inline float FcalTruthShower::getX() const {
   return m_x;
}

inline void FcalTruthShower::setX(float x) {
   m_x = x;
}

inline float FcalTruthShower::getY() const {
   return m_y;
}

inline void FcalTruthShower::setY(float y) {
   m_y = y;
}

inline float FcalTruthShower::getZ() const {
   return m_z;
}

inline void FcalTruthShower::setZ(float z) {
   m_z = z;
}

inline const void *FcalTruthShower::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &FcalTruthShower::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &FcalTruthShower::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList FcalTruthShower::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void FcalTruthShower::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline ForwardEMcal::ForwardEMcal(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_fcalBlock_list(&m_host->m_fcalBlock_plist,
               m_host->m_fcalBlock_plist.end(),
               m_host->m_fcalBlock_plist.end(),
               this),
   m_fcalTruthShower_list(&m_host->m_fcalTruthShower_plist,
               m_host->m_fcalTruthShower_plist.end(),
               m_host->m_fcalTruthShower_plist.end(),
               this)
{}

inline ForwardEMcal::~ForwardEMcal() {
   deleteFcalBlocks();
   deleteFcalTruthShowers();
}

inline std::string ForwardEMcal::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float ForwardEMcal::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string ForwardEMcal::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int ForwardEMcal::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string ForwardEMcal::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int ForwardEMcal::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int ForwardEMcal::getMinOccurs() const {
   return 0;
}

inline const void *ForwardEMcal::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline FcalBlock &ForwardEMcal::getFcalBlock(int index) {
   return m_fcalBlock_list(index);
}

inline FcalBlockList &ForwardEMcal::getFcalBlocks() {
   return m_fcalBlock_list;
}

inline FcalBlockList ForwardEMcal::addFcalBlocks(int count, int start) {
   return m_fcalBlock_list.add(count,start);
}

inline void ForwardEMcal::deleteFcalBlocks(int count, int start) {
   m_fcalBlock_list.del(count,start);
}

inline FcalTruthShower &ForwardEMcal::getFcalTruthShower(int index) {
   return m_fcalTruthShower_list(index);
}

inline FcalTruthShowerList &ForwardEMcal::getFcalTruthShowers() {
   return m_fcalTruthShower_list;
}

inline FcalTruthShowerList ForwardEMcal::addFcalTruthShowers(int count, int start) {
   return m_fcalTruthShower_list.add(count,start);
}

inline void ForwardEMcal::deleteFcalTruthShowers(int count, int start) {
   m_fcalTruthShower_list.del(count,start);
}

inline CcalHit::CcalHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_t(0)
{}

inline CcalHit::~CcalHit() {}

inline std::string CcalHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CcalHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CcalHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CcalHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CcalHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CcalHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int CcalHit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int CcalHit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float CcalHit::getE() const {
   return m_E;
}

inline void CcalHit::setE(float E) {
   m_E = E;
}

inline std::string CcalHit::getMaxOccurs() const {
   return "unbounded";
}

inline float CcalHit::getT() const {
   return m_t;
}

inline void CcalHit::setT(float t) {
   m_t = t;
}

inline const void *CcalHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline CcalTruthHit::CcalTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_t(0)
{}

inline CcalTruthHit::~CcalTruthHit() {}

inline std::string CcalTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CcalTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CcalTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CcalTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CcalTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CcalTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int CcalTruthHit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int CcalTruthHit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float CcalTruthHit::getE() const {
   return m_E;
}

inline void CcalTruthHit::setE(float E) {
   m_E = E;
}

inline std::string CcalTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline float CcalTruthHit::getT() const {
   return m_t;
}

inline void CcalTruthHit::setT(float t) {
   m_t = t;
}

inline const void *CcalTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline CcalBlock::CcalBlock(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_column(0),
   m_row(0),
   m_ccalHit_list(&m_host->m_ccalHit_plist,
               m_host->m_ccalHit_plist.end(),
               m_host->m_ccalHit_plist.end(),
               this),
   m_ccalTruthHit_list(&m_host->m_ccalTruthHit_plist,
               m_host->m_ccalTruthHit_plist.end(),
               m_host->m_ccalTruthHit_plist.end(),
               this)
{}

inline CcalBlock::~CcalBlock() {
   deleteCcalHits();
   deleteCcalTruthHits();
}

inline std::string CcalBlock::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CcalBlock::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CcalBlock::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CcalBlock::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CcalBlock::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int CcalBlock::getColumn() const {
   return m_column;
}

inline void CcalBlock::setColumn(int column) {
   m_column = column;
}

inline std::string CcalBlock::getMaxOccurs() const {
   return "unbounded";
}

inline int CcalBlock::getMinOccurs() const {
   return 0;
}

inline int CcalBlock::getRow() const {
   return m_row;
}

inline void CcalBlock::setRow(int row) {
   m_row = row;
}

inline const void *CcalBlock::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "column") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_column;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "row") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_row;
   }
   return m_parent->getAttribute(name, atype);
}

inline CcalHit &CcalBlock::getCcalHit(int index) {
   return m_ccalHit_list(index);
}

inline CcalHitList &CcalBlock::getCcalHits() {
   return m_ccalHit_list;
}

inline CcalHitList CcalBlock::addCcalHits(int count, int start) {
   return m_ccalHit_list.add(count,start);
}

inline void CcalBlock::deleteCcalHits(int count, int start) {
   m_ccalHit_list.del(count,start);
}

inline CcalTruthHit &CcalBlock::getCcalTruthHit(int index) {
   return m_ccalTruthHit_list(index);
}

inline CcalTruthHitList &CcalBlock::getCcalTruthHits() {
   return m_ccalTruthHit_list;
}

inline CcalTruthHitList CcalBlock::addCcalTruthHits(int count, int start) {
   return m_ccalTruthHit_list.add(count,start);
}

inline void CcalBlock::deleteCcalTruthHits(int count, int start) {
   m_ccalTruthHit_list.del(count,start);
}

inline CcalTruthShower::CcalTruthShower(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline CcalTruthShower::~CcalTruthShower() {
   deleteTrackIDs();
}

inline std::string CcalTruthShower::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float CcalTruthShower::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string CcalTruthShower::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int CcalTruthShower::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int CcalTruthShower::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float CcalTruthShower::getE() const {
   return m_E;
}

inline void CcalTruthShower::setE(float E) {
   m_E = E;
}

inline std::string CcalTruthShower::getMaxOccurs() const {
   return "unbounded";
}

inline int CcalTruthShower::getMinOccurs() const {
   return 0;
}

inline bool CcalTruthShower::getPrimary() const {
   return m_primary;
}

inline void CcalTruthShower::setPrimary(bool primary) {
   m_primary = primary;
}

inline int CcalTruthShower::getPtype() const {
   return m_ptype;
}

inline void CcalTruthShower::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float CcalTruthShower::getPx() const {
   return m_px;
}

inline void CcalTruthShower::setPx(float px) {
   m_px = px;
}

inline float CcalTruthShower::getPy() const {
   return m_py;
}

inline void CcalTruthShower::setPy(float py) {
   m_py = py;
}

inline float CcalTruthShower::getPz() const {
   return m_pz;
}

inline void CcalTruthShower::setPz(float pz) {
   m_pz = pz;
}

inline float CcalTruthShower::getT() const {
   return m_t;
}

inline void CcalTruthShower::setT(float t) {
   m_t = t;
}

inline int CcalTruthShower::getTrack() const {
   return m_track;
}

inline void CcalTruthShower::setTrack(int track) {
   m_track = track;
}

inline float CcalTruthShower::getX() const {
   return m_x;
}

inline void CcalTruthShower::setX(float x) {
   m_x = x;
}

inline float CcalTruthShower::getY() const {
   return m_y;
}

inline void CcalTruthShower::setY(float y) {
   m_y = y;
}

inline float CcalTruthShower::getZ() const {
   return m_z;
}

inline void CcalTruthShower::setZ(float z) {
   m_z = z;
}

inline const void *CcalTruthShower::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &CcalTruthShower::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &CcalTruthShower::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList CcalTruthShower::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void CcalTruthShower::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline ComptonEMcal::ComptonEMcal(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_ccalBlock_list(&m_host->m_ccalBlock_plist,
               m_host->m_ccalBlock_plist.end(),
               m_host->m_ccalBlock_plist.end(),
               this),
   m_ccalTruthShower_list(&m_host->m_ccalTruthShower_plist,
               m_host->m_ccalTruthShower_plist.end(),
               m_host->m_ccalTruthShower_plist.end(),
               this)
{}

inline ComptonEMcal::~ComptonEMcal() {
   deleteCcalBlocks();
   deleteCcalTruthShowers();
}

inline std::string ComptonEMcal::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float ComptonEMcal::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string ComptonEMcal::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int ComptonEMcal::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string ComptonEMcal::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int ComptonEMcal::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int ComptonEMcal::getMinOccurs() const {
   return 0;
}

inline const void *ComptonEMcal::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline CcalBlock &ComptonEMcal::getCcalBlock(int index) {
   return m_ccalBlock_list(index);
}

inline CcalBlockList &ComptonEMcal::getCcalBlocks() {
   return m_ccalBlock_list;
}

inline CcalBlockList ComptonEMcal::addCcalBlocks(int count, int start) {
   return m_ccalBlock_list.add(count,start);
}

inline void ComptonEMcal::deleteCcalBlocks(int count, int start) {
   m_ccalBlock_list.del(count,start);
}

inline CcalTruthShower &ComptonEMcal::getCcalTruthShower(int index) {
   return m_ccalTruthShower_list(index);
}

inline CcalTruthShowerList &ComptonEMcal::getCcalTruthShowers() {
   return m_ccalTruthShower_list;
}

inline CcalTruthShowerList ComptonEMcal::addCcalTruthShowers(int count, int start) {
   return m_ccalTruthShower_list.add(count,start);
}

inline void ComptonEMcal::deleteCcalTruthShowers(int count, int start) {
   m_ccalTruthShower_list.del(count,start);
}

inline UpvHit::UpvHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_end(0),
   m_t(0)
{}

inline UpvHit::~UpvHit() {}

inline std::string UpvHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float UpvHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string UpvHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int UpvHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int UpvHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int UpvHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int UpvHit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float UpvHit::getE() const {
   return m_E;
}

inline void UpvHit::setE(float E) {
   m_E = E;
}

inline int UpvHit::getEnd() const {
   return m_end;
}

inline void UpvHit::setEnd(int end) {
   m_end = end;
}

inline std::string UpvHit::getMaxOccurs() const {
   return "unbounded";
}

inline int UpvHit::getMinOccurs() const {
   return 0;
}

inline float UpvHit::getT() const {
   return m_t;
}

inline void UpvHit::setT(float t) {
   m_t = t;
}

inline const void *UpvHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline UpvTruthHit::UpvTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_end(0),
   m_t(0),
   m_xlocal(0)
{}

inline UpvTruthHit::~UpvTruthHit() {}

inline std::string UpvTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float UpvTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string UpvTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int UpvTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int UpvTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int UpvTruthHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int UpvTruthHit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float UpvTruthHit::getE() const {
   return m_E;
}

inline void UpvTruthHit::setE(float E) {
   m_E = E;
}

inline int UpvTruthHit::getEnd() const {
   return m_end;
}

inline void UpvTruthHit::setEnd(int end) {
   m_end = end;
}

inline std::string UpvTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int UpvTruthHit::getMinOccurs() const {
   return 0;
}

inline float UpvTruthHit::getT() const {
   return m_t;
}

inline void UpvTruthHit::setT(float t) {
   m_t = t;
}

inline float UpvTruthHit::getXlocal() const {
   return m_xlocal;
}

inline void UpvTruthHit::setXlocal(float xlocal) {
   m_xlocal = xlocal;
}

inline const void *UpvTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "end") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_end;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "xlocal") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_xlocal;
   }
   return m_parent->getAttribute(name, atype);
}

inline UpvPaddle::UpvPaddle(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_layer(0),
   m_row(0),
   m_upvHit_list(&m_host->m_upvHit_plist,
               m_host->m_upvHit_plist.end(),
               m_host->m_upvHit_plist.end(),
               this),
   m_upvTruthHit_list(&m_host->m_upvTruthHit_plist,
               m_host->m_upvTruthHit_plist.end(),
               m_host->m_upvTruthHit_plist.end(),
               this)
{}

inline UpvPaddle::~UpvPaddle() {
   deleteUpvHits();
   deleteUpvTruthHits();
}

inline std::string UpvPaddle::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float UpvPaddle::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string UpvPaddle::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int UpvPaddle::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int UpvPaddle::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int UpvPaddle::getLayer() const {
   return m_layer;
}

inline void UpvPaddle::setLayer(int layer) {
   m_layer = layer;
}

inline std::string UpvPaddle::getMaxOccurs() const {
   return "unbounded";
}

inline int UpvPaddle::getMinOccurs() const {
   return 0;
}

inline int UpvPaddle::getRow() const {
   return m_row;
}

inline void UpvPaddle::setRow(int row) {
   m_row = row;
}

inline const void *UpvPaddle::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "layer") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_layer;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "row") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_row;
   }
   return m_parent->getAttribute(name, atype);
}

inline UpvHit &UpvPaddle::getUpvHit(int index) {
   return m_upvHit_list(index);
}

inline UpvHitList &UpvPaddle::getUpvHits() {
   return m_upvHit_list;
}

inline UpvHitList UpvPaddle::addUpvHits(int count, int start) {
   return m_upvHit_list.add(count,start);
}

inline void UpvPaddle::deleteUpvHits(int count, int start) {
   m_upvHit_list.del(count,start);
}

inline UpvTruthHit &UpvPaddle::getUpvTruthHit(int index) {
   return m_upvTruthHit_list(index);
}

inline UpvTruthHitList &UpvPaddle::getUpvTruthHits() {
   return m_upvTruthHit_list;
}

inline UpvTruthHitList UpvPaddle::addUpvTruthHits(int count, int start) {
   return m_upvTruthHit_list.add(count,start);
}

inline void UpvPaddle::deleteUpvTruthHits(int count, int start) {
   m_upvTruthHit_list.del(count,start);
}

inline UpvTruthShower::UpvTruthShower(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline UpvTruthShower::~UpvTruthShower() {
   deleteTrackIDs();
}

inline std::string UpvTruthShower::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float UpvTruthShower::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string UpvTruthShower::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int UpvTruthShower::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int UpvTruthShower::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float UpvTruthShower::getE() const {
   return m_E;
}

inline void UpvTruthShower::setE(float E) {
   m_E = E;
}

inline std::string UpvTruthShower::getMaxOccurs() const {
   return "unbounded";
}

inline int UpvTruthShower::getMinOccurs() const {
   return 0;
}

inline bool UpvTruthShower::getPrimary() const {
   return m_primary;
}

inline void UpvTruthShower::setPrimary(bool primary) {
   m_primary = primary;
}

inline int UpvTruthShower::getPtype() const {
   return m_ptype;
}

inline void UpvTruthShower::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float UpvTruthShower::getPx() const {
   return m_px;
}

inline void UpvTruthShower::setPx(float px) {
   m_px = px;
}

inline float UpvTruthShower::getPy() const {
   return m_py;
}

inline void UpvTruthShower::setPy(float py) {
   m_py = py;
}

inline float UpvTruthShower::getPz() const {
   return m_pz;
}

inline void UpvTruthShower::setPz(float pz) {
   m_pz = pz;
}

inline float UpvTruthShower::getT() const {
   return m_t;
}

inline void UpvTruthShower::setT(float t) {
   m_t = t;
}

inline int UpvTruthShower::getTrack() const {
   return m_track;
}

inline void UpvTruthShower::setTrack(int track) {
   m_track = track;
}

inline float UpvTruthShower::getX() const {
   return m_x;
}

inline void UpvTruthShower::setX(float x) {
   m_x = x;
}

inline float UpvTruthShower::getY() const {
   return m_y;
}

inline void UpvTruthShower::setY(float y) {
   m_y = y;
}

inline float UpvTruthShower::getZ() const {
   return m_z;
}

inline void UpvTruthShower::setZ(float z) {
   m_z = z;
}

inline const void *UpvTruthShower::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &UpvTruthShower::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &UpvTruthShower::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList UpvTruthShower::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void UpvTruthShower::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline UpstreamEMveto::UpstreamEMveto(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_upvPaddle_list(&m_host->m_upvPaddle_plist,
               m_host->m_upvPaddle_plist.end(),
               m_host->m_upvPaddle_plist.end(),
               this),
   m_upvTruthShower_list(&m_host->m_upvTruthShower_plist,
               m_host->m_upvTruthShower_plist.end(),
               m_host->m_upvTruthShower_plist.end(),
               this)
{}

inline UpstreamEMveto::~UpstreamEMveto() {
   deleteUpvPaddles();
   deleteUpvTruthShowers();
}

inline std::string UpstreamEMveto::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float UpstreamEMveto::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string UpstreamEMveto::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int UpstreamEMveto::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string UpstreamEMveto::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int UpstreamEMveto::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int UpstreamEMveto::getMinOccurs() const {
   return 0;
}

inline const void *UpstreamEMveto::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline UpvPaddle &UpstreamEMveto::getUpvPaddle(int index) {
   return m_upvPaddle_list(index);
}

inline UpvPaddleList &UpstreamEMveto::getUpvPaddles() {
   return m_upvPaddle_list;
}

inline UpvPaddleList UpstreamEMveto::addUpvPaddles(int count, int start) {
   return m_upvPaddle_list.add(count,start);
}

inline void UpstreamEMveto::deleteUpvPaddles(int count, int start) {
   m_upvPaddle_list.del(count,start);
}

inline UpvTruthShower &UpstreamEMveto::getUpvTruthShower(int index) {
   return m_upvTruthShower_list(index);
}

inline UpvTruthShowerList &UpstreamEMveto::getUpvTruthShowers() {
   return m_upvTruthShower_list;
}

inline UpvTruthShowerList UpstreamEMveto::addUpvTruthShowers(int count, int start) {
   return m_upvTruthShower_list.add(count,start);
}

inline void UpstreamEMveto::deleteUpvTruthShowers(int count, int start) {
   m_upvTruthShower_list.del(count,start);
}

inline TaggerHit::TaggerHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_npe(0),
   m_t(0),
   m_tADC(0)
{}

inline TaggerHit::~TaggerHit() {}

inline std::string TaggerHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TaggerHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TaggerHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TaggerHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int TaggerHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float TaggerHit::getE() const {
   return *(float*)m_parent->getAttribute("E");
}

inline int TaggerHit::getCounterId() const {
   return *(int*)m_parent->getAttribute("counterId");
}

inline int TaggerHit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int TaggerHit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline std::string TaggerHit::getMaxOccurs() const {
   return "unbounded";
}

inline int TaggerHit::getMinOccurs() const {
   return 0;
}

inline int TaggerHit::getNpe() const {
   return m_npe;
}

inline void TaggerHit::setNpe(int npe) {
   m_npe = npe;
}

inline float TaggerHit::getT() const {
   return m_t;
}

inline void TaggerHit::setT(float t) {
   m_t = t;
}

inline float TaggerHit::getTADC() const {
   return m_tADC;
}

inline void TaggerHit::setTADC(float tADC) {
   m_tADC = tADC;
}

inline const void *TaggerHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "npe") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_npe;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "tADC") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_tADC;
   }
   return m_parent->getAttribute(name, atype);
}

inline TaggerTruthHit::TaggerTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_bg(0),
   m_dE(0),
   m_t(0)
{}

inline TaggerTruthHit::~TaggerTruthHit() {}

inline std::string TaggerTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TaggerTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TaggerTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TaggerTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int TaggerTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int TaggerTruthHit::getCounterId() const {
   return *(int*)m_parent->getAttribute("counterId");
}

inline int TaggerTruthHit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline int TaggerTruthHit::getRow() const {
   return *(int*)m_parent->getAttribute("row");
}

inline float TaggerTruthHit::getE() const {
   return m_E;
}

inline void TaggerTruthHit::setE(float E) {
   m_E = E;
}

inline int TaggerTruthHit::getBg() const {
   return m_bg;
}

inline void TaggerTruthHit::setBg(int bg) {
   m_bg = bg;
}

inline float TaggerTruthHit::getDE() const {
   return m_dE;
}

inline void TaggerTruthHit::setDE(float dE) {
   m_dE = dE;
}

inline std::string TaggerTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int TaggerTruthHit::getMinOccurs() const {
   return 0;
}

inline float TaggerTruthHit::getT() const {
   return m_t;
}

inline void TaggerTruthHit::setT(float t) {
   m_t = t;
}

inline const void *TaggerTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "bg") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_bg;
   }
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline MicroChannel::MicroChannel(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_column(0),
   m_row(0),
   m_taggerHit_list(&m_host->m_taggerHit_plist,
               m_host->m_taggerHit_plist.end(),
               m_host->m_taggerHit_plist.end(),
               this),
   m_taggerTruthHit_list(&m_host->m_taggerTruthHit_plist,
               m_host->m_taggerTruthHit_plist.end(),
               m_host->m_taggerTruthHit_plist.end(),
               this)
{}

inline MicroChannel::~MicroChannel() {
   deleteTaggerHits();
   deleteTaggerTruthHits();
}

inline std::string MicroChannel::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float MicroChannel::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string MicroChannel::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int MicroChannel::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int MicroChannel::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float MicroChannel::getE() const {
   return m_E;
}

inline void MicroChannel::setE(float E) {
   m_E = E;
}

inline int MicroChannel::getColumn() const {
   return m_column;
}

inline void MicroChannel::setColumn(int column) {
   m_column = column;
}

inline std::string MicroChannel::getMaxOccurs() const {
   return "unbounded";
}

inline int MicroChannel::getMinOccurs() const {
   return 0;
}

inline int MicroChannel::getRow() const {
   return m_row;
}

inline void MicroChannel::setRow(int row) {
   m_row = row;
}

inline const void *MicroChannel::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "column") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_column;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "row") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_row;
   }
   return m_parent->getAttribute(name, atype);
}

inline TaggerHit &MicroChannel::getTaggerHit(int index) {
   return m_taggerHit_list(index);
}

inline TaggerHitList &MicroChannel::getTaggerHits() {
   return m_taggerHit_list;
}

inline TaggerHitList MicroChannel::addTaggerHits(int count, int start) {
   return m_taggerHit_list.add(count,start);
}

inline void MicroChannel::deleteTaggerHits(int count, int start) {
   m_taggerHit_list.del(count,start);
}

inline TaggerTruthHit &MicroChannel::getTaggerTruthHit(int index) {
   return m_taggerTruthHit_list(index);
}

inline TaggerTruthHitList &MicroChannel::getTaggerTruthHits() {
   return m_taggerTruthHit_list;
}

inline TaggerTruthHitList MicroChannel::addTaggerTruthHits(int count, int start) {
   return m_taggerTruthHit_list.add(count,start);
}

inline void MicroChannel::deleteTaggerTruthHits(int count, int start) {
   m_taggerTruthHit_list.del(count,start);
}

inline HodoChannel::HodoChannel(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_counterId(0),
   m_taggerHit_list(&m_host->m_taggerHit_plist,
               m_host->m_taggerHit_plist.end(),
               m_host->m_taggerHit_plist.end(),
               this),
   m_taggerTruthHit_list(&m_host->m_taggerTruthHit_plist,
               m_host->m_taggerTruthHit_plist.end(),
               m_host->m_taggerTruthHit_plist.end(),
               this)
{}

inline HodoChannel::~HodoChannel() {
   deleteTaggerHits();
   deleteTaggerTruthHits();
}

inline std::string HodoChannel::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float HodoChannel::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string HodoChannel::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int HodoChannel::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int HodoChannel::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float HodoChannel::getE() const {
   return m_E;
}

inline void HodoChannel::setE(float E) {
   m_E = E;
}

inline int HodoChannel::getCounterId() const {
   return m_counterId;
}

inline void HodoChannel::setCounterId(int counterId) {
   m_counterId = counterId;
}

inline std::string HodoChannel::getMaxOccurs() const {
   return "unbounded";
}

inline int HodoChannel::getMinOccurs() const {
   return 0;
}

inline const void *HodoChannel::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "counterId") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_counterId;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline TaggerHit &HodoChannel::getTaggerHit(int index) {
   return m_taggerHit_list(index);
}

inline TaggerHitList &HodoChannel::getTaggerHits() {
   return m_taggerHit_list;
}

inline TaggerHitList HodoChannel::addTaggerHits(int count, int start) {
   return m_taggerHit_list.add(count,start);
}

inline void HodoChannel::deleteTaggerHits(int count, int start) {
   m_taggerHit_list.del(count,start);
}

inline TaggerTruthHit &HodoChannel::getTaggerTruthHit(int index) {
   return m_taggerTruthHit_list(index);
}

inline TaggerTruthHitList &HodoChannel::getTaggerTruthHits() {
   return m_taggerTruthHit_list;
}

inline TaggerTruthHitList HodoChannel::addTaggerTruthHits(int count, int start) {
   return m_taggerTruthHit_list.add(count,start);
}

inline void HodoChannel::deleteTaggerTruthHits(int count, int start) {
   m_taggerTruthHit_list.del(count,start);
}

inline Tagger::Tagger(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_microChannel_list(&m_host->m_microChannel_plist,
               m_host->m_microChannel_plist.end(),
               m_host->m_microChannel_plist.end(),
               this),
   m_hodoChannel_list(&m_host->m_hodoChannel_plist,
               m_host->m_hodoChannel_plist.end(),
               m_host->m_hodoChannel_plist.end(),
               this)
{}

inline Tagger::~Tagger() {
   deleteMicroChannels();
   deleteHodoChannels();
}

inline std::string Tagger::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Tagger::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Tagger::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Tagger::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string Tagger::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int Tagger::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int Tagger::getMinOccurs() const {
   return 0;
}

inline const void *Tagger::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline MicroChannel &Tagger::getMicroChannel(int index) {
   return m_microChannel_list(index);
}

inline MicroChannelList &Tagger::getMicroChannels() {
   return m_microChannel_list;
}

inline MicroChannelList Tagger::addMicroChannels(int count, int start) {
   return m_microChannel_list.add(count,start);
}

inline void Tagger::deleteMicroChannels(int count, int start) {
   m_microChannel_list.del(count,start);
}

inline HodoChannel &Tagger::getHodoChannel(int index) {
   return m_hodoChannel_list(index);
}

inline HodoChannelList &Tagger::getHodoChannels() {
   return m_hodoChannel_list;
}

inline HodoChannelList Tagger::addHodoChannels(int count, int start) {
   return m_hodoChannel_list.add(count,start);
}

inline void Tagger::deleteHodoChannels(int count, int start) {
   m_hodoChannel_list.del(count,start);
}

inline PsHit::PsHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_t(0)
{}

inline PsHit::~PsHit() {}

inline std::string PsHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PsHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PsHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PsHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int PsHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int PsHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int PsHit::getArm() const {
   return *(int*)m_parent->getAttribute("arm");
}

inline int PsHit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline float PsHit::getDE() const {
   return m_dE;
}

inline void PsHit::setDE(float dE) {
   m_dE = dE;
}

inline std::string PsHit::getMaxOccurs() const {
   return "unbounded";
}

inline float PsHit::getT() const {
   return m_t;
}

inline void PsHit::setT(float t) {
   m_t = t;
}

inline const void *PsHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline PsTruthHit::PsTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_itrack(0),
   m_ptype(0),
   m_t(0)
{}

inline PsTruthHit::~PsTruthHit() {}

inline std::string PsTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PsTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PsTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PsTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int PsTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int PsTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int PsTruthHit::getArm() const {
   return *(int*)m_parent->getAttribute("arm");
}

inline int PsTruthHit::getColumn() const {
   return *(int*)m_parent->getAttribute("column");
}

inline float PsTruthHit::getDE() const {
   return m_dE;
}

inline void PsTruthHit::setDE(float dE) {
   m_dE = dE;
}

inline int PsTruthHit::getItrack() const {
   return m_itrack;
}

inline void PsTruthHit::setItrack(int itrack) {
   m_itrack = itrack;
}

inline std::string PsTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int PsTruthHit::getPtype() const {
   return m_ptype;
}

inline void PsTruthHit::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float PsTruthHit::getT() const {
   return m_t;
}

inline void PsTruthHit::setT(float t) {
   m_t = t;
}

inline const void *PsTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline PsTile::PsTile(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_arm(0),
   m_column(0),
   m_psHit_list(&m_host->m_psHit_plist,
               m_host->m_psHit_plist.end(),
               m_host->m_psHit_plist.end(),
               this),
   m_psTruthHit_list(&m_host->m_psTruthHit_plist,
               m_host->m_psTruthHit_plist.end(),
               m_host->m_psTruthHit_plist.end(),
               this)
{}

inline PsTile::~PsTile() {
   deletePsHits();
   deletePsTruthHits();
}

inline std::string PsTile::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PsTile::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PsTile::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PsTile::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int PsTile::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int PsTile::getArm() const {
   return m_arm;
}

inline void PsTile::setArm(int arm) {
   m_arm = arm;
}

inline int PsTile::getColumn() const {
   return m_column;
}

inline void PsTile::setColumn(int column) {
   m_column = column;
}

inline std::string PsTile::getMaxOccurs() const {
   return "unbounded";
}

inline int PsTile::getMinOccurs() const {
   return 0;
}

inline const void *PsTile::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "arm") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_arm;
   }
   if (name == "column") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_column;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline PsHit &PsTile::getPsHit(int index) {
   return m_psHit_list(index);
}

inline PsHitList &PsTile::getPsHits() {
   return m_psHit_list;
}

inline PsHitList PsTile::addPsHits(int count, int start) {
   return m_psHit_list.add(count,start);
}

inline void PsTile::deletePsHits(int count, int start) {
   m_psHit_list.del(count,start);
}

inline PsTruthHit &PsTile::getPsTruthHit(int index) {
   return m_psTruthHit_list(index);
}

inline PsTruthHitList &PsTile::getPsTruthHits() {
   return m_psTruthHit_list;
}

inline PsTruthHitList PsTile::addPsTruthHits(int count, int start) {
   return m_psTruthHit_list.add(count,start);
}

inline void PsTile::deletePsTruthHits(int count, int start) {
   m_psTruthHit_list.del(count,start);
}

inline PsTruthPoint::PsTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_arm(0),
   m_column(0),
   m_dEdx(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline PsTruthPoint::~PsTruthPoint() {
   deleteTrackIDs();
}

inline std::string PsTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PsTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PsTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PsTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int PsTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float PsTruthPoint::getE() const {
   return m_E;
}

inline void PsTruthPoint::setE(float E) {
   m_E = E;
}

inline int PsTruthPoint::getArm() const {
   return m_arm;
}

inline void PsTruthPoint::setArm(int arm) {
   m_arm = arm;
}

inline int PsTruthPoint::getColumn() const {
   return m_column;
}

inline void PsTruthPoint::setColumn(int column) {
   m_column = column;
}

inline float PsTruthPoint::getDEdx() const {
   return m_dEdx;
}

inline void PsTruthPoint::setDEdx(float dEdx) {
   m_dEdx = dEdx;
}

inline std::string PsTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int PsTruthPoint::getMinOccurs() const {
   return 0;
}

inline bool PsTruthPoint::getPrimary() const {
   return m_primary;
}

inline void PsTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int PsTruthPoint::getPtype() const {
   return m_ptype;
}

inline void PsTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float PsTruthPoint::getPx() const {
   return m_px;
}

inline void PsTruthPoint::setPx(float px) {
   m_px = px;
}

inline float PsTruthPoint::getPy() const {
   return m_py;
}

inline void PsTruthPoint::setPy(float py) {
   m_py = py;
}

inline float PsTruthPoint::getPz() const {
   return m_pz;
}

inline void PsTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float PsTruthPoint::getT() const {
   return m_t;
}

inline void PsTruthPoint::setT(float t) {
   m_t = t;
}

inline int PsTruthPoint::getTrack() const {
   return m_track;
}

inline void PsTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float PsTruthPoint::getX() const {
   return m_x;
}

inline void PsTruthPoint::setX(float x) {
   m_x = x;
}

inline float PsTruthPoint::getY() const {
   return m_y;
}

inline void PsTruthPoint::setY(float y) {
   m_y = y;
}

inline float PsTruthPoint::getZ() const {
   return m_z;
}

inline void PsTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *PsTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "arm") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_arm;
   }
   if (name == "column") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_column;
   }
   if (name == "dEdx") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dEdx;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &PsTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &PsTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList PsTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void PsTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline PairSpectrometerFine::PairSpectrometerFine(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_psTile_list(&m_host->m_psTile_plist,
               m_host->m_psTile_plist.end(),
               m_host->m_psTile_plist.end(),
               this),
   m_psTruthPoint_list(&m_host->m_psTruthPoint_plist,
               m_host->m_psTruthPoint_plist.end(),
               m_host->m_psTruthPoint_plist.end(),
               this)
{}

inline PairSpectrometerFine::~PairSpectrometerFine() {
   deletePsTiles();
   deletePsTruthPoints();
}

inline std::string PairSpectrometerFine::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PairSpectrometerFine::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PairSpectrometerFine::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PairSpectrometerFine::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string PairSpectrometerFine::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int PairSpectrometerFine::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int PairSpectrometerFine::getMinOccurs() const {
   return 0;
}

inline const void *PairSpectrometerFine::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline PsTile &PairSpectrometerFine::getPsTile(int index) {
   return m_psTile_list(index);
}

inline PsTileList &PairSpectrometerFine::getPsTiles() {
   return m_psTile_list;
}

inline PsTileList PairSpectrometerFine::addPsTiles(int count, int start) {
   return m_psTile_list.add(count,start);
}

inline void PairSpectrometerFine::deletePsTiles(int count, int start) {
   m_psTile_list.del(count,start);
}

inline PsTruthPoint &PairSpectrometerFine::getPsTruthPoint(int index) {
   return m_psTruthPoint_list(index);
}

inline PsTruthPointList &PairSpectrometerFine::getPsTruthPoints() {
   return m_psTruthPoint_list;
}

inline PsTruthPointList PairSpectrometerFine::addPsTruthPoints(int count, int start) {
   return m_psTruthPoint_list.add(count,start);
}

inline void PairSpectrometerFine::deletePsTruthPoints(int count, int start) {
   m_psTruthPoint_list.del(count,start);
}

inline PscHit::PscHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_t(0)
{}

inline PscHit::~PscHit() {}

inline std::string PscHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PscHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PscHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PscHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int PscHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int PscHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int PscHit::getArm() const {
   return *(int*)m_parent->getAttribute("arm");
}

inline int PscHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline float PscHit::getDE() const {
   return m_dE;
}

inline void PscHit::setDE(float dE) {
   m_dE = dE;
}

inline std::string PscHit::getMaxOccurs() const {
   return "unbounded";
}

inline float PscHit::getT() const {
   return m_t;
}

inline void PscHit::setT(float t) {
   m_t = t;
}

inline const void *PscHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline PscTruthHit::PscTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_itrack(0),
   m_ptype(0),
   m_t(0)
{}

inline PscTruthHit::~PscTruthHit() {}

inline std::string PscTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PscTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PscTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PscTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int PscTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int PscTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int PscTruthHit::getArm() const {
   return *(int*)m_parent->getAttribute("arm");
}

inline int PscTruthHit::getModule() const {
   return *(int*)m_parent->getAttribute("module");
}

inline float PscTruthHit::getDE() const {
   return m_dE;
}

inline void PscTruthHit::setDE(float dE) {
   m_dE = dE;
}

inline int PscTruthHit::getItrack() const {
   return m_itrack;
}

inline void PscTruthHit::setItrack(int itrack) {
   m_itrack = itrack;
}

inline std::string PscTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int PscTruthHit::getPtype() const {
   return m_ptype;
}

inline void PscTruthHit::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float PscTruthHit::getT() const {
   return m_t;
}

inline void PscTruthHit::setT(float t) {
   m_t = t;
}

inline const void *PscTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline PscPaddle::PscPaddle(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_arm(0),
   m_module(0),
   m_pscHit_list(&m_host->m_pscHit_plist,
               m_host->m_pscHit_plist.end(),
               m_host->m_pscHit_plist.end(),
               this),
   m_pscTruthHit_list(&m_host->m_pscTruthHit_plist,
               m_host->m_pscTruthHit_plist.end(),
               m_host->m_pscTruthHit_plist.end(),
               this)
{}

inline PscPaddle::~PscPaddle() {
   deletePscHits();
   deletePscTruthHits();
}

inline std::string PscPaddle::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PscPaddle::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PscPaddle::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PscPaddle::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int PscPaddle::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int PscPaddle::getArm() const {
   return m_arm;
}

inline void PscPaddle::setArm(int arm) {
   m_arm = arm;
}

inline std::string PscPaddle::getMaxOccurs() const {
   return "unbounded";
}

inline int PscPaddle::getMinOccurs() const {
   return 0;
}

inline int PscPaddle::getModule() const {
   return m_module;
}

inline void PscPaddle::setModule(int module) {
   m_module = module;
}

inline const void *PscPaddle::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "arm") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_arm;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "module") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_module;
   }
   return m_parent->getAttribute(name, atype);
}

inline PscHit &PscPaddle::getPscHit(int index) {
   return m_pscHit_list(index);
}

inline PscHitList &PscPaddle::getPscHits() {
   return m_pscHit_list;
}

inline PscHitList PscPaddle::addPscHits(int count, int start) {
   return m_pscHit_list.add(count,start);
}

inline void PscPaddle::deletePscHits(int count, int start) {
   m_pscHit_list.del(count,start);
}

inline PscTruthHit &PscPaddle::getPscTruthHit(int index) {
   return m_pscTruthHit_list(index);
}

inline PscTruthHitList &PscPaddle::getPscTruthHits() {
   return m_pscTruthHit_list;
}

inline PscTruthHitList PscPaddle::addPscTruthHits(int count, int start) {
   return m_pscTruthHit_list.add(count,start);
}

inline void PscPaddle::deletePscTruthHits(int count, int start) {
   m_pscTruthHit_list.del(count,start);
}

inline PscTruthPoint::PscTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_arm(0),
   m_dEdx(0),
   m_module(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline PscTruthPoint::~PscTruthPoint() {
   deleteTrackIDs();
}

inline std::string PscTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PscTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PscTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PscTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int PscTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float PscTruthPoint::getE() const {
   return m_E;
}

inline void PscTruthPoint::setE(float E) {
   m_E = E;
}

inline int PscTruthPoint::getArm() const {
   return m_arm;
}

inline void PscTruthPoint::setArm(int arm) {
   m_arm = arm;
}

inline float PscTruthPoint::getDEdx() const {
   return m_dEdx;
}

inline void PscTruthPoint::setDEdx(float dEdx) {
   m_dEdx = dEdx;
}

inline std::string PscTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int PscTruthPoint::getMinOccurs() const {
   return 0;
}

inline int PscTruthPoint::getModule() const {
   return m_module;
}

inline void PscTruthPoint::setModule(int module) {
   m_module = module;
}

inline bool PscTruthPoint::getPrimary() const {
   return m_primary;
}

inline void PscTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int PscTruthPoint::getPtype() const {
   return m_ptype;
}

inline void PscTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float PscTruthPoint::getPx() const {
   return m_px;
}

inline void PscTruthPoint::setPx(float px) {
   m_px = px;
}

inline float PscTruthPoint::getPy() const {
   return m_py;
}

inline void PscTruthPoint::setPy(float py) {
   m_py = py;
}

inline float PscTruthPoint::getPz() const {
   return m_pz;
}

inline void PscTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float PscTruthPoint::getT() const {
   return m_t;
}

inline void PscTruthPoint::setT(float t) {
   m_t = t;
}

inline int PscTruthPoint::getTrack() const {
   return m_track;
}

inline void PscTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float PscTruthPoint::getX() const {
   return m_x;
}

inline void PscTruthPoint::setX(float x) {
   m_x = x;
}

inline float PscTruthPoint::getY() const {
   return m_y;
}

inline void PscTruthPoint::setY(float y) {
   m_y = y;
}

inline float PscTruthPoint::getZ() const {
   return m_z;
}

inline void PscTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *PscTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "arm") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_arm;
   }
   if (name == "dEdx") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dEdx;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "module") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_module;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &PscTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &PscTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList PscTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void PscTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline PairSpectrometerCoarse::PairSpectrometerCoarse(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_pscPaddle_list(&m_host->m_pscPaddle_plist,
               m_host->m_pscPaddle_plist.end(),
               m_host->m_pscPaddle_plist.end(),
               this),
   m_pscTruthPoint_list(&m_host->m_pscTruthPoint_plist,
               m_host->m_pscTruthPoint_plist.end(),
               m_host->m_pscTruthPoint_plist.end(),
               this)
{}

inline PairSpectrometerCoarse::~PairSpectrometerCoarse() {
   deletePscPaddles();
   deletePscTruthPoints();
}

inline std::string PairSpectrometerCoarse::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PairSpectrometerCoarse::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PairSpectrometerCoarse::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PairSpectrometerCoarse::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string PairSpectrometerCoarse::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int PairSpectrometerCoarse::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int PairSpectrometerCoarse::getMinOccurs() const {
   return 0;
}

inline const void *PairSpectrometerCoarse::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline PscPaddle &PairSpectrometerCoarse::getPscPaddle(int index) {
   return m_pscPaddle_list(index);
}

inline PscPaddleList &PairSpectrometerCoarse::getPscPaddles() {
   return m_pscPaddle_list;
}

inline PscPaddleList PairSpectrometerCoarse::addPscPaddles(int count, int start) {
   return m_pscPaddle_list.add(count,start);
}

inline void PairSpectrometerCoarse::deletePscPaddles(int count, int start) {
   m_pscPaddle_list.del(count,start);
}

inline PscTruthPoint &PairSpectrometerCoarse::getPscTruthPoint(int index) {
   return m_pscTruthPoint_list(index);
}

inline PscTruthPointList &PairSpectrometerCoarse::getPscTruthPoints() {
   return m_pscTruthPoint_list;
}

inline PscTruthPointList PairSpectrometerCoarse::addPscTruthPoints(int count, int start) {
   return m_pscTruthPoint_list.add(count,start);
}

inline void PairSpectrometerCoarse::deletePscTruthPoints(int count, int start) {
   m_pscTruthPoint_list.del(count,start);
}

inline TpolHit::TpolHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_t(0)
{}

inline TpolHit::~TpolHit() {}

inline std::string TpolHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TpolHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TpolHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TpolHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int TpolHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int TpolHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int TpolHit::getRing() const {
   return *(int*)m_parent->getAttribute("ring");
}

inline int TpolHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float TpolHit::getDE() const {
   return m_dE;
}

inline void TpolHit::setDE(float dE) {
   m_dE = dE;
}

inline std::string TpolHit::getMaxOccurs() const {
   return "unbounded";
}

inline float TpolHit::getT() const {
   return m_t;
}

inline void TpolHit::setT(float t) {
   m_t = t;
}

inline const void *TpolHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline TpolTruthHit::TpolTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_itrack(0),
   m_ptype(0),
   m_t(0)
{}

inline TpolTruthHit::~TpolTruthHit() {}

inline std::string TpolTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TpolTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TpolTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TpolTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int TpolTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int TpolTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int TpolTruthHit::getRing() const {
   return *(int*)m_parent->getAttribute("ring");
}

inline int TpolTruthHit::getSector() const {
   return *(int*)m_parent->getAttribute("sector");
}

inline float TpolTruthHit::getDE() const {
   return m_dE;
}

inline void TpolTruthHit::setDE(float dE) {
   m_dE = dE;
}

inline int TpolTruthHit::getItrack() const {
   return m_itrack;
}

inline void TpolTruthHit::setItrack(int itrack) {
   m_itrack = itrack;
}

inline std::string TpolTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline int TpolTruthHit::getPtype() const {
   return m_ptype;
}

inline void TpolTruthHit::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float TpolTruthHit::getT() const {
   return m_t;
}

inline void TpolTruthHit::setT(float t) {
   m_t = t;
}

inline const void *TpolTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "itrack") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_itrack;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline TpolSector::TpolSector(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_ring(0),
   m_sector(0),
   m_tpolHit_list(&m_host->m_tpolHit_plist,
               m_host->m_tpolHit_plist.end(),
               m_host->m_tpolHit_plist.end(),
               this),
   m_tpolTruthHit_list(&m_host->m_tpolTruthHit_plist,
               m_host->m_tpolTruthHit_plist.end(),
               m_host->m_tpolTruthHit_plist.end(),
               this)
{}

inline TpolSector::~TpolSector() {
   deleteTpolHits();
   deleteTpolTruthHits();
}

inline std::string TpolSector::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TpolSector::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TpolSector::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TpolSector::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int TpolSector::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string TpolSector::getMaxOccurs() const {
   return "unbounded";
}

inline int TpolSector::getMinOccurs() const {
   return 0;
}

inline int TpolSector::getRing() const {
   return m_ring;
}

inline void TpolSector::setRing(int ring) {
   m_ring = ring;
}

inline int TpolSector::getSector() const {
   return m_sector;
}

inline void TpolSector::setSector(int sector) {
   m_sector = sector;
}

inline const void *TpolSector::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "ring") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ring;
   }
   if (name == "sector") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_sector;
   }
   return m_parent->getAttribute(name, atype);
}

inline TpolHit &TpolSector::getTpolHit(int index) {
   return m_tpolHit_list(index);
}

inline TpolHitList &TpolSector::getTpolHits() {
   return m_tpolHit_list;
}

inline TpolHitList TpolSector::addTpolHits(int count, int start) {
   return m_tpolHit_list.add(count,start);
}

inline void TpolSector::deleteTpolHits(int count, int start) {
   m_tpolHit_list.del(count,start);
}

inline TpolTruthHit &TpolSector::getTpolTruthHit(int index) {
   return m_tpolTruthHit_list(index);
}

inline TpolTruthHitList &TpolSector::getTpolTruthHits() {
   return m_tpolTruthHit_list;
}

inline TpolTruthHitList TpolSector::addTpolTruthHits(int count, int start) {
   return m_tpolTruthHit_list.add(count,start);
}

inline void TpolSector::deleteTpolTruthHits(int count, int start) {
   m_tpolTruthHit_list.del(count,start);
}

inline TpolTruthPoint::TpolTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_dEdx(0),
   m_phi(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_r(0),
   m_t(0),
   m_track(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline TpolTruthPoint::~TpolTruthPoint() {
   deleteTrackIDs();
}

inline std::string TpolTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TpolTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TpolTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TpolTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int TpolTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float TpolTruthPoint::getE() const {
   return m_E;
}

inline void TpolTruthPoint::setE(float E) {
   m_E = E;
}

inline float TpolTruthPoint::getDEdx() const {
   return m_dEdx;
}

inline void TpolTruthPoint::setDEdx(float dEdx) {
   m_dEdx = dEdx;
}

inline std::string TpolTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int TpolTruthPoint::getMinOccurs() const {
   return 0;
}

inline float TpolTruthPoint::getPhi() const {
   return m_phi;
}

inline void TpolTruthPoint::setPhi(float phi) {
   m_phi = phi;
}

inline bool TpolTruthPoint::getPrimary() const {
   return m_primary;
}

inline void TpolTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int TpolTruthPoint::getPtype() const {
   return m_ptype;
}

inline void TpolTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float TpolTruthPoint::getPx() const {
   return m_px;
}

inline void TpolTruthPoint::setPx(float px) {
   m_px = px;
}

inline float TpolTruthPoint::getPy() const {
   return m_py;
}

inline void TpolTruthPoint::setPy(float py) {
   m_py = py;
}

inline float TpolTruthPoint::getPz() const {
   return m_pz;
}

inline void TpolTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float TpolTruthPoint::getR() const {
   return m_r;
}

inline void TpolTruthPoint::setR(float r) {
   m_r = r;
}

inline float TpolTruthPoint::getT() const {
   return m_t;
}

inline void TpolTruthPoint::setT(float t) {
   m_t = t;
}

inline int TpolTruthPoint::getTrack() const {
   return m_track;
}

inline void TpolTruthPoint::setTrack(int track) {
   m_track = track;
}

inline const void *TpolTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "dEdx") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dEdx;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "phi") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_phi;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "r") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_r;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &TpolTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &TpolTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList TpolTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void TpolTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline TripletPolarimeter::TripletPolarimeter(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_tpolSector_list(&m_host->m_tpolSector_plist,
               m_host->m_tpolSector_plist.end(),
               m_host->m_tpolSector_plist.end(),
               this),
   m_tpolTruthPoint_list(&m_host->m_tpolTruthPoint_plist,
               m_host->m_tpolTruthPoint_plist.end(),
               m_host->m_tpolTruthPoint_plist.end(),
               this)
{}

inline TripletPolarimeter::~TripletPolarimeter() {
   deleteTpolSectors();
   deleteTpolTruthPoints();
}

inline std::string TripletPolarimeter::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TripletPolarimeter::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TripletPolarimeter::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TripletPolarimeter::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string TripletPolarimeter::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int TripletPolarimeter::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int TripletPolarimeter::getMinOccurs() const {
   return 0;
}

inline const void *TripletPolarimeter::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline TpolSector &TripletPolarimeter::getTpolSector(int index) {
   return m_tpolSector_list(index);
}

inline TpolSectorList &TripletPolarimeter::getTpolSectors() {
   return m_tpolSector_list;
}

inline TpolSectorList TripletPolarimeter::addTpolSectors(int count, int start) {
   return m_tpolSector_list.add(count,start);
}

inline void TripletPolarimeter::deleteTpolSectors(int count, int start) {
   m_tpolSector_list.del(count,start);
}

inline TpolTruthPoint &TripletPolarimeter::getTpolTruthPoint(int index) {
   return m_tpolTruthPoint_list(index);
}

inline TpolTruthPointList &TripletPolarimeter::getTpolTruthPoints() {
   return m_tpolTruthPoint_list;
}

inline TpolTruthPointList TripletPolarimeter::addTpolTruthPoints(int count, int start) {
   return m_tpolTruthPoint_list.add(count,start);
}

inline void TripletPolarimeter::deleteTpolTruthPoints(int count, int start) {
   m_tpolTruthPoint_list.del(count,start);
}

inline McTrajectoryPoint::McTrajectoryPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_dE(0),
   m_mech(0),
   m_part(0),
   m_primary_track(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_radlen(0),
   m_step(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0)
{}

inline McTrajectoryPoint::~McTrajectoryPoint() {}

inline std::string McTrajectoryPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float McTrajectoryPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string McTrajectoryPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int McTrajectoryPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int McTrajectoryPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float McTrajectoryPoint::getE() const {
   return m_E;
}

inline void McTrajectoryPoint::setE(float E) {
   m_E = E;
}

inline float McTrajectoryPoint::getDE() const {
   return m_dE;
}

inline void McTrajectoryPoint::setDE(float dE) {
   m_dE = dE;
}

inline std::string McTrajectoryPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int McTrajectoryPoint::getMech() const {
   return m_mech;
}

inline void McTrajectoryPoint::setMech(int mech) {
   m_mech = mech;
}

inline int McTrajectoryPoint::getMinOccurs() const {
   return 0;
}

inline int McTrajectoryPoint::getPart() const {
   return m_part;
}

inline void McTrajectoryPoint::setPart(int part) {
   m_part = part;
}

inline int McTrajectoryPoint::getPrimary_track() const {
   return m_primary_track;
}

inline void McTrajectoryPoint::setPrimary_track(int primary_track) {
   m_primary_track = primary_track;
}

inline float McTrajectoryPoint::getPx() const {
   return m_px;
}

inline void McTrajectoryPoint::setPx(float px) {
   m_px = px;
}

inline float McTrajectoryPoint::getPy() const {
   return m_py;
}

inline void McTrajectoryPoint::setPy(float py) {
   m_py = py;
}

inline float McTrajectoryPoint::getPz() const {
   return m_pz;
}

inline void McTrajectoryPoint::setPz(float pz) {
   m_pz = pz;
}

inline float McTrajectoryPoint::getRadlen() const {
   return m_radlen;
}

inline void McTrajectoryPoint::setRadlen(float radlen) {
   m_radlen = radlen;
}

inline float McTrajectoryPoint::getStep() const {
   return m_step;
}

inline void McTrajectoryPoint::setStep(float step) {
   m_step = step;
}

inline float McTrajectoryPoint::getT() const {
   return m_t;
}

inline void McTrajectoryPoint::setT(float t) {
   m_t = t;
}

inline int McTrajectoryPoint::getTrack() const {
   return m_track;
}

inline void McTrajectoryPoint::setTrack(int track) {
   m_track = track;
}

inline float McTrajectoryPoint::getX() const {
   return m_x;
}

inline void McTrajectoryPoint::setX(float x) {
   m_x = x;
}

inline float McTrajectoryPoint::getY() const {
   return m_y;
}

inline void McTrajectoryPoint::setY(float y) {
   m_y = y;
}

inline float McTrajectoryPoint::getZ() const {
   return m_z;
}

inline void McTrajectoryPoint::setZ(float z) {
   m_z = z;
}

inline const void *McTrajectoryPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "mech") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_mech;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "part") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_part;
   }
   if (name == "primary_track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_primary_track;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "radlen") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_radlen;
   }
   if (name == "step") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_step;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline McTrajectory::McTrajectory(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_mcTrajectoryPoint_list(&m_host->m_mcTrajectoryPoint_plist,
               m_host->m_mcTrajectoryPoint_plist.end(),
               m_host->m_mcTrajectoryPoint_plist.end(),
               this)
{}

inline McTrajectory::~McTrajectory() {
   deleteMcTrajectoryPoints();
}

inline std::string McTrajectory::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float McTrajectory::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string McTrajectory::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int McTrajectory::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string McTrajectory::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int McTrajectory::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int McTrajectory::getMinOccurs() const {
   return 0;
}

inline const void *McTrajectory::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline McTrajectoryPoint &McTrajectory::getMcTrajectoryPoint(int index) {
   return m_mcTrajectoryPoint_list(index);
}

inline McTrajectoryPointList &McTrajectory::getMcTrajectoryPoints() {
   return m_mcTrajectoryPoint_list;
}

inline McTrajectoryPointList McTrajectory::addMcTrajectoryPoints(int count, int start) {
   return m_mcTrajectoryPoint_list.add(count,start);
}

inline void McTrajectory::deleteMcTrajectoryPoints(int count, int start) {
   m_mcTrajectoryPoint_list.del(count,start);
}

inline RFsubsystem::RFsubsystem(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_jtag(""),
   m_tsync(0)
{}

inline RFsubsystem::~RFsubsystem() {}

inline std::string RFsubsystem::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float RFsubsystem::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string RFsubsystem::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int RFsubsystem::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int RFsubsystem::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string RFsubsystem::getJtag() const {
   return m_jtag;
}

inline void RFsubsystem::setJtag(const std::string &jtag) {
   m_jtag = jtag;
}

inline std::string RFsubsystem::getMaxOccurs() const {
   return "unbounded";
}

inline int RFsubsystem::getMinOccurs() const {
   return 0;
}

inline float RFsubsystem::getTsync() const {
   return m_tsync;
}

inline void RFsubsystem::setTsync(float tsync) {
   m_tsync = tsync;
}

inline std::string RFsubsystem::getTunit() const {
   return "ns";
}

inline const void *RFsubsystem::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "jtag") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_jtag;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "tsync") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_tsync;
   }
   if (name == "tunit") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_tunit = getTunit();
      return &m_tunit;
   }
   return m_parent->getAttribute(name, atype);
}

inline RFtime::RFtime(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_jtag(""),
   m_tsync(0),
   m_RFsubsystem_list(&m_host->m_RFsubsystem_plist,
               m_host->m_RFsubsystem_plist.end(),
               m_host->m_RFsubsystem_plist.end(),
               this)
{}

inline RFtime::~RFtime() {
   deleteRFsubsystems();
}

inline std::string RFtime::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float RFtime::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string RFtime::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int RFtime::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string RFtime::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int RFtime::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline std::string RFtime::getJtag() const {
   return m_jtag;
}

inline void RFtime::setJtag(const std::string &jtag) {
   m_jtag = jtag;
}

inline int RFtime::getMinOccurs() const {
   return 0;
}

inline float RFtime::getTsync() const {
   return m_tsync;
}

inline void RFtime::setTsync(float tsync) {
   m_tsync = tsync;
}

inline std::string RFtime::getTunit() const {
   return "ns";
}

inline const void *RFtime::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "jtag") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_jtag;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "tsync") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_tsync;
   }
   if (name == "tunit") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_tunit = getTunit();
      return &m_tunit;
   }
   return m_parent->getAttribute(name, atype);
}

inline RFsubsystem &RFtime::getRFsubsystem(int index) {
   return m_RFsubsystem_list(index);
}

inline RFsubsystemList &RFtime::getRFsubsystems() {
   return m_RFsubsystem_list;
}

inline RFsubsystemList RFtime::addRFsubsystems(int count, int start) {
   return m_RFsubsystem_list.add(count,start);
}

inline void RFtime::deleteRFsubsystems(int count, int start) {
   m_RFsubsystem_list.del(count,start);
}

inline FmwpcTruthHit::FmwpcTruthHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_dx(0),
   m_t(0)
{}

inline FmwpcTruthHit::~FmwpcTruthHit() {}

inline std::string FmwpcTruthHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FmwpcTruthHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FmwpcTruthHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FmwpcTruthHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FmwpcTruthHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FmwpcTruthHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FmwpcTruthHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FmwpcTruthHit::getWire() const {
   return *(int*)m_parent->getAttribute("wire");
}

inline float FmwpcTruthHit::getDE() const {
   return m_dE;
}

inline void FmwpcTruthHit::setDE(float dE) {
   m_dE = dE;
}

inline float FmwpcTruthHit::getDx() const {
   return m_dx;
}

inline void FmwpcTruthHit::setDx(float dx) {
   m_dx = dx;
}

inline std::string FmwpcTruthHit::getMaxOccurs() const {
   return "unbounded";
}

inline float FmwpcTruthHit::getT() const {
   return m_t;
}

inline void FmwpcTruthHit::setT(float t) {
   m_t = t;
}

inline const void *FmwpcTruthHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "dx") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dx;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FmwpcHit::FmwpcHit(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_dE(0),
   m_t(0)
{}

inline FmwpcHit::~FmwpcHit() {}

inline std::string FmwpcHit::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FmwpcHit::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FmwpcHit::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FmwpcHit::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FmwpcHit::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FmwpcHit::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline int FmwpcHit::getLayer() const {
   return *(int*)m_parent->getAttribute("layer");
}

inline int FmwpcHit::getWire() const {
   return *(int*)m_parent->getAttribute("wire");
}

inline float FmwpcHit::getDE() const {
   return m_dE;
}

inline void FmwpcHit::setDE(float dE) {
   m_dE = dE;
}

inline std::string FmwpcHit::getMaxOccurs() const {
   return "unbounded";
}

inline float FmwpcHit::getT() const {
   return m_t;
}

inline void FmwpcHit::setT(float t) {
   m_t = t;
}

inline const void *FmwpcHit::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "dE") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_dE;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   return m_parent->getAttribute(name, atype);
}

inline FmwpcChamber::FmwpcChamber(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_layer(0),
   m_wire(0),
   m_fmwpcTruthHit_list(&m_host->m_fmwpcTruthHit_plist,
               m_host->m_fmwpcTruthHit_plist.end(),
               m_host->m_fmwpcTruthHit_plist.end(),
               this),
   m_fmwpcHit_list(&m_host->m_fmwpcHit_plist,
               m_host->m_fmwpcHit_plist.end(),
               m_host->m_fmwpcHit_plist.end(),
               this)
{}

inline FmwpcChamber::~FmwpcChamber() {
   deleteFmwpcTruthHits();
   deleteFmwpcHits();
}

inline std::string FmwpcChamber::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FmwpcChamber::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FmwpcChamber::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FmwpcChamber::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FmwpcChamber::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int FmwpcChamber::getLayer() const {
   return m_layer;
}

inline void FmwpcChamber::setLayer(int layer) {
   m_layer = layer;
}

inline std::string FmwpcChamber::getMaxOccurs() const {
   return "unbounded";
}

inline int FmwpcChamber::getMinOccurs() const {
   return 0;
}

inline int FmwpcChamber::getWire() const {
   return m_wire;
}

inline void FmwpcChamber::setWire(int wire) {
   m_wire = wire;
}

inline const void *FmwpcChamber::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "layer") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_layer;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "wire") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_wire;
   }
   return m_parent->getAttribute(name, atype);
}

inline FmwpcTruthHit &FmwpcChamber::getFmwpcTruthHit(int index) {
   return m_fmwpcTruthHit_list(index);
}

inline FmwpcTruthHitList &FmwpcChamber::getFmwpcTruthHits() {
   return m_fmwpcTruthHit_list;
}

inline FmwpcTruthHitList FmwpcChamber::addFmwpcTruthHits(int count, int start) {
   return m_fmwpcTruthHit_list.add(count,start);
}

inline void FmwpcChamber::deleteFmwpcTruthHits(int count, int start) {
   m_fmwpcTruthHit_list.del(count,start);
}

inline FmwpcHit &FmwpcChamber::getFmwpcHit(int index) {
   return m_fmwpcHit_list(index);
}

inline FmwpcHitList &FmwpcChamber::getFmwpcHits() {
   return m_fmwpcHit_list;
}

inline FmwpcHitList FmwpcChamber::addFmwpcHits(int count, int start) {
   return m_fmwpcHit_list.add(count,start);
}

inline void FmwpcChamber::deleteFmwpcHits(int count, int start) {
   m_fmwpcHit_list.del(count,start);
}

inline FmwpcTruthPoint::FmwpcTruthPoint(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_E(0),
   m_primary(0),
   m_ptype(0),
   m_px(0),
   m_py(0),
   m_pz(0),
   m_t(0),
   m_track(0),
   m_x(0),
   m_y(0),
   m_z(0),
   m_trackID_link(&m_host->m_trackID_plist,
               m_host->m_trackID_plist.end(),
               m_host->m_trackID_plist.end(),
               this)
{}

inline FmwpcTruthPoint::~FmwpcTruthPoint() {
   deleteTrackIDs();
}

inline std::string FmwpcTruthPoint::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float FmwpcTruthPoint::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string FmwpcTruthPoint::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int FmwpcTruthPoint::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int FmwpcTruthPoint::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float FmwpcTruthPoint::getE() const {
   return m_E;
}

inline void FmwpcTruthPoint::setE(float E) {
   m_E = E;
}

inline std::string FmwpcTruthPoint::getMaxOccurs() const {
   return "unbounded";
}

inline int FmwpcTruthPoint::getMinOccurs() const {
   return 0;
}

inline bool FmwpcTruthPoint::getPrimary() const {
   return m_primary;
}

inline void FmwpcTruthPoint::setPrimary(bool primary) {
   m_primary = primary;
}

inline int FmwpcTruthPoint::getPtype() const {
   return m_ptype;
}

inline void FmwpcTruthPoint::setPtype(int ptype) {
   m_ptype = ptype;
}

inline float FmwpcTruthPoint::getPx() const {
   return m_px;
}

inline void FmwpcTruthPoint::setPx(float px) {
   m_px = px;
}

inline float FmwpcTruthPoint::getPy() const {
   return m_py;
}

inline void FmwpcTruthPoint::setPy(float py) {
   m_py = py;
}

inline float FmwpcTruthPoint::getPz() const {
   return m_pz;
}

inline void FmwpcTruthPoint::setPz(float pz) {
   m_pz = pz;
}

inline float FmwpcTruthPoint::getT() const {
   return m_t;
}

inline void FmwpcTruthPoint::setT(float t) {
   m_t = t;
}

inline int FmwpcTruthPoint::getTrack() const {
   return m_track;
}

inline void FmwpcTruthPoint::setTrack(int track) {
   m_track = track;
}

inline float FmwpcTruthPoint::getX() const {
   return m_x;
}

inline void FmwpcTruthPoint::setX(float x) {
   m_x = x;
}

inline float FmwpcTruthPoint::getY() const {
   return m_y;
}

inline void FmwpcTruthPoint::setY(float y) {
   m_y = y;
}

inline float FmwpcTruthPoint::getZ() const {
   return m_z;
}

inline void FmwpcTruthPoint::setZ(float z) {
   m_z = z;
}

inline const void *FmwpcTruthPoint::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "E") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_E;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "primary") {
      if (atype != 0)
         *atype = k_hddm_boolean;
      return &m_primary;
   }
   if (name == "ptype") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_ptype;
   }
   if (name == "px") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_px;
   }
   if (name == "py") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_py;
   }
   if (name == "pz") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_pz;
   }
   if (name == "t") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_t;
   }
   if (name == "track") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_track;
   }
   if (name == "x") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_x;
   }
   if (name == "y") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_y;
   }
   if (name == "z") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_z;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackID &FmwpcTruthPoint::getTrackID() {
   return m_trackID_link.front();
}

inline TrackIDList &FmwpcTruthPoint::getTrackIDs() {
   return m_trackID_link;
}

inline TrackIDList FmwpcTruthPoint::addTrackIDs(int count, int start) {
   return m_trackID_link.add(count,start);
}

inline void FmwpcTruthPoint::deleteTrackIDs(int count, int start) {
   m_trackID_link.del(count,start);
}

inline ForwardMWPC::ForwardMWPC(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_fmwpcChamber_list(&m_host->m_fmwpcChamber_plist,
               m_host->m_fmwpcChamber_plist.end(),
               m_host->m_fmwpcChamber_plist.end(),
               this),
   m_fmwpcTruthPoint_list(&m_host->m_fmwpcTruthPoint_plist,
               m_host->m_fmwpcTruthPoint_plist.end(),
               m_host->m_fmwpcTruthPoint_plist.end(),
               this)
{}

inline ForwardMWPC::~ForwardMWPC() {
   deleteFmwpcChambers();
   deleteFmwpcTruthPoints();
}

inline std::string ForwardMWPC::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float ForwardMWPC::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string ForwardMWPC::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int ForwardMWPC::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string ForwardMWPC::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int ForwardMWPC::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int ForwardMWPC::getMinOccurs() const {
   return 0;
}

inline const void *ForwardMWPC::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   return m_parent->getAttribute(name, atype);
}

inline FmwpcChamber &ForwardMWPC::getFmwpcChamber(int index) {
   return m_fmwpcChamber_list(index);
}

inline FmwpcChamberList &ForwardMWPC::getFmwpcChambers() {
   return m_fmwpcChamber_list;
}

inline FmwpcChamberList ForwardMWPC::addFmwpcChambers(int count, int start) {
   return m_fmwpcChamber_list.add(count,start);
}

inline void ForwardMWPC::deleteFmwpcChambers(int count, int start) {
   m_fmwpcChamber_list.del(count,start);
}

inline FmwpcTruthPoint &ForwardMWPC::getFmwpcTruthPoint(int index) {
   return m_fmwpcTruthPoint_list(index);
}

inline FmwpcTruthPointList &ForwardMWPC::getFmwpcTruthPoints() {
   return m_fmwpcTruthPoint_list;
}

inline FmwpcTruthPointList ForwardMWPC::addFmwpcTruthPoints(int count, int start) {
   return m_fmwpcTruthPoint_list.add(count,start);
}

inline void ForwardMWPC::deleteFmwpcTruthPoints(int count, int start) {
   m_fmwpcTruthPoint_list.del(count,start);
}

inline HitView::HitView(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_centralDC_link(&m_host->m_centralDC_plist,
               m_host->m_centralDC_plist.end(),
               m_host->m_centralDC_plist.end(),
               this),
   m_forwardDC_link(&m_host->m_forwardDC_plist,
               m_host->m_forwardDC_plist.end(),
               m_host->m_forwardDC_plist.end(),
               this),
   m_startCntr_link(&m_host->m_startCntr_plist,
               m_host->m_startCntr_plist.end(),
               m_host->m_startCntr_plist.end(),
               this),
   m_barrelEMcal_link(&m_host->m_barrelEMcal_plist,
               m_host->m_barrelEMcal_plist.end(),
               m_host->m_barrelEMcal_plist.end(),
               this),
   m_gapEMcal_link(&m_host->m_gapEMcal_plist,
               m_host->m_gapEMcal_plist.end(),
               m_host->m_gapEMcal_plist.end(),
               this),
   m_Cerenkov_link(&m_host->m_Cerenkov_plist,
               m_host->m_Cerenkov_plist.end(),
               m_host->m_Cerenkov_plist.end(),
               this),
   m_RICH_link(&m_host->m_RICH_plist,
               m_host->m_RICH_plist.end(),
               m_host->m_RICH_plist.end(),
               this),
   m_DIRC_link(&m_host->m_DIRC_plist,
               m_host->m_DIRC_plist.end(),
               m_host->m_DIRC_plist.end(),
               this),
   m_forwardTOF_link(&m_host->m_forwardTOF_plist,
               m_host->m_forwardTOF_plist.end(),
               m_host->m_forwardTOF_plist.end(),
               this),
   m_forwardEMcal_link(&m_host->m_forwardEMcal_plist,
               m_host->m_forwardEMcal_plist.end(),
               m_host->m_forwardEMcal_plist.end(),
               this),
   m_ComptonEMcal_link(&m_host->m_ComptonEMcal_plist,
               m_host->m_ComptonEMcal_plist.end(),
               m_host->m_ComptonEMcal_plist.end(),
               this),
   m_upstreamEMveto_link(&m_host->m_upstreamEMveto_plist,
               m_host->m_upstreamEMveto_plist.end(),
               m_host->m_upstreamEMveto_plist.end(),
               this),
   m_tagger_link(&m_host->m_tagger_plist,
               m_host->m_tagger_plist.end(),
               m_host->m_tagger_plist.end(),
               this),
   m_pairSpectrometerFine_link(&m_host->m_pairSpectrometerFine_plist,
               m_host->m_pairSpectrometerFine_plist.end(),
               m_host->m_pairSpectrometerFine_plist.end(),
               this),
   m_pairSpectrometerCoarse_link(&m_host->m_pairSpectrometerCoarse_plist,
               m_host->m_pairSpectrometerCoarse_plist.end(),
               m_host->m_pairSpectrometerCoarse_plist.end(),
               this),
   m_tripletPolarimeter_link(&m_host->m_tripletPolarimeter_plist,
               m_host->m_tripletPolarimeter_plist.end(),
               m_host->m_tripletPolarimeter_plist.end(),
               this),
   m_mcTrajectory_link(&m_host->m_mcTrajectory_plist,
               m_host->m_mcTrajectory_plist.end(),
               m_host->m_mcTrajectory_plist.end(),
               this),
   m_RFtime_link(&m_host->m_RFtime_plist,
               m_host->m_RFtime_plist.end(),
               m_host->m_RFtime_plist.end(),
               this),
   m_forwardMWPC_link(&m_host->m_forwardMWPC_plist,
               m_host->m_forwardMWPC_plist.end(),
               m_host->m_forwardMWPC_plist.end(),
               this)
{}

inline HitView::~HitView() {
   deleteCentralDCs();
   deleteForwardDCs();
   deleteStartCntrs();
   deleteBarrelEMcals();
   deleteGapEMcals();
   deleteCerenkovs();
   deleteRICHs();
   deleteDIRCs();
   deleteForwardTOFs();
   deleteForwardEMcals();
   deleteComptonEMcals();
   deleteUpstreamEMvetos();
   deleteTaggers();
   deletePairSpectrometerFines();
   deletePairSpectrometerCoarses();
   deleteTripletPolarimeters();
   deleteMcTrajectorys();
   deleteRFtimes();
   deleteForwardMWPCs();
}

inline std::string HitView::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline std::string HitView::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int HitView::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string HitView::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int HitView::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int HitView::getMinOccurs() const {
   return 0;
}

inline float HitView::getVersion() const {
   return 2.0;
}

inline const void *HitView::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "version") {
      if (atype != 0)
         *atype = k_hddm_float;
      static float m_version = getVersion();
      return &m_version;
   }
   return m_parent->getAttribute(name, atype);
}

inline CentralDC &HitView::getCentralDC() {
   return m_centralDC_link.front();
}

inline CentralDCList &HitView::getCentralDCs() {
   return m_centralDC_link;
}

inline CentralDCList HitView::addCentralDCs(int count, int start) {
   return m_centralDC_link.add(count,start);
}

inline void HitView::deleteCentralDCs(int count, int start) {
   m_centralDC_link.del(count,start);
}

inline ForwardDC &HitView::getForwardDC() {
   return m_forwardDC_link.front();
}

inline ForwardDCList &HitView::getForwardDCs() {
   return m_forwardDC_link;
}

inline ForwardDCList HitView::addForwardDCs(int count, int start) {
   return m_forwardDC_link.add(count,start);
}

inline void HitView::deleteForwardDCs(int count, int start) {
   m_forwardDC_link.del(count,start);
}

inline StartCntr &HitView::getStartCntr() {
   return m_startCntr_link.front();
}

inline StartCntrList &HitView::getStartCntrs() {
   return m_startCntr_link;
}

inline StartCntrList HitView::addStartCntrs(int count, int start) {
   return m_startCntr_link.add(count,start);
}

inline void HitView::deleteStartCntrs(int count, int start) {
   m_startCntr_link.del(count,start);
}

inline BarrelEMcal &HitView::getBarrelEMcal() {
   return m_barrelEMcal_link.front();
}

inline BarrelEMcalList &HitView::getBarrelEMcals() {
   return m_barrelEMcal_link;
}

inline BarrelEMcalList HitView::addBarrelEMcals(int count, int start) {
   return m_barrelEMcal_link.add(count,start);
}

inline void HitView::deleteBarrelEMcals(int count, int start) {
   m_barrelEMcal_link.del(count,start);
}

inline GapEMcal &HitView::getGapEMcal() {
   return m_gapEMcal_link.front();
}

inline GapEMcalList &HitView::getGapEMcals() {
   return m_gapEMcal_link;
}

inline GapEMcalList HitView::addGapEMcals(int count, int start) {
   return m_gapEMcal_link.add(count,start);
}

inline void HitView::deleteGapEMcals(int count, int start) {
   m_gapEMcal_link.del(count,start);
}

inline Cerenkov &HitView::getCerenkov() {
   return m_Cerenkov_link.front();
}

inline CerenkovList &HitView::getCerenkovs() {
   return m_Cerenkov_link;
}

inline CerenkovList HitView::addCerenkovs(int count, int start) {
   return m_Cerenkov_link.add(count,start);
}

inline void HitView::deleteCerenkovs(int count, int start) {
   m_Cerenkov_link.del(count,start);
}

inline RICH &HitView::getRICH() {
   return m_RICH_link.front();
}

inline RICHList &HitView::getRICHs() {
   return m_RICH_link;
}

inline RICHList HitView::addRICHs(int count, int start) {
   return m_RICH_link.add(count,start);
}

inline void HitView::deleteRICHs(int count, int start) {
   m_RICH_link.del(count,start);
}

inline DIRC &HitView::getDIRC() {
   return m_DIRC_link.front();
}

inline DIRCList &HitView::getDIRCs() {
   return m_DIRC_link;
}

inline DIRCList HitView::addDIRCs(int count, int start) {
   return m_DIRC_link.add(count,start);
}

inline void HitView::deleteDIRCs(int count, int start) {
   m_DIRC_link.del(count,start);
}

inline ForwardTOF &HitView::getForwardTOF() {
   return m_forwardTOF_link.front();
}

inline ForwardTOFList &HitView::getForwardTOFs() {
   return m_forwardTOF_link;
}

inline ForwardTOFList HitView::addForwardTOFs(int count, int start) {
   return m_forwardTOF_link.add(count,start);
}

inline void HitView::deleteForwardTOFs(int count, int start) {
   m_forwardTOF_link.del(count,start);
}

inline ForwardEMcal &HitView::getForwardEMcal() {
   return m_forwardEMcal_link.front();
}

inline ForwardEMcalList &HitView::getForwardEMcals() {
   return m_forwardEMcal_link;
}

inline ForwardEMcalList HitView::addForwardEMcals(int count, int start) {
   return m_forwardEMcal_link.add(count,start);
}

inline void HitView::deleteForwardEMcals(int count, int start) {
   m_forwardEMcal_link.del(count,start);
}

inline ComptonEMcal &HitView::getComptonEMcal() {
   return m_ComptonEMcal_link.front();
}

inline ComptonEMcalList &HitView::getComptonEMcals() {
   return m_ComptonEMcal_link;
}

inline ComptonEMcalList HitView::addComptonEMcals(int count, int start) {
   return m_ComptonEMcal_link.add(count,start);
}

inline void HitView::deleteComptonEMcals(int count, int start) {
   m_ComptonEMcal_link.del(count,start);
}

inline UpstreamEMveto &HitView::getUpstreamEMveto() {
   return m_upstreamEMveto_link.front();
}

inline UpstreamEMvetoList &HitView::getUpstreamEMvetos() {
   return m_upstreamEMveto_link;
}

inline UpstreamEMvetoList HitView::addUpstreamEMvetos(int count, int start) {
   return m_upstreamEMveto_link.add(count,start);
}

inline void HitView::deleteUpstreamEMvetos(int count, int start) {
   m_upstreamEMveto_link.del(count,start);
}

inline Tagger &HitView::getTagger() {
   return m_tagger_link.front();
}

inline TaggerList &HitView::getTaggers() {
   return m_tagger_link;
}

inline TaggerList HitView::addTaggers(int count, int start) {
   return m_tagger_link.add(count,start);
}

inline void HitView::deleteTaggers(int count, int start) {
   m_tagger_link.del(count,start);
}

inline PairSpectrometerFine &HitView::getPairSpectrometerFine() {
   return m_pairSpectrometerFine_link.front();
}

inline PairSpectrometerFineList &HitView::getPairSpectrometerFines() {
   return m_pairSpectrometerFine_link;
}

inline PairSpectrometerFineList HitView::addPairSpectrometerFines(int count, int start) {
   return m_pairSpectrometerFine_link.add(count,start);
}

inline void HitView::deletePairSpectrometerFines(int count, int start) {
   m_pairSpectrometerFine_link.del(count,start);
}

inline PairSpectrometerCoarse &HitView::getPairSpectrometerCoarse() {
   return m_pairSpectrometerCoarse_link.front();
}

inline PairSpectrometerCoarseList &HitView::getPairSpectrometerCoarses() {
   return m_pairSpectrometerCoarse_link;
}

inline PairSpectrometerCoarseList HitView::addPairSpectrometerCoarses(int count, int start) {
   return m_pairSpectrometerCoarse_link.add(count,start);
}

inline void HitView::deletePairSpectrometerCoarses(int count, int start) {
   m_pairSpectrometerCoarse_link.del(count,start);
}

inline TripletPolarimeter &HitView::getTripletPolarimeter() {
   return m_tripletPolarimeter_link.front();
}

inline TripletPolarimeterList &HitView::getTripletPolarimeters() {
   return m_tripletPolarimeter_link;
}

inline TripletPolarimeterList HitView::addTripletPolarimeters(int count, int start) {
   return m_tripletPolarimeter_link.add(count,start);
}

inline void HitView::deleteTripletPolarimeters(int count, int start) {
   m_tripletPolarimeter_link.del(count,start);
}

inline McTrajectory &HitView::getMcTrajectory() {
   return m_mcTrajectory_link.front();
}

inline McTrajectoryList &HitView::getMcTrajectorys() {
   return m_mcTrajectory_link;
}

inline McTrajectoryList HitView::addMcTrajectorys(int count, int start) {
   return m_mcTrajectory_link.add(count,start);
}

inline void HitView::deleteMcTrajectorys(int count, int start) {
   m_mcTrajectory_link.del(count,start);
}

inline RFtime &HitView::getRFtime() {
   return m_RFtime_link.front();
}

inline RFtimeList &HitView::getRFtimes() {
   return m_RFtime_link;
}

inline RFtimeList HitView::addRFtimes(int count, int start) {
   return m_RFtime_link.add(count,start);
}

inline void HitView::deleteRFtimes(int count, int start) {
   m_RFtime_link.del(count,start);
}

inline ForwardMWPC &HitView::getForwardMWPC() {
   return m_forwardMWPC_link.front();
}

inline ForwardMWPCList &HitView::getForwardMWPCs() {
   return m_forwardMWPC_link;
}

inline ForwardMWPCList HitView::addForwardMWPCs(int count, int start) {
   return m_forwardMWPC_link.add(count,start);
}

inline void HitView::deleteForwardMWPCs(int count, int start) {
   m_forwardMWPC_link.del(count,start);
}

inline ErrorMatrix::ErrorMatrix(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_Ncols(0),
   m_Nrows(0),
   m_type(""),
   m_vals("")
{}

inline ErrorMatrix::~ErrorMatrix() {}

inline std::string ErrorMatrix::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float ErrorMatrix::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string ErrorMatrix::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int ErrorMatrix::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string ErrorMatrix::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int ErrorMatrix::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int ErrorMatrix::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline float ErrorMatrix::getFOM() const {
   return *(float*)m_parent->getAttribute("FOM");
}

inline int ErrorMatrix::getNdof() const {
   return *(int*)m_parent->getAttribute("Ndof");
}

inline int ErrorMatrix::getCandidateid() const {
   return *(int*)m_parent->getAttribute("candidateid");
}

inline float ErrorMatrix::getChisq() const {
   return *(float*)m_parent->getAttribute("chisq");
}

inline int ErrorMatrix::getId() const {
   return *(int*)m_parent->getAttribute("id");
}

inline int ErrorMatrix::getTrackid() const {
   return *(int*)m_parent->getAttribute("trackid");
}

inline int ErrorMatrix::getNcols() const {
   return m_Ncols;
}

inline void ErrorMatrix::setNcols(int Ncols) {
   m_Ncols = Ncols;
}

inline int ErrorMatrix::getNrows() const {
   return m_Nrows;
}

inline void ErrorMatrix::setNrows(int Nrows) {
   m_Nrows = Nrows;
}

inline std::string ErrorMatrix::getType() const {
   return m_type;
}

inline void ErrorMatrix::setType(const std::string &type) {
   m_type = type;
}

inline std::string ErrorMatrix::getVals() const {
   return m_vals;
}

inline void ErrorMatrix::setVals(const std::string &vals) {
   m_vals = vals;
}

inline const void *ErrorMatrix::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "Ncols") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_Ncols;
   }
   if (name == "Nrows") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_Nrows;
   }
   if (name == "type") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_type;
   }
   if (name == "vals") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_vals;
   }
   return m_parent->getAttribute(name, atype);
}

inline TrackingErrorMatrix::TrackingErrorMatrix(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_Ncols(0),
   m_Nrows(0),
   m_type(""),
   m_vals("")
{}

inline TrackingErrorMatrix::~TrackingErrorMatrix() {}

inline std::string TrackingErrorMatrix::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float TrackingErrorMatrix::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string TrackingErrorMatrix::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int TrackingErrorMatrix::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string TrackingErrorMatrix::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int TrackingErrorMatrix::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int TrackingErrorMatrix::getMinOccurs() const {
   return *(int*)m_parent->getAttribute("minOccurs");
}

inline float TrackingErrorMatrix::getFOM() const {
   return *(float*)m_parent->getAttribute("FOM");
}

inline int TrackingErrorMatrix::getNdof() const {
   return *(int*)m_parent->getAttribute("Ndof");
}

inline int TrackingErrorMatrix::getCandidateid() const {
   return *(int*)m_parent->getAttribute("candidateid");
}

inline float TrackingErrorMatrix::getChisq() const {
   return *(float*)m_parent->getAttribute("chisq");
}

inline int TrackingErrorMatrix::getId() const {
   return *(int*)m_parent->getAttribute("id");
}

inline int TrackingErrorMatrix::getTrackid() const {
   return *(int*)m_parent->getAttribute("trackid");
}

inline int TrackingErrorMatrix::getNcols() const {
   return m_Ncols;
}

inline void TrackingErrorMatrix::setNcols(int Ncols) {
   m_Ncols = Ncols;
}

inline int TrackingErrorMatrix::getNrows() const {
   return m_Nrows;
}

inline void TrackingErrorMatrix::setNrows(int Nrows) {
   m_Nrows = Nrows;
}

inline std::string TrackingErrorMatrix::getType() const {
   return m_type;
}

inline void TrackingErrorMatrix::setType(const std::string &type) {
   m_type = type;
}

inline std::string TrackingErrorMatrix::getVals() const {
   return m_vals;
}

inline void TrackingErrorMatrix::setVals(const std::string &vals) {
   m_vals = vals;
}

inline const void *TrackingErrorMatrix::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "Ncols") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_Ncols;
   }
   if (name == "Nrows") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_Nrows;
   }
   if (name == "type") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_type;
   }
   if (name == "vals") {
      if (atype != 0)
         *atype = k_hddm_string;
      return &m_vals;
   }
   return m_parent->getAttribute(name, atype);
}

inline Tracktimebased::Tracktimebased(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_FOM(0),
   m_Ndof(0),
   m_candidateid(0),
   m_chisq(0),
   m_id(0),
   m_trackid(0),
   m_momentum_link(&m_host->m_momentum_plist,
               m_host->m_momentum_plist.end(),
               m_host->m_momentum_plist.end(),
               this),
   m_properties_link(&m_host->m_properties_plist,
               m_host->m_properties_plist.end(),
               m_host->m_properties_plist.end(),
               this),
   m_origin_link(&m_host->m_origin_plist,
               m_host->m_origin_plist.end(),
               m_host->m_origin_plist.end(),
               this),
   m_errorMatrix_link(&m_host->m_errorMatrix_plist,
               m_host->m_errorMatrix_plist.end(),
               m_host->m_errorMatrix_plist.end(),
               this),
   m_TrackingErrorMatrix_link(&m_host->m_TrackingErrorMatrix_plist,
               m_host->m_TrackingErrorMatrix_plist.end(),
               m_host->m_TrackingErrorMatrix_plist.end(),
               this)
{}

inline Tracktimebased::~Tracktimebased() {
   deleteMomenta();
   deletePropertiesList();
   deleteOrigins();
   deleteErrorMatrixs();
   deleteTrackingErrorMatrixs();
}

inline std::string Tracktimebased::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float Tracktimebased::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string Tracktimebased::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int Tracktimebased::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline int Tracktimebased::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline float Tracktimebased::getFOM() const {
   return m_FOM;
}

inline void Tracktimebased::setFOM(float FOM) {
   m_FOM = FOM;
}

inline int Tracktimebased::getNdof() const {
   return m_Ndof;
}

inline void Tracktimebased::setNdof(int Ndof) {
   m_Ndof = Ndof;
}

inline int Tracktimebased::getCandidateid() const {
   return m_candidateid;
}

inline void Tracktimebased::setCandidateid(int candidateid) {
   m_candidateid = candidateid;
}

inline float Tracktimebased::getChisq() const {
   return m_chisq;
}

inline void Tracktimebased::setChisq(float chisq) {
   m_chisq = chisq;
}

inline int Tracktimebased::getId() const {
   return m_id;
}

inline void Tracktimebased::setId(int id) {
   m_id = id;
}

inline std::string Tracktimebased::getMaxOccurs() const {
   return "unbounded";
}

inline int Tracktimebased::getMinOccurs() const {
   return 0;
}

inline int Tracktimebased::getTrackid() const {
   return m_trackid;
}

inline void Tracktimebased::setTrackid(int trackid) {
   m_trackid = trackid;
}

inline const void *Tracktimebased::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "FOM") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_FOM;
   }
   if (name == "Ndof") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_Ndof;
   }
   if (name == "candidateid") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_candidateid;
   }
   if (name == "chisq") {
      if (atype != 0)
         *atype = k_hddm_float;
      return &m_chisq;
   }
   if (name == "id") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_id;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "trackid") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_trackid;
   }
   return m_parent->getAttribute(name, atype);
}

inline Momentum &Tracktimebased::getMomentum() {
   return m_momentum_link.front();
}

inline MomentumList &Tracktimebased::getMomenta() {
   return m_momentum_link;
}

inline MomentumList Tracktimebased::addMomenta(int count, int start) {
   return m_momentum_link.add(count,start);
}

inline void Tracktimebased::deleteMomenta(int count, int start) {
   m_momentum_link.del(count,start);
}

inline Properties &Tracktimebased::getProperties() {
   return m_properties_link.front();
}

inline PropertiesList &Tracktimebased::getPropertiesList() {
   return m_properties_link;
}

inline PropertiesList Tracktimebased::addPropertiesList(int count, int start) {
   return m_properties_link.add(count,start);
}

inline void Tracktimebased::deletePropertiesList(int count, int start) {
   m_properties_link.del(count,start);
}

inline Origin &Tracktimebased::getOrigin() {
   return m_origin_link.front();
}

inline OriginList &Tracktimebased::getOrigins() {
   return m_origin_link;
}

inline OriginList Tracktimebased::addOrigins(int count, int start) {
   return m_origin_link.add(count,start);
}

inline void Tracktimebased::deleteOrigins(int count, int start) {
   m_origin_link.del(count,start);
}

inline ErrorMatrix &Tracktimebased::getErrorMatrix() {
   return m_errorMatrix_link.front();
}

inline ErrorMatrixList &Tracktimebased::getErrorMatrixs() {
   return m_errorMatrix_link;
}

inline ErrorMatrixList Tracktimebased::addErrorMatrixs(int count, int start) {
   return m_errorMatrix_link.add(count,start);
}

inline void Tracktimebased::deleteErrorMatrixs(int count, int start) {
   m_errorMatrix_link.del(count,start);
}

inline TrackingErrorMatrix &Tracktimebased::getTrackingErrorMatrix() {
   return m_TrackingErrorMatrix_link.front();
}

inline TrackingErrorMatrixList &Tracktimebased::getTrackingErrorMatrixs() {
   return m_TrackingErrorMatrix_link;
}

inline TrackingErrorMatrixList Tracktimebased::addTrackingErrorMatrixs(int count, int start) {
   return m_TrackingErrorMatrix_link.add(count,start);
}

inline void Tracktimebased::deleteTrackingErrorMatrixs(int count, int start) {
   m_TrackingErrorMatrix_link.del(count,start);
}

inline ReconView::ReconView(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_tracktimebased_list(&m_host->m_tracktimebased_plist,
               m_host->m_tracktimebased_plist.end(),
               m_host->m_tracktimebased_plist.end(),
               this)
{}

inline ReconView::~ReconView() {
   deleteTracktimebaseds();
}

inline std::string ReconView::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline std::string ReconView::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int ReconView::getEventNo() const {
   return *(int*)m_parent->getAttribute("eventNo");
}

inline std::string ReconView::getMaxOccurs() const {
   return *(std::string*)m_parent->getAttribute("maxOccurs");
}

inline int ReconView::getRunNo() const {
   return *(int*)m_parent->getAttribute("runNo");
}

inline int ReconView::getMinOccurs() const {
   return 0;
}

inline float ReconView::getVersion() const {
   return 1.0;
}

inline const void *ReconView::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "minOccurs") {
      if (atype != 0)
         *atype = k_hddm_int;
      static int m_minOccurs = getMinOccurs();
      return &m_minOccurs;
   }
   if (name == "version") {
      if (atype != 0)
         *atype = k_hddm_float;
      static float m_version = getVersion();
      return &m_version;
   }
   return m_parent->getAttribute(name, atype);
}

inline Tracktimebased &ReconView::getTracktimebased(int index) {
   return m_tracktimebased_list(index);
}

inline TracktimebasedList &ReconView::getTracktimebaseds() {
   return m_tracktimebased_list;
}

inline TracktimebasedList ReconView::addTracktimebaseds(int count, int start) {
   return m_tracktimebased_list.add(count,start);
}

inline void ReconView::deleteTracktimebaseds(int count, int start) {
   m_tracktimebased_list.del(count,start);
}

inline PhysicsEvent::PhysicsEvent(HDDM_Element *parent)
 : HDDM_Element(parent),
   m_eventNo(0),
   m_runNo(0),
   m_dataVersionString_list(&m_host->m_dataVersionString_plist,
               m_host->m_dataVersionString_plist.end(),
               m_host->m_dataVersionString_plist.end(),
               this),
   m_ccdbContext_list(&m_host->m_ccdbContext_plist,
               m_host->m_ccdbContext_plist.end(),
               m_host->m_ccdbContext_plist.end(),
               this),
   m_reaction_list(&m_host->m_reaction_plist,
               m_host->m_reaction_plist.end(),
               m_host->m_reaction_plist.end(),
               this),
   m_hitView_link(&m_host->m_hitView_plist,
               m_host->m_hitView_plist.end(),
               m_host->m_hitView_plist.end(),
               this),
   m_reconView_link(&m_host->m_reconView_plist,
               m_host->m_reconView_plist.end(),
               m_host->m_reconView_plist.end(),
               this)
{}

inline PhysicsEvent::~PhysicsEvent() {
   deleteDataVersionStrings();
   deleteCcdbContexts();
   deleteReactions();
   deleteHitViews();
   deleteReconViews();
}

inline std::string PhysicsEvent::getClass() const {
   return *(std::string*)m_parent->getAttribute("class");
}

inline float PhysicsEvent::getVersion() const {
   return *(float*)m_parent->getAttribute("version");
}

inline std::string PhysicsEvent::getXmlns() const {
   return *(std::string*)m_parent->getAttribute("xmlns");
}

inline int PhysicsEvent::getEventNo() const {
   return m_eventNo;
}

inline void PhysicsEvent::setEventNo(int eventNo) {
   m_eventNo = eventNo;
}

inline std::string PhysicsEvent::getMaxOccurs() const {
   return "unbounded";
}

inline int PhysicsEvent::getRunNo() const {
   return m_runNo;
}

inline void PhysicsEvent::setRunNo(int runNo) {
   m_runNo = runNo;
}

inline const void *PhysicsEvent::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "eventNo") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_eventNo;
   }
   if (name == "maxOccurs") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_maxOccurs = getMaxOccurs();
      return &m_maxOccurs;
   }
   if (name == "runNo") {
      if (atype != 0)
         *atype = k_hddm_int;
      return &m_runNo;
   }
   return m_parent->getAttribute(name, atype);
}

inline DataVersionString &PhysicsEvent::getDataVersionString(int index) {
   return m_dataVersionString_list(index);
}

inline DataVersionStringList &PhysicsEvent::getDataVersionStrings() {
   return m_dataVersionString_list;
}

inline DataVersionStringList PhysicsEvent::addDataVersionStrings(int count, int start) {
   return m_dataVersionString_list.add(count,start);
}

inline void PhysicsEvent::deleteDataVersionStrings(int count, int start) {
   m_dataVersionString_list.del(count,start);
}

inline CcdbContext &PhysicsEvent::getCcdbContext(int index) {
   return m_ccdbContext_list(index);
}

inline CcdbContextList &PhysicsEvent::getCcdbContexts() {
   return m_ccdbContext_list;
}

inline CcdbContextList PhysicsEvent::addCcdbContexts(int count, int start) {
   return m_ccdbContext_list.add(count,start);
}

inline void PhysicsEvent::deleteCcdbContexts(int count, int start) {
   m_ccdbContext_list.del(count,start);
}

inline Reaction &PhysicsEvent::getReaction(int index) {
   return m_reaction_list(index);
}

inline ReactionList &PhysicsEvent::getReactions() {
   return m_reaction_list;
}

inline ReactionList PhysicsEvent::addReactions(int count, int start) {
   return m_reaction_list.add(count,start);
}

inline void PhysicsEvent::deleteReactions(int count, int start) {
   m_reaction_list.del(count,start);
}

inline HitView &PhysicsEvent::getHitView() {
   return m_hitView_link.front();
}

inline HitViewList &PhysicsEvent::getHitViews() {
   return m_hitView_link;
}

inline HitViewList PhysicsEvent::addHitViews(int count, int start) {
   return m_hitView_link.add(count,start);
}

inline void PhysicsEvent::deleteHitViews(int count, int start) {
   m_hitView_link.del(count,start);
}

inline ReconView &PhysicsEvent::getReconView() {
   return m_reconView_link.front();
}

inline ReconViewList &PhysicsEvent::getReconViews() {
   return m_reconView_link;
}

inline ReconViewList PhysicsEvent::addReconViews(int count, int start) {
   return m_reconView_link.add(count,start);
}

inline void PhysicsEvent::deleteReconViews(int count, int start) {
   m_reconView_link.del(count,start);
}

inline HDDM::HDDM()
 : HDDM_Element(),
   m_geometry_plist(),
   m_physicsEvent_plist(),
   m_geometry_link(&this->m_geometry_plist,
               this->m_geometry_plist.end(),
               this->m_geometry_plist.end(),
               this),
   m_physicsEvent_list(&this->m_physicsEvent_plist,
               this->m_physicsEvent_plist.end(),
               this->m_physicsEvent_plist.end(),
               this)
{
   m_host = this;
}

inline HDDM::~HDDM() {
   deleteGeometrys();
   deletePhysicsEvents();
}

inline std::string HDDM::getClass() const {
   return "s";
}

inline float HDDM::getVersion() const {
   return 1.0;
}

inline std::string HDDM::getXmlns() const {
   return "http://www.gluex.org/hddm";
}

inline void HDDM::clear() {
   deleteGeometrys();
   deletePhysicsEvents();
}

inline const void *HDDM::getAttribute(const std::string &name,
                                                   hddm_type *atype) const {
   if (name == "class") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_class = getClass();
      return &m_class;
   }
   if (name == "version") {
      if (atype != 0)
         *atype = k_hddm_float;
      static float m_version = getVersion();
      return &m_version;
   }
   if (name == "xmlns") {
      if (atype != 0)
         *atype = k_hddm_unknown;
      static std::string m_xmlns = getXmlns();
      return &m_xmlns;
   }
   return 0;
}

inline Geometry &HDDM::getGeometry() {
   return m_geometry_link.front();
}

inline GeometryList &HDDM::getGeometrys() {
   return m_geometry_link;
}

inline GeometryList HDDM::addGeometrys(int count, int start) {
   return m_geometry_link.add(count,start);
}

inline void HDDM::deleteGeometrys(int count, int start) {
   m_geometry_link.del(count,start);
}

inline PhysicsEvent &HDDM::getPhysicsEvent(int index) {
   return m_physicsEvent_list(index);
}

inline PhysicsEventList &HDDM::getPhysicsEvents() {
   return m_physicsEvent_list;
}

inline PhysicsEventList HDDM::addPhysicsEvents(int count, int start) {
   return m_physicsEvent_list.add(count,start);
}

inline void HDDM::deletePhysicsEvents(int count, int start) {
   m_physicsEvent_list.del(count,start);
}

inline CerenkovList HDDM::getCerenkovs() {
   return CerenkovList(&m_Cerenkov_plist,
                   m_Cerenkov_plist.begin(),
                   m_Cerenkov_plist.end());
}

inline ComptonEMcalList HDDM::getComptonEMcals() {
   return ComptonEMcalList(&m_ComptonEMcal_plist,
                   m_ComptonEMcal_plist.begin(),
                   m_ComptonEMcal_plist.end());
}

inline DIRCList HDDM::getDIRCs() {
   return DIRCList(&m_DIRC_plist,
                   m_DIRC_plist.begin(),
                   m_DIRC_plist.end());
}

inline RFsubsystemList HDDM::getRFsubsystems() {
   return RFsubsystemList(&m_RFsubsystem_plist,
                   m_RFsubsystem_plist.begin(),
                   m_RFsubsystem_plist.end());
}

inline RFtimeList HDDM::getRFtimes() {
   return RFtimeList(&m_RFtime_plist,
                   m_RFtime_plist.begin(),
                   m_RFtime_plist.end());
}

inline RICHList HDDM::getRICHs() {
   return RICHList(&m_RICH_plist,
                   m_RICH_plist.begin(),
                   m_RICH_plist.end());
}

inline TrackingErrorMatrixList HDDM::getTrackingErrorMatrixs() {
   return TrackingErrorMatrixList(&m_TrackingErrorMatrix_plist,
                   m_TrackingErrorMatrix_plist.begin(),
                   m_TrackingErrorMatrix_plist.end());
}

inline BarrelEMcalList HDDM::getBarrelEMcals() {
   return BarrelEMcalList(&m_barrelEMcal_plist,
                   m_barrelEMcal_plist.begin(),
                   m_barrelEMcal_plist.end());
}

inline BcalCellList HDDM::getBcalCells() {
   return BcalCellList(&m_bcalCell_plist,
                   m_bcalCell_plist.begin(),
                   m_bcalCell_plist.end());
}

inline BcalSiPMDownHitList HDDM::getBcalSiPMDownHits() {
   return BcalSiPMDownHitList(&m_bcalSiPMDownHit_plist,
                   m_bcalSiPMDownHit_plist.begin(),
                   m_bcalSiPMDownHit_plist.end());
}

inline BcalSiPMSpectrumList HDDM::getBcalSiPMSpectrums() {
   return BcalSiPMSpectrumList(&m_bcalSiPMSpectrum_plist,
                   m_bcalSiPMSpectrum_plist.begin(),
                   m_bcalSiPMSpectrum_plist.end());
}

inline BcalSiPMTruthList HDDM::getBcalSiPMTruths() {
   return BcalSiPMTruthList(&m_bcalSiPMTruth_plist,
                   m_bcalSiPMTruth_plist.begin(),
                   m_bcalSiPMTruth_plist.end());
}

inline BcalSiPMUpHitList HDDM::getBcalSiPMUpHits() {
   return BcalSiPMUpHitList(&m_bcalSiPMUpHit_plist,
                   m_bcalSiPMUpHit_plist.begin(),
                   m_bcalSiPMUpHit_plist.end());
}

inline BcalTDCDigiHitList HDDM::getBcalTDCDigiHits() {
   return BcalTDCDigiHitList(&m_bcalTDCDigiHit_plist,
                   m_bcalTDCDigiHit_plist.begin(),
                   m_bcalTDCDigiHit_plist.end());
}

inline BcalTDCHitList HDDM::getBcalTDCHits() {
   return BcalTDCHitList(&m_bcalTDCHit_plist,
                   m_bcalTDCHit_plist.begin(),
                   m_bcalTDCHit_plist.end());
}

inline BcalTruthHitList HDDM::getBcalTruthHits() {
   return BcalTruthHitList(&m_bcalTruthHit_plist,
                   m_bcalTruthHit_plist.begin(),
                   m_bcalTruthHit_plist.end());
}

inline BcalTruthIncidentParticleList HDDM::getBcalTruthIncidentParticles() {
   return BcalTruthIncidentParticleList(&m_bcalTruthIncidentParticle_plist,
                   m_bcalTruthIncidentParticle_plist.begin(),
                   m_bcalTruthIncidentParticle_plist.end());
}

inline BcalTruthShowerList HDDM::getBcalTruthShowers() {
   return BcalTruthShowerList(&m_bcalTruthShower_plist,
                   m_bcalTruthShower_plist.begin(),
                   m_bcalTruthShower_plist.end());
}

inline BcalfADCDigiHitList HDDM::getBcalfADCDigiHits() {
   return BcalfADCDigiHitList(&m_bcalfADCDigiHit_plist,
                   m_bcalfADCDigiHit_plist.begin(),
                   m_bcalfADCDigiHit_plist.end());
}

inline BcalfADCHitList HDDM::getBcalfADCHits() {
   return BcalfADCHitList(&m_bcalfADCHit_plist,
                   m_bcalfADCHit_plist.begin(),
                   m_bcalfADCHit_plist.end());
}

inline BcalfADCPeakList HDDM::getBcalfADCPeaks() {
   return BcalfADCPeakList(&m_bcalfADCPeak_plist,
                   m_bcalfADCPeak_plist.begin(),
                   m_bcalfADCPeak_plist.end());
}

inline BeamList HDDM::getBeams() {
   return BeamList(&m_beam_plist,
                   m_beam_plist.begin(),
                   m_beam_plist.end());
}

inline CcalBlockList HDDM::getCcalBlocks() {
   return CcalBlockList(&m_ccalBlock_plist,
                   m_ccalBlock_plist.begin(),
                   m_ccalBlock_plist.end());
}

inline CcalHitList HDDM::getCcalHits() {
   return CcalHitList(&m_ccalHit_plist,
                   m_ccalHit_plist.begin(),
                   m_ccalHit_plist.end());
}

inline CcalTruthHitList HDDM::getCcalTruthHits() {
   return CcalTruthHitList(&m_ccalTruthHit_plist,
                   m_ccalTruthHit_plist.begin(),
                   m_ccalTruthHit_plist.end());
}

inline CcalTruthShowerList HDDM::getCcalTruthShowers() {
   return CcalTruthShowerList(&m_ccalTruthShower_plist,
                   m_ccalTruthShower_plist.begin(),
                   m_ccalTruthShower_plist.end());
}

inline CcdbContextList HDDM::getCcdbContexts() {
   return CcdbContextList(&m_ccdbContext_plist,
                   m_ccdbContext_plist.begin(),
                   m_ccdbContext_plist.end());
}

inline CdcDigihitList HDDM::getCdcDigihits() {
   return CdcDigihitList(&m_cdcDigihit_plist,
                   m_cdcDigihit_plist.begin(),
                   m_cdcDigihit_plist.end());
}

inline CdcHitQFList HDDM::getCdcHitQFs() {
   return CdcHitQFList(&m_cdcHitQF_plist,
                   m_cdcHitQF_plist.begin(),
                   m_cdcHitQF_plist.end());
}

inline CdcStrawList HDDM::getCdcStraws() {
   return CdcStrawList(&m_cdcStraw_plist,
                   m_cdcStraw_plist.begin(),
                   m_cdcStraw_plist.end());
}

inline CdcStrawHitList HDDM::getCdcStrawHits() {
   return CdcStrawHitList(&m_cdcStrawHit_plist,
                   m_cdcStrawHit_plist.begin(),
                   m_cdcStrawHit_plist.end());
}

inline CdcStrawTruthHitList HDDM::getCdcStrawTruthHits() {
   return CdcStrawTruthHitList(&m_cdcStrawTruthHit_plist,
                   m_cdcStrawTruthHit_plist.begin(),
                   m_cdcStrawTruthHit_plist.end());
}

inline CdcTruthPointList HDDM::getCdcTruthPoints() {
   return CdcTruthPointList(&m_cdcTruthPoint_plist,
                   m_cdcTruthPoint_plist.begin(),
                   m_cdcTruthPoint_plist.end());
}

inline CentralDCList HDDM::getCentralDCs() {
   return CentralDCList(&m_centralDC_plist,
                   m_centralDC_plist.begin(),
                   m_centralDC_plist.end());
}

inline CereHitList HDDM::getCereHits() {
   return CereHitList(&m_cereHit_plist,
                   m_cereHit_plist.begin(),
                   m_cereHit_plist.end());
}

inline CereSectionList HDDM::getCereSections() {
   return CereSectionList(&m_cereSection_plist,
                   m_cereSection_plist.begin(),
                   m_cereSection_plist.end());
}

inline CereTruthHitList HDDM::getCereTruthHits() {
   return CereTruthHitList(&m_cereTruthHit_plist,
                   m_cereTruthHit_plist.begin(),
                   m_cereTruthHit_plist.end());
}

inline CereTruthPointList HDDM::getCereTruthPoints() {
   return CereTruthPointList(&m_cereTruthPoint_plist,
                   m_cereTruthPoint_plist.begin(),
                   m_cereTruthPoint_plist.end());
}

inline DataVersionStringList HDDM::getDataVersionStrings() {
   return DataVersionStringList(&m_dataVersionString_plist,
                   m_dataVersionString_plist.begin(),
                   m_dataVersionString_plist.end());
}

inline DircPmtHitList HDDM::getDircPmtHits() {
   return DircPmtHitList(&m_dircPmtHit_plist,
                   m_dircPmtHit_plist.begin(),
                   m_dircPmtHit_plist.end());
}

inline DircTruthBarHitList HDDM::getDircTruthBarHits() {
   return DircTruthBarHitList(&m_dircTruthBarHit_plist,
                   m_dircTruthBarHit_plist.begin(),
                   m_dircTruthBarHit_plist.end());
}

inline DircTruthPmtHitList HDDM::getDircTruthPmtHits() {
   return DircTruthPmtHitList(&m_dircTruthPmtHit_plist,
                   m_dircTruthPmtHit_plist.begin(),
                   m_dircTruthPmtHit_plist.end());
}

inline DircTruthPmtHitExtraList HDDM::getDircTruthPmtHitExtras() {
   return DircTruthPmtHitExtraList(&m_dircTruthPmtHitExtra_plist,
                   m_dircTruthPmtHitExtra_plist.begin(),
                   m_dircTruthPmtHitExtra_plist.end());
}

inline ErrorMatrixList HDDM::getErrorMatrixs() {
   return ErrorMatrixList(&m_errorMatrix_plist,
                   m_errorMatrix_plist.begin(),
                   m_errorMatrix_plist.end());
}

inline FcalBlockList HDDM::getFcalBlocks() {
   return FcalBlockList(&m_fcalBlock_plist,
                   m_fcalBlock_plist.begin(),
                   m_fcalBlock_plist.end());
}

inline FcalDigihitList HDDM::getFcalDigihits() {
   return FcalDigihitList(&m_fcalDigihit_plist,
                   m_fcalDigihit_plist.begin(),
                   m_fcalDigihit_plist.end());
}

inline FcalHitList HDDM::getFcalHits() {
   return FcalHitList(&m_fcalHit_plist,
                   m_fcalHit_plist.begin(),
                   m_fcalHit_plist.end());
}

inline FcalTruthHitList HDDM::getFcalTruthHits() {
   return FcalTruthHitList(&m_fcalTruthHit_plist,
                   m_fcalTruthHit_plist.begin(),
                   m_fcalTruthHit_plist.end());
}

inline FcalTruthLightGuideList HDDM::getFcalTruthLightGuides() {
   return FcalTruthLightGuideList(&m_fcalTruthLightGuide_plist,
                   m_fcalTruthLightGuide_plist.begin(),
                   m_fcalTruthLightGuide_plist.end());
}

inline FcalTruthShowerList HDDM::getFcalTruthShowers() {
   return FcalTruthShowerList(&m_fcalTruthShower_plist,
                   m_fcalTruthShower_plist.begin(),
                   m_fcalTruthShower_plist.end());
}

inline FdcAnodeHitList HDDM::getFdcAnodeHits() {
   return FdcAnodeHitList(&m_fdcAnodeHit_plist,
                   m_fdcAnodeHit_plist.begin(),
                   m_fdcAnodeHit_plist.end());
}

inline FdcAnodeTruthHitList HDDM::getFdcAnodeTruthHits() {
   return FdcAnodeTruthHitList(&m_fdcAnodeTruthHit_plist,
                   m_fdcAnodeTruthHit_plist.begin(),
                   m_fdcAnodeTruthHit_plist.end());
}

inline FdcAnodeWireList HDDM::getFdcAnodeWires() {
   return FdcAnodeWireList(&m_fdcAnodeWire_plist,
                   m_fdcAnodeWire_plist.begin(),
                   m_fdcAnodeWire_plist.end());
}

inline FdcCathodeHitList HDDM::getFdcCathodeHits() {
   return FdcCathodeHitList(&m_fdcCathodeHit_plist,
                   m_fdcCathodeHit_plist.begin(),
                   m_fdcCathodeHit_plist.end());
}

inline FdcCathodeStripList HDDM::getFdcCathodeStrips() {
   return FdcCathodeStripList(&m_fdcCathodeStrip_plist,
                   m_fdcCathodeStrip_plist.begin(),
                   m_fdcCathodeStrip_plist.end());
}

inline FdcCathodeTruthHitList HDDM::getFdcCathodeTruthHits() {
   return FdcCathodeTruthHitList(&m_fdcCathodeTruthHit_plist,
                   m_fdcCathodeTruthHit_plist.begin(),
                   m_fdcCathodeTruthHit_plist.end());
}

inline FdcChamberList HDDM::getFdcChambers() {
   return FdcChamberList(&m_fdcChamber_plist,
                   m_fdcChamber_plist.begin(),
                   m_fdcChamber_plist.end());
}

inline FdcDigihitList HDDM::getFdcDigihits() {
   return FdcDigihitList(&m_fdcDigihit_plist,
                   m_fdcDigihit_plist.begin(),
                   m_fdcDigihit_plist.end());
}

inline FdcTruthPointList HDDM::getFdcTruthPoints() {
   return FdcTruthPointList(&m_fdcTruthPoint_plist,
                   m_fdcTruthPoint_plist.begin(),
                   m_fdcTruthPoint_plist.end());
}

inline FmwpcChamberList HDDM::getFmwpcChambers() {
   return FmwpcChamberList(&m_fmwpcChamber_plist,
                   m_fmwpcChamber_plist.begin(),
                   m_fmwpcChamber_plist.end());
}

inline FmwpcHitList HDDM::getFmwpcHits() {
   return FmwpcHitList(&m_fmwpcHit_plist,
                   m_fmwpcHit_plist.begin(),
                   m_fmwpcHit_plist.end());
}

inline FmwpcTruthHitList HDDM::getFmwpcTruthHits() {
   return FmwpcTruthHitList(&m_fmwpcTruthHit_plist,
                   m_fmwpcTruthHit_plist.begin(),
                   m_fmwpcTruthHit_plist.end());
}

inline FmwpcTruthPointList HDDM::getFmwpcTruthPoints() {
   return FmwpcTruthPointList(&m_fmwpcTruthPoint_plist,
                   m_fmwpcTruthPoint_plist.begin(),
                   m_fmwpcTruthPoint_plist.end());
}

inline ForwardDCList HDDM::getForwardDCs() {
   return ForwardDCList(&m_forwardDC_plist,
                   m_forwardDC_plist.begin(),
                   m_forwardDC_plist.end());
}

inline ForwardEMcalList HDDM::getForwardEMcals() {
   return ForwardEMcalList(&m_forwardEMcal_plist,
                   m_forwardEMcal_plist.begin(),
                   m_forwardEMcal_plist.end());
}

inline ForwardMWPCList HDDM::getForwardMWPCs() {
   return ForwardMWPCList(&m_forwardMWPC_plist,
                   m_forwardMWPC_plist.begin(),
                   m_forwardMWPC_plist.end());
}

inline ForwardTOFList HDDM::getForwardTOFs() {
   return ForwardTOFList(&m_forwardTOF_plist,
                   m_forwardTOF_plist.begin(),
                   m_forwardTOF_plist.end());
}

inline FtofCounterList HDDM::getFtofCounters() {
   return FtofCounterList(&m_ftofCounter_plist,
                   m_ftofCounter_plist.begin(),
                   m_ftofCounter_plist.end());
}

inline FtofDigihitList HDDM::getFtofDigihits() {
   return FtofDigihitList(&m_ftofDigihit_plist,
                   m_ftofDigihit_plist.begin(),
                   m_ftofDigihit_plist.end());
}

inline FtofHitList HDDM::getFtofHits() {
   return FtofHitList(&m_ftofHit_plist,
                   m_ftofHit_plist.begin(),
                   m_ftofHit_plist.end());
}

inline FtofTruthExtraList HDDM::getFtofTruthExtras() {
   return FtofTruthExtraList(&m_ftofTruthExtra_plist,
                   m_ftofTruthExtra_plist.begin(),
                   m_ftofTruthExtra_plist.end());
}

inline FtofTruthHitList HDDM::getFtofTruthHits() {
   return FtofTruthHitList(&m_ftofTruthHit_plist,
                   m_ftofTruthHit_plist.begin(),
                   m_ftofTruthHit_plist.end());
}

inline FtofTruthPointList HDDM::getFtofTruthPoints() {
   return FtofTruthPointList(&m_ftofTruthPoint_plist,
                   m_ftofTruthPoint_plist.begin(),
                   m_ftofTruthPoint_plist.end());
}

inline GapEMcalList HDDM::getGapEMcals() {
   return GapEMcalList(&m_gapEMcal_plist,
                   m_gapEMcal_plist.begin(),
                   m_gapEMcal_plist.end());
}

inline GcalCellList HDDM::getGcalCells() {
   return GcalCellList(&m_gcalCell_plist,
                   m_gcalCell_plist.begin(),
                   m_gcalCell_plist.end());
}

inline GcalHitList HDDM::getGcalHits() {
   return GcalHitList(&m_gcalHit_plist,
                   m_gcalHit_plist.begin(),
                   m_gcalHit_plist.end());
}

inline GcalTruthHitList HDDM::getGcalTruthHits() {
   return GcalTruthHitList(&m_gcalTruthHit_plist,
                   m_gcalTruthHit_plist.begin(),
                   m_gcalTruthHit_plist.end());
}

inline GcalTruthShowerList HDDM::getGcalTruthShowers() {
   return GcalTruthShowerList(&m_gcalTruthShower_plist,
                   m_gcalTruthShower_plist.begin(),
                   m_gcalTruthShower_plist.end());
}

inline HitViewList HDDM::getHitViews() {
   return HitViewList(&m_hitView_plist,
                   m_hitView_plist.begin(),
                   m_hitView_plist.end());
}

inline HodoChannelList HDDM::getHodoChannels() {
   return HodoChannelList(&m_hodoChannel_plist,
                   m_hodoChannel_plist.begin(),
                   m_hodoChannel_plist.end());
}

inline McTrajectoryList HDDM::getMcTrajectorys() {
   return McTrajectoryList(&m_mcTrajectory_plist,
                   m_mcTrajectory_plist.begin(),
                   m_mcTrajectory_plist.end());
}

inline McTrajectoryPointList HDDM::getMcTrajectoryPoints() {
   return McTrajectoryPointList(&m_mcTrajectoryPoint_plist,
                   m_mcTrajectoryPoint_plist.begin(),
                   m_mcTrajectoryPoint_plist.end());
}

inline MicroChannelList HDDM::getMicroChannels() {
   return MicroChannelList(&m_microChannel_plist,
                   m_microChannel_plist.begin(),
                   m_microChannel_plist.end());
}

inline MomentumList HDDM::getMomenta() {
   return MomentumList(&m_momentum_plist,
                   m_momentum_plist.begin(),
                   m_momentum_plist.end());
}

inline OriginList HDDM::getOrigins() {
   return OriginList(&m_origin_plist,
                   m_origin_plist.begin(),
                   m_origin_plist.end());
}

inline PairSpectrometerCoarseList HDDM::getPairSpectrometerCoarses() {
   return PairSpectrometerCoarseList(&m_pairSpectrometerCoarse_plist,
                   m_pairSpectrometerCoarse_plist.begin(),
                   m_pairSpectrometerCoarse_plist.end());
}

inline PairSpectrometerFineList HDDM::getPairSpectrometerFines() {
   return PairSpectrometerFineList(&m_pairSpectrometerFine_plist,
                   m_pairSpectrometerFine_plist.begin(),
                   m_pairSpectrometerFine_plist.end());
}

inline PolarizationList HDDM::getPolarizations() {
   return PolarizationList(&m_polarization_plist,
                   m_polarization_plist.begin(),
                   m_polarization_plist.end());
}

inline ProductList HDDM::getProducts() {
   return ProductList(&m_product_plist,
                   m_product_plist.begin(),
                   m_product_plist.end());
}

inline PropertiesList HDDM::getPropertiesList() {
   return PropertiesList(&m_properties_plist,
                   m_properties_plist.begin(),
                   m_properties_plist.end());
}

inline PsHitList HDDM::getPsHits() {
   return PsHitList(&m_psHit_plist,
                   m_psHit_plist.begin(),
                   m_psHit_plist.end());
}

inline PsTileList HDDM::getPsTiles() {
   return PsTileList(&m_psTile_plist,
                   m_psTile_plist.begin(),
                   m_psTile_plist.end());
}

inline PsTruthHitList HDDM::getPsTruthHits() {
   return PsTruthHitList(&m_psTruthHit_plist,
                   m_psTruthHit_plist.begin(),
                   m_psTruthHit_plist.end());
}

inline PsTruthPointList HDDM::getPsTruthPoints() {
   return PsTruthPointList(&m_psTruthPoint_plist,
                   m_psTruthPoint_plist.begin(),
                   m_psTruthPoint_plist.end());
}

inline PscHitList HDDM::getPscHits() {
   return PscHitList(&m_pscHit_plist,
                   m_pscHit_plist.begin(),
                   m_pscHit_plist.end());
}

inline PscPaddleList HDDM::getPscPaddles() {
   return PscPaddleList(&m_pscPaddle_plist,
                   m_pscPaddle_plist.begin(),
                   m_pscPaddle_plist.end());
}

inline PscTruthHitList HDDM::getPscTruthHits() {
   return PscTruthHitList(&m_pscTruthHit_plist,
                   m_pscTruthHit_plist.begin(),
                   m_pscTruthHit_plist.end());
}

inline PscTruthPointList HDDM::getPscTruthPoints() {
   return PscTruthPointList(&m_pscTruthPoint_plist,
                   m_pscTruthPoint_plist.begin(),
                   m_pscTruthPoint_plist.end());
}

inline RandomList HDDM::getRandoms() {
   return RandomList(&m_random_plist,
                   m_random_plist.begin(),
                   m_random_plist.end());
}

inline ReactionList HDDM::getReactions() {
   return ReactionList(&m_reaction_plist,
                   m_reaction_plist.begin(),
                   m_reaction_plist.end());
}

inline ReconViewList HDDM::getReconViews() {
   return ReconViewList(&m_reconView_plist,
                   m_reconView_plist.begin(),
                   m_reconView_plist.end());
}

inline RichTruthHitList HDDM::getRichTruthHits() {
   return RichTruthHitList(&m_richTruthHit_plist,
                   m_richTruthHit_plist.begin(),
                   m_richTruthHit_plist.end());
}

inline RichTruthPointList HDDM::getRichTruthPoints() {
   return RichTruthPointList(&m_richTruthPoint_plist,
                   m_richTruthPoint_plist.begin(),
                   m_richTruthPoint_plist.end());
}

inline StartCntrList HDDM::getStartCntrs() {
   return StartCntrList(&m_startCntr_plist,
                   m_startCntr_plist.begin(),
                   m_startCntr_plist.end());
}

inline StcDigihitList HDDM::getStcDigihits() {
   return StcDigihitList(&m_stcDigihit_plist,
                   m_stcDigihit_plist.begin(),
                   m_stcDigihit_plist.end());
}

inline StcHitList HDDM::getStcHits() {
   return StcHitList(&m_stcHit_plist,
                   m_stcHit_plist.begin(),
                   m_stcHit_plist.end());
}

inline StcPaddleList HDDM::getStcPaddles() {
   return StcPaddleList(&m_stcPaddle_plist,
                   m_stcPaddle_plist.begin(),
                   m_stcPaddle_plist.end());
}

inline StcTruthHitList HDDM::getStcTruthHits() {
   return StcTruthHitList(&m_stcTruthHit_plist,
                   m_stcTruthHit_plist.begin(),
                   m_stcTruthHit_plist.end());
}

inline StcTruthPointList HDDM::getStcTruthPoints() {
   return StcTruthPointList(&m_stcTruthPoint_plist,
                   m_stcTruthPoint_plist.begin(),
                   m_stcTruthPoint_plist.end());
}

inline TaggerList HDDM::getTaggers() {
   return TaggerList(&m_tagger_plist,
                   m_tagger_plist.begin(),
                   m_tagger_plist.end());
}

inline TaggerHitList HDDM::getTaggerHits() {
   return TaggerHitList(&m_taggerHit_plist,
                   m_taggerHit_plist.begin(),
                   m_taggerHit_plist.end());
}

inline TaggerTruthHitList HDDM::getTaggerTruthHits() {
   return TaggerTruthHitList(&m_taggerTruthHit_plist,
                   m_taggerTruthHit_plist.begin(),
                   m_taggerTruthHit_plist.end());
}

inline TargetList HDDM::getTargets() {
   return TargetList(&m_target_plist,
                   m_target_plist.begin(),
                   m_target_plist.end());
}

inline TpolHitList HDDM::getTpolHits() {
   return TpolHitList(&m_tpolHit_plist,
                   m_tpolHit_plist.begin(),
                   m_tpolHit_plist.end());
}

inline TpolSectorList HDDM::getTpolSectors() {
   return TpolSectorList(&m_tpolSector_plist,
                   m_tpolSector_plist.begin(),
                   m_tpolSector_plist.end());
}

inline TpolTruthHitList HDDM::getTpolTruthHits() {
   return TpolTruthHitList(&m_tpolTruthHit_plist,
                   m_tpolTruthHit_plist.begin(),
                   m_tpolTruthHit_plist.end());
}

inline TpolTruthPointList HDDM::getTpolTruthPoints() {
   return TpolTruthPointList(&m_tpolTruthPoint_plist,
                   m_tpolTruthPoint_plist.begin(),
                   m_tpolTruthPoint_plist.end());
}

inline TrackIDList HDDM::getTrackIDs() {
   return TrackIDList(&m_trackID_plist,
                   m_trackID_plist.begin(),
                   m_trackID_plist.end());
}

inline TracktimebasedList HDDM::getTracktimebaseds() {
   return TracktimebasedList(&m_tracktimebased_plist,
                   m_tracktimebased_plist.begin(),
                   m_tracktimebased_plist.end());
}

inline TripletPolarimeterList HDDM::getTripletPolarimeters() {
   return TripletPolarimeterList(&m_tripletPolarimeter_plist,
                   m_tripletPolarimeter_plist.begin(),
                   m_tripletPolarimeter_plist.end());
}

inline UpstreamEMvetoList HDDM::getUpstreamEMvetos() {
   return UpstreamEMvetoList(&m_upstreamEMveto_plist,
                   m_upstreamEMveto_plist.begin(),
                   m_upstreamEMveto_plist.end());
}

inline UpvHitList HDDM::getUpvHits() {
   return UpvHitList(&m_upvHit_plist,
                   m_upvHit_plist.begin(),
                   m_upvHit_plist.end());
}

inline UpvPaddleList HDDM::getUpvPaddles() {
   return UpvPaddleList(&m_upvPaddle_plist,
                   m_upvPaddle_plist.begin(),
                   m_upvPaddle_plist.end());
}

inline UpvTruthHitList HDDM::getUpvTruthHits() {
   return UpvTruthHitList(&m_upvTruthHit_plist,
                   m_upvTruthHit_plist.begin(),
                   m_upvTruthHit_plist.end());
}

inline UpvTruthShowerList HDDM::getUpvTruthShowers() {
   return UpvTruthShowerList(&m_upvTruthShower_plist,
                   m_upvTruthShower_plist.begin(),
                   m_upvTruthShower_plist.end());
}

inline UserDataList HDDM::getUserDatas() {
   return UserDataList(&m_userData_plist,
                   m_userData_plist.begin(),
                   m_userData_plist.end());
}

inline UserDataFloatList HDDM::getUserDataFloats() {
   return UserDataFloatList(&m_userDataFloat_plist,
                   m_userDataFloat_plist.begin(),
                   m_userDataFloat_plist.end());
}

inline UserDataIntList HDDM::getUserDataInts() {
   return UserDataIntList(&m_userDataInt_plist,
                   m_userDataInt_plist.begin(),
                   m_userDataInt_plist.end());
}

inline VertexList HDDM::getVertices() {
   return VertexList(&m_vertex_plist,
                   m_vertex_plist.begin(),
                   m_vertex_plist.end());
}

inline void Geometry::streamer(istream &istr) {
   *istr.getXDRistream() >> m_md5reconstruction >> m_md5simulation >> m_md5smear;
}

inline void Geometry::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_md5reconstruction << m_md5simulation << m_md5smear;
}

inline void DataVersionString::streamer(istream &istr) {
   *istr.getXDRistream() >> m_text;
}

inline void DataVersionString::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_text;
}

inline void CcdbContext::streamer(istream &istr) {
   *istr.getXDRistream() >> m_text;
}

inline void CcdbContext::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_text;
}

inline void Momentum::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_px >> m_py >> m_pz;
}

inline void Momentum::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_px << m_py << m_pz;
}

inline void Polarization::streamer(istream &istr) {
   *istr.getXDRistream() >> m_Px >> m_Py >> m_Pz;
}

inline void Polarization::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_Px << m_Py << m_Pz;
}

inline void Properties::streamer(istream &istr) {
   *istr.getXDRistream() >> m_charge >> m_mass;
}

inline void Properties::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_charge << m_mass;
}

inline void Beam::streamer(istream &istr) {
   *istr.getXDRistream() >> m_type;
   istr >> m_momentum_link >> m_polarization_link >> m_properties_link;
}

inline void Beam::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_type;
   ostr << m_momentum_link << m_polarization_link << m_properties_link;
}

inline void Target::streamer(istream &istr) {
   *istr.getXDRistream() >> m_type;
   istr >> m_momentum_link >> m_polarization_link >> m_properties_link;
}

inline void Target::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_type;
   ostr << m_momentum_link << m_polarization_link << m_properties_link;
}

inline void Product::streamer(istream &istr) {
   *istr.getXDRistream() >> m_decayVertex >> m_id >> m_mech >> m_parentid >> m_pdgtype >> m_type;
   istr >> m_momentum_link >> m_polarization_link >> m_properties_link;
}

inline void Product::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_decayVertex << m_id << m_mech << m_parentid << m_pdgtype << m_type;
   ostr << m_momentum_link << m_polarization_link << m_properties_link;
}

inline void Origin::streamer(istream &istr) {
   *istr.getXDRistream() >> m_t >> m_vx >> m_vy >> m_vz;
}

inline void Origin::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_t << m_vx << m_vy << m_vz;
}

inline void Vertex::streamer(istream &istr) {
   istr >> m_product_list >> m_origin_link;
}

inline void Vertex::streamer(ostream &ostr) {
   ostr << m_product_list << m_origin_link;
}

inline void Random::streamer(istream &istr) {
   *istr.getXDRistream() >> m_seed1 >> m_seed2 >> m_seed3 >> m_seed4;
}

inline void Random::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_seed1 << m_seed2 << m_seed3 << m_seed4;
}

inline void UserDataFloat::streamer(istream &istr) {
   *istr.getXDRistream() >> m_data >> m_meaning;
}

inline void UserDataFloat::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_data << m_meaning;
}

inline void UserDataInt::streamer(istream &istr) {
   *istr.getXDRistream() >> m_data >> m_meaning;
}

inline void UserDataInt::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_data << m_meaning;
}

inline void UserData::streamer(istream &istr) {
   *istr.getXDRistream() >> m_description;
   istr >> m_userDataFloat_list >> m_userDataInt_list;
}

inline void UserData::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_description;
   ostr << m_userDataFloat_list << m_userDataInt_list;
}

inline void Reaction::streamer(istream &istr) {
   *istr.getXDRistream() >> m_type >> m_weight;
   istr >> m_beam_link >> m_target_link >> m_vertex_list >> m_random_link >> m_userData_list;
}

inline void Reaction::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_type << m_weight;
   ostr << m_beam_link << m_target_link << m_vertex_list << m_random_link << m_userData_list;
}

inline void CdcDigihit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_peakAmp;
}

inline void CdcDigihit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_peakAmp;
}

inline void CdcHitQF::streamer(istream &istr) {
   *istr.getXDRistream() >> m_QF;
}

inline void CdcHitQF::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_QF;
}

inline void CdcStrawHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_q >> m_t;
   istr >> m_cdcDigihit_link >> m_cdcHitQF_link;
}

inline void CdcStrawHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_q << m_t;
   ostr << m_cdcDigihit_link << m_cdcHitQF_link;
}

inline void CdcStrawTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_d >> m_itrack >> m_ptype >> m_q >> m_t;
}

inline void CdcStrawTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_d << m_itrack << m_ptype << m_q << m_t;
}

inline void CdcStraw::streamer(istream &istr) {
   *istr.getXDRistream() >> m_ring >> m_straw;
   istr >> m_cdcStrawHit_list >> m_cdcStrawTruthHit_list;
}

inline void CdcStraw::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_ring << m_straw;
   ostr << m_cdcStrawHit_list << m_cdcStrawTruthHit_list;
}

inline void TrackID::streamer(istream &istr) {
   *istr.getXDRistream() >> m_itrack;
}

inline void TrackID::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_itrack;
}

inline void CdcTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dEdx >> m_dradius >> m_phi >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_r >> m_t >> m_track >> m_z;
   istr >> m_trackID_link;
}

inline void CdcTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dEdx << m_dradius << m_phi << m_primary << m_ptype << m_px << m_py << m_pz << m_r << m_t << m_track << m_z;
   ostr << m_trackID_link;
}

inline void CentralDC::streamer(istream &istr) {
   istr >> m_cdcStraw_list >> m_cdcTruthPoint_list;
}

inline void CentralDC::streamer(ostream &ostr) {
   ostr << m_cdcStraw_list << m_cdcTruthPoint_list;
}

inline void FdcAnodeHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_t;
}

inline void FdcAnodeHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_t;
}

inline void FdcAnodeTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_d >> m_dE >> m_itrack >> m_ptype >> m_t >> m_t_unsmeared;
}

inline void FdcAnodeTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_d << m_dE << m_itrack << m_ptype << m_t << m_t_unsmeared;
}

inline void FdcAnodeWire::streamer(istream &istr) {
   *istr.getXDRistream() >> m_wire;
   istr >> m_fdcAnodeHit_list >> m_fdcAnodeTruthHit_list;
}

inline void FdcAnodeWire::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_wire;
   ostr << m_fdcAnodeHit_list << m_fdcAnodeTruthHit_list;
}

inline void FdcDigihit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_peakAmp;
}

inline void FdcDigihit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_peakAmp;
}

inline void FdcCathodeHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_q >> m_t;
   istr >> m_fdcDigihit_link;
}

inline void FdcCathodeHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_q << m_t;
   ostr << m_fdcDigihit_link;
}

inline void FdcCathodeTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_itrack >> m_ptype >> m_q >> m_t;
}

inline void FdcCathodeTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_itrack << m_ptype << m_q << m_t;
}

inline void FdcCathodeStrip::streamer(istream &istr) {
   *istr.getXDRistream() >> m_plane >> m_strip;
   istr >> m_fdcCathodeHit_list >> m_fdcCathodeTruthHit_list;
}

inline void FdcCathodeStrip::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_plane << m_strip;
   ostr << m_fdcCathodeHit_list << m_fdcCathodeTruthHit_list;
}

inline void FdcTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_dEdx >> m_dradius >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void FdcTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_dEdx << m_dradius << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void FdcChamber::streamer(istream &istr) {
   *istr.getXDRistream() >> m_layer >> m_module;
   istr >> m_fdcAnodeWire_list >> m_fdcCathodeStrip_list >> m_fdcTruthPoint_list;
}

inline void FdcChamber::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_layer << m_module;
   ostr << m_fdcAnodeWire_list << m_fdcCathodeStrip_list << m_fdcTruthPoint_list;
}

inline void ForwardDC::streamer(istream &istr) {
   istr >> m_fdcChamber_list;
}

inline void ForwardDC::streamer(ostream &ostr) {
   ostr << m_fdcChamber_list;
}

inline void StcDigihit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_peakAmp;
}

inline void StcDigihit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_peakAmp;
}

inline void StcHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_t;
   istr >> m_stcDigihit_link;
}

inline void StcHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_t;
   ostr << m_stcDigihit_link;
}

inline void StcTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_itrack >> m_ptype >> m_t;
}

inline void StcTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_itrack << m_ptype << m_t;
}

inline void StcPaddle::streamer(istream &istr) {
   *istr.getXDRistream() >> m_sector;
   istr >> m_stcHit_list >> m_stcTruthHit_list;
}

inline void StcPaddle::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_sector;
   ostr << m_stcHit_list << m_stcTruthHit_list;
}

inline void StcTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_dEdx >> m_phi >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_r >> m_sector >> m_t >> m_track >> m_z;
   istr >> m_trackID_link;
}

inline void StcTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_dEdx << m_phi << m_primary << m_ptype << m_px << m_py << m_pz << m_r << m_sector << m_t << m_track << m_z;
   ostr << m_trackID_link;
}

inline void StartCntr::streamer(istream &istr) {
   istr >> m_stcPaddle_list >> m_stcTruthPoint_list;
}

inline void StartCntr::streamer(ostream &ostr) {
   ostr << m_stcPaddle_list << m_stcTruthPoint_list;
}

inline void BcalSiPMUpHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_t;
}

inline void BcalSiPMUpHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_t;
}

inline void BcalSiPMDownHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_t;
}

inline void BcalSiPMDownHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_t;
}

inline void BcalSiPMTruth::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_incident_id;
}

inline void BcalSiPMTruth::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_incident_id;
}

inline void BcalSiPMSpectrum::streamer(istream &istr) {
   *istr.getXDRistream() >> m_bin_width >> m_end >> m_tstart >> m_vals;
   istr >> m_bcalSiPMTruth_link;
}

inline void BcalSiPMSpectrum::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_bin_width << m_end << m_tstart << m_vals;
   ostr << m_bcalSiPMTruth_link;
}

inline void BcalfADCHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_end >> m_t;
}

inline void BcalfADCHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_end << m_t;
}

inline void BcalfADCPeak::streamer(istream &istr) {
   *istr.getXDRistream() >> m_peakAmp;
}

inline void BcalfADCPeak::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_peakAmp;
}

inline void BcalfADCDigiHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_end >> m_pulse_integral >> m_pulse_time;
   istr >> m_bcalfADCPeak_link;
}

inline void BcalfADCDigiHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_end << m_pulse_integral << m_pulse_time;
   ostr << m_bcalfADCPeak_link;
}

inline void BcalTDCHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_end >> m_t;
}

inline void BcalTDCHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_end << m_t;
}

inline void BcalTDCDigiHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_end >> m_time;
}

inline void BcalTDCDigiHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_end << m_time;
}

inline void BcalTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_incident_id >> m_t >> m_zLocal;
}

inline void BcalTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_incident_id << m_t << m_zLocal;
}

inline void BcalCell::streamer(istream &istr) {
   *istr.getXDRistream() >> m_layer >> m_module >> m_sector;
   istr >> m_bcalSiPMUpHit_list >> m_bcalSiPMDownHit_list >> m_bcalSiPMSpectrum_list >> m_bcalfADCHit_list >> m_bcalfADCDigiHit_list >> m_bcalTDCHit_list >> m_bcalTDCDigiHit_list >> m_bcalTruthHit_list;
}

inline void BcalCell::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_layer << m_module << m_sector;
   ostr << m_bcalSiPMUpHit_list << m_bcalSiPMDownHit_list << m_bcalSiPMSpectrum_list << m_bcalfADCHit_list << m_bcalfADCDigiHit_list << m_bcalTDCHit_list << m_bcalTDCDigiHit_list << m_bcalTruthHit_list;
}

inline void BcalTruthIncidentParticle::streamer(istream &istr) {
   *istr.getXDRistream() >> m_id >> m_ptype >> m_px >> m_py >> m_pz >> m_x >> m_y >> m_z;
}

inline void BcalTruthIncidentParticle::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_id << m_ptype << m_px << m_py << m_pz << m_x << m_y << m_z;
}

inline void BcalTruthShower::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_phi >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_r >> m_t >> m_track >> m_z;
   istr >> m_trackID_link;
}

inline void BcalTruthShower::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_phi << m_primary << m_ptype << m_px << m_py << m_pz << m_r << m_t << m_track << m_z;
   ostr << m_trackID_link;
}

inline void BarrelEMcal::streamer(istream &istr) {
   istr >> m_bcalCell_list >> m_bcalTruthIncidentParticle_list >> m_bcalTruthShower_list;
}

inline void BarrelEMcal::streamer(ostream &ostr) {
   ostr << m_bcalCell_list << m_bcalTruthIncidentParticle_list << m_bcalTruthShower_list;
}

inline void GcalHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_t >> m_zLocal;
}

inline void GcalHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_t << m_zLocal;
}

inline void GcalTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_t >> m_zLocal;
}

inline void GcalTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_t << m_zLocal;
}

inline void GcalCell::streamer(istream &istr) {
   *istr.getXDRistream() >> m_module;
   istr >> m_gcalHit_list >> m_gcalTruthHit_list;
}

inline void GcalCell::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_module;
   ostr << m_gcalHit_list << m_gcalTruthHit_list;
}

inline void GcalTruthShower::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_phi >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_r >> m_t >> m_track >> m_z;
   istr >> m_trackID_link;
}

inline void GcalTruthShower::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_phi << m_primary << m_ptype << m_px << m_py << m_pz << m_r << m_t << m_track << m_z;
   ostr << m_trackID_link;
}

inline void GapEMcal::streamer(istream &istr) {
   istr >> m_gcalCell_list >> m_gcalTruthShower_list;
}

inline void GapEMcal::streamer(ostream &ostr) {
   ostr << m_gcalCell_list << m_gcalTruthShower_list;
}

inline void CereHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_pe >> m_t;
}

inline void CereHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_pe << m_t;
}

inline void CereTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_pe >> m_t;
}

inline void CereTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_pe << m_t;
}

inline void CereSection::streamer(istream &istr) {
   *istr.getXDRistream() >> m_sector;
   istr >> m_cereHit_list >> m_cereTruthHit_list;
}

inline void CereSection::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_sector;
   ostr << m_cereHit_list << m_cereTruthHit_list;
}

inline void CereTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void CereTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void Cerenkov::streamer(istream &istr) {
   istr >> m_cereSection_list >> m_cereTruthPoint_list;
}

inline void Cerenkov::streamer(ostream &ostr) {
   ostr << m_cereSection_list << m_cereTruthPoint_list;
}

inline void RichTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_t >> m_x >> m_y >> m_z;
}

inline void RichTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_t << m_x << m_y << m_z;
}

inline void RichTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void RichTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void RICH::streamer(istream &istr) {
   istr >> m_richTruthHit_list >> m_richTruthPoint_list;
}

inline void RICH::streamer(ostream &ostr) {
   ostr << m_richTruthHit_list << m_richTruthPoint_list;
}

inline void DircTruthBarHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_bar >> m_pdg >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
}

inline void DircTruthBarHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_bar << m_pdg << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
}

inline void DircTruthPmtHitExtra::streamer(istream &istr) {
   *istr.getXDRistream() >> m_bbrefl >> m_path >> m_refl >> m_t_fixed;
}

inline void DircTruthPmtHitExtra::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_bbrefl << m_path << m_refl << m_t_fixed;
}

inline void DircTruthPmtHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_ch >> m_key_bar >> m_t >> m_x >> m_y >> m_z;
   istr >> m_dircTruthPmtHitExtra_list;
}

inline void DircTruthPmtHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_ch << m_key_bar << m_t << m_x << m_y << m_z;
   ostr << m_dircTruthPmtHitExtra_list;
}

inline void DircPmtHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_ch >> m_t;
}

inline void DircPmtHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_ch << m_t;
}

inline void DIRC::streamer(istream &istr) {
   istr >> m_dircTruthBarHit_list >> m_dircTruthPmtHit_list >> m_dircPmtHit_list;
}

inline void DIRC::streamer(ostream &ostr) {
   ostr << m_dircTruthBarHit_list << m_dircTruthPmtHit_list << m_dircPmtHit_list;
}

inline void FtofDigihit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_peakAmp;
}

inline void FtofDigihit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_peakAmp;
}

inline void FtofHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_end >> m_t;
   istr >> m_ftofDigihit_link;
}

inline void FtofHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_end << m_t;
   ostr << m_ftofDigihit_link;
}

inline void FtofTruthExtra::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_dist >> m_itrack >> m_ptype >> m_px >> m_py >> m_pz >> m_x >> m_y >> m_z;
}

inline void FtofTruthExtra::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_dist << m_itrack << m_ptype << m_px << m_py << m_pz << m_x << m_y << m_z;
}

inline void FtofTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_end >> m_t;
   istr >> m_ftofTruthExtra_list;
}

inline void FtofTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_end << m_t;
   ostr << m_ftofTruthExtra_list;
}

inline void FtofCounter::streamer(istream &istr) {
   *istr.getXDRistream() >> m_bar >> m_plane;
   istr >> m_ftofHit_list >> m_ftofTruthHit_list;
}

inline void FtofCounter::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_bar << m_plane;
   ostr << m_ftofHit_list << m_ftofTruthHit_list;
}

inline void FtofTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void FtofTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void ForwardTOF::streamer(istream &istr) {
   istr >> m_ftofCounter_list >> m_ftofTruthPoint_list;
}

inline void ForwardTOF::streamer(ostream &ostr) {
   ostr << m_ftofCounter_list << m_ftofTruthPoint_list;
}

inline void FcalDigihit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_integralOverPeak;
}

inline void FcalDigihit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_integralOverPeak;
}

inline void FcalHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_t;
   istr >> m_fcalDigihit_link;
}

inline void FcalHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_t;
   ostr << m_fcalDigihit_link;
}

inline void FcalTruthLightGuide::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_t;
}

inline void FcalTruthLightGuide::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_t;
}

inline void FcalTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_t;
   istr >> m_fcalTruthLightGuide_list;
}

inline void FcalTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_t;
   ostr << m_fcalTruthLightGuide_list;
}

inline void FcalBlock::streamer(istream &istr) {
   *istr.getXDRistream() >> m_column >> m_row;
   istr >> m_fcalHit_list >> m_fcalTruthHit_list;
}

inline void FcalBlock::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_column << m_row;
   ostr << m_fcalHit_list << m_fcalTruthHit_list;
}

inline void FcalTruthShower::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void FcalTruthShower::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void ForwardEMcal::streamer(istream &istr) {
   istr >> m_fcalBlock_list >> m_fcalTruthShower_list;
}

inline void ForwardEMcal::streamer(ostream &ostr) {
   ostr << m_fcalBlock_list << m_fcalTruthShower_list;
}

inline void CcalHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_t;
}

inline void CcalHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_t;
}

inline void CcalTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_t;
}

inline void CcalTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_t;
}

inline void CcalBlock::streamer(istream &istr) {
   *istr.getXDRistream() >> m_column >> m_row;
   istr >> m_ccalHit_list >> m_ccalTruthHit_list;
}

inline void CcalBlock::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_column << m_row;
   ostr << m_ccalHit_list << m_ccalTruthHit_list;
}

inline void CcalTruthShower::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void CcalTruthShower::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void ComptonEMcal::streamer(istream &istr) {
   istr >> m_ccalBlock_list >> m_ccalTruthShower_list;
}

inline void ComptonEMcal::streamer(ostream &ostr) {
   ostr << m_ccalBlock_list << m_ccalTruthShower_list;
}

inline void UpvHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_end >> m_t;
}

inline void UpvHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_end << m_t;
}

inline void UpvTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_end >> m_t >> m_xlocal;
}

inline void UpvTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_end << m_t << m_xlocal;
}

inline void UpvPaddle::streamer(istream &istr) {
   *istr.getXDRistream() >> m_layer >> m_row;
   istr >> m_upvHit_list >> m_upvTruthHit_list;
}

inline void UpvPaddle::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_layer << m_row;
   ostr << m_upvHit_list << m_upvTruthHit_list;
}

inline void UpvTruthShower::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void UpvTruthShower::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void UpstreamEMveto::streamer(istream &istr) {
   istr >> m_upvPaddle_list >> m_upvTruthShower_list;
}

inline void UpstreamEMveto::streamer(ostream &ostr) {
   ostr << m_upvPaddle_list << m_upvTruthShower_list;
}

inline void TaggerHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_npe >> m_t >> m_tADC;
}

inline void TaggerHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_npe << m_t << m_tADC;
}

inline void TaggerTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_bg >> m_dE >> m_t;
}

inline void TaggerTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_bg << m_dE << m_t;
}

inline void MicroChannel::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_column >> m_row;
   istr >> m_taggerHit_list >> m_taggerTruthHit_list;
}

inline void MicroChannel::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_column << m_row;
   ostr << m_taggerHit_list << m_taggerTruthHit_list;
}

inline void HodoChannel::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_counterId;
   istr >> m_taggerHit_list >> m_taggerTruthHit_list;
}

inline void HodoChannel::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_counterId;
   ostr << m_taggerHit_list << m_taggerTruthHit_list;
}

inline void Tagger::streamer(istream &istr) {
   istr >> m_microChannel_list >> m_hodoChannel_list;
}

inline void Tagger::streamer(ostream &ostr) {
   ostr << m_microChannel_list << m_hodoChannel_list;
}

inline void PsHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_t;
}

inline void PsHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_t;
}

inline void PsTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_itrack >> m_ptype >> m_t;
}

inline void PsTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_itrack << m_ptype << m_t;
}

inline void PsTile::streamer(istream &istr) {
   *istr.getXDRistream() >> m_arm >> m_column;
   istr >> m_psHit_list >> m_psTruthHit_list;
}

inline void PsTile::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_arm << m_column;
   ostr << m_psHit_list << m_psTruthHit_list;
}

inline void PsTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_arm >> m_column >> m_dEdx >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void PsTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_arm << m_column << m_dEdx << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void PairSpectrometerFine::streamer(istream &istr) {
   istr >> m_psTile_list >> m_psTruthPoint_list;
}

inline void PairSpectrometerFine::streamer(ostream &ostr) {
   ostr << m_psTile_list << m_psTruthPoint_list;
}

inline void PscHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_t;
}

inline void PscHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_t;
}

inline void PscTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_itrack >> m_ptype >> m_t;
}

inline void PscTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_itrack << m_ptype << m_t;
}

inline void PscPaddle::streamer(istream &istr) {
   *istr.getXDRistream() >> m_arm >> m_module;
   istr >> m_pscHit_list >> m_pscTruthHit_list;
}

inline void PscPaddle::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_arm << m_module;
   ostr << m_pscHit_list << m_pscTruthHit_list;
}

inline void PscTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_arm >> m_dEdx >> m_module >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void PscTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_arm << m_dEdx << m_module << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void PairSpectrometerCoarse::streamer(istream &istr) {
   istr >> m_pscPaddle_list >> m_pscTruthPoint_list;
}

inline void PairSpectrometerCoarse::streamer(ostream &ostr) {
   ostr << m_pscPaddle_list << m_pscTruthPoint_list;
}

inline void TpolHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_t;
}

inline void TpolHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_t;
}

inline void TpolTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_itrack >> m_ptype >> m_t;
}

inline void TpolTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_itrack << m_ptype << m_t;
}

inline void TpolSector::streamer(istream &istr) {
   *istr.getXDRistream() >> m_ring >> m_sector;
   istr >> m_tpolHit_list >> m_tpolTruthHit_list;
}

inline void TpolSector::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_ring << m_sector;
   ostr << m_tpolHit_list << m_tpolTruthHit_list;
}

inline void TpolTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_dEdx >> m_phi >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_r >> m_t >> m_track;
   istr >> m_trackID_link;
}

inline void TpolTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_dEdx << m_phi << m_primary << m_ptype << m_px << m_py << m_pz << m_r << m_t << m_track;
   ostr << m_trackID_link;
}

inline void TripletPolarimeter::streamer(istream &istr) {
   istr >> m_tpolSector_list >> m_tpolTruthPoint_list;
}

inline void TripletPolarimeter::streamer(ostream &ostr) {
   ostr << m_tpolSector_list << m_tpolTruthPoint_list;
}

inline void McTrajectoryPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_dE >> m_mech >> m_part >> m_primary_track >> m_px >> m_py >> m_pz >> m_radlen >> m_step >> m_t >> m_track >> m_x >> m_y >> m_z;
}

inline void McTrajectoryPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_dE << m_mech << m_part << m_primary_track << m_px << m_py << m_pz << m_radlen << m_step << m_t << m_track << m_x << m_y << m_z;
}

inline void McTrajectory::streamer(istream &istr) {
   istr >> m_mcTrajectoryPoint_list;
}

inline void McTrajectory::streamer(ostream &ostr) {
   ostr << m_mcTrajectoryPoint_list;
}

inline void RFsubsystem::streamer(istream &istr) {
   *istr.getXDRistream() >> m_jtag >> m_tsync;
}

inline void RFsubsystem::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_jtag << m_tsync;
}

inline void RFtime::streamer(istream &istr) {
   *istr.getXDRistream() >> m_jtag >> m_tsync;
   istr >> m_RFsubsystem_list;
}

inline void RFtime::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_jtag << m_tsync;
   ostr << m_RFsubsystem_list;
}

inline void FmwpcTruthHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_dx >> m_t;
}

inline void FmwpcTruthHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_dx << m_t;
}

inline void FmwpcHit::streamer(istream &istr) {
   *istr.getXDRistream() >> m_dE >> m_t;
}

inline void FmwpcHit::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_dE << m_t;
}

inline void FmwpcChamber::streamer(istream &istr) {
   *istr.getXDRistream() >> m_layer >> m_wire;
   istr >> m_fmwpcTruthHit_list >> m_fmwpcHit_list;
}

inline void FmwpcChamber::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_layer << m_wire;
   ostr << m_fmwpcTruthHit_list << m_fmwpcHit_list;
}

inline void FmwpcTruthPoint::streamer(istream &istr) {
   *istr.getXDRistream() >> m_E >> m_primary >> m_ptype >> m_px >> m_py >> m_pz >> m_t >> m_track >> m_x >> m_y >> m_z;
   istr >> m_trackID_link;
}

inline void FmwpcTruthPoint::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_E << m_primary << m_ptype << m_px << m_py << m_pz << m_t << m_track << m_x << m_y << m_z;
   ostr << m_trackID_link;
}

inline void ForwardMWPC::streamer(istream &istr) {
   istr >> m_fmwpcChamber_list >> m_fmwpcTruthPoint_list;
}

inline void ForwardMWPC::streamer(ostream &ostr) {
   ostr << m_fmwpcChamber_list << m_fmwpcTruthPoint_list;
}

inline void HitView::streamer(istream &istr) {
   istr >> m_centralDC_link >> m_forwardDC_link >> m_startCntr_link >> m_barrelEMcal_link >> m_gapEMcal_link >> m_Cerenkov_link >> m_RICH_link >> m_DIRC_link >> m_forwardTOF_link >> m_forwardEMcal_link >> m_ComptonEMcal_link >> m_upstreamEMveto_link >> m_tagger_link >> m_pairSpectrometerFine_link >> m_pairSpectrometerCoarse_link >> m_tripletPolarimeter_link >> m_mcTrajectory_link >> m_RFtime_link >> m_forwardMWPC_link;
}

inline void HitView::streamer(ostream &ostr) {
   ostr << m_centralDC_link << m_forwardDC_link << m_startCntr_link << m_barrelEMcal_link << m_gapEMcal_link << m_Cerenkov_link << m_RICH_link << m_DIRC_link << m_forwardTOF_link << m_forwardEMcal_link << m_ComptonEMcal_link << m_upstreamEMveto_link << m_tagger_link << m_pairSpectrometerFine_link << m_pairSpectrometerCoarse_link << m_tripletPolarimeter_link << m_mcTrajectory_link << m_RFtime_link << m_forwardMWPC_link;
}

inline void ErrorMatrix::streamer(istream &istr) {
   *istr.getXDRistream() >> m_Ncols >> m_Nrows >> m_type >> m_vals;
}

inline void ErrorMatrix::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_Ncols << m_Nrows << m_type << m_vals;
}

inline void TrackingErrorMatrix::streamer(istream &istr) {
   *istr.getXDRistream() >> m_Ncols >> m_Nrows >> m_type >> m_vals;
}

inline void TrackingErrorMatrix::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_Ncols << m_Nrows << m_type << m_vals;
}

inline void Tracktimebased::streamer(istream &istr) {
   *istr.getXDRistream() >> m_FOM >> m_Ndof >> m_candidateid >> m_chisq >> m_id >> m_trackid;
   istr >> m_momentum_link >> m_properties_link >> m_origin_link >> m_errorMatrix_link >> m_TrackingErrorMatrix_link;
}

inline void Tracktimebased::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_FOM << m_Ndof << m_candidateid << m_chisq << m_id << m_trackid;
   ostr << m_momentum_link << m_properties_link << m_origin_link << m_errorMatrix_link << m_TrackingErrorMatrix_link;
}

inline void ReconView::streamer(istream &istr) {
   istr >> m_tracktimebased_list;
}

inline void ReconView::streamer(ostream &ostr) {
   ostr << m_tracktimebased_list;
}

inline void PhysicsEvent::streamer(istream &istr) {
   *istr.getXDRistream() >> m_eventNo >> m_runNo;
   istr >> m_dataVersionString_list >> m_ccdbContext_list >> m_reaction_list >> m_hitView_link >> m_reconView_link;
}

inline void PhysicsEvent::streamer(ostream &ostr) {
   *ostr.getXDRostream() << m_eventNo << m_runNo;
   ostr << m_dataVersionString_list << m_ccdbContext_list << m_reaction_list << m_hitView_link << m_reconView_link;
}

inline void HDDM::streamer(istream &istr) {
   istr >> m_geometry_link >> m_physicsEvent_list;
}

inline void HDDM::streamer(ostream &ostr) {
   ostr << m_geometry_link << m_physicsEvent_list;
}

inline std::string HDDM::DocumentString() {
   return std::string(
"<HDDM class=\"s\" version=\"1.0\" xmlns=\"http://www.gluex.org/hddm\">\n"
"  <geometry maxOccurs=\"1\" md5reconstruction=\"string\" md5simulation=\"string\" md5smear=\"string\" minOccurs=\"0\" />\n"
"  <physicsEvent eventNo=\"int\" maxOccurs=\"unbounded\" runNo=\"int\">\n"
"    <dataVersionString maxOccurs=\"unbounded\" minOccurs=\"0\" text=\"string\" />\n"
"    <ccdbContext maxOccurs=\"unbounded\" minOccurs=\"0\" text=\"string\" />\n"
"    <reaction maxOccurs=\"unbounded\" minOccurs=\"0\" type=\"int\" weight=\"float\">\n"
"      <beam minOccurs=\"0\" type=\"Particle_t\">\n"
"        <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"        <polarization Px=\"float\" Py=\"float\" Pz=\"float\" minOccurs=\"0\" />\n"
"        <properties charge=\"int\" mass=\"float\" />\n"
"      </beam>\n"
"      <target minOccurs=\"0\" type=\"Particle_t\">\n"
"        <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"        <polarization Px=\"float\" Py=\"float\" Pz=\"float\" minOccurs=\"0\" />\n"
"        <properties charge=\"int\" mass=\"float\" />\n"
"      </target>\n"
"      <vertex maxOccurs=\"unbounded\">\n"
"        <product decayVertex=\"int\" id=\"int\" maxOccurs=\"unbounded\" mech=\"int\" parentid=\"int\" pdgtype=\"int\" type=\"Particle_t\">\n"
"          <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"          <polarization Px=\"float\" Py=\"float\" Pz=\"float\" minOccurs=\"0\" />\n"
"          <properties charge=\"int\" mass=\"float\" minOccurs=\"0\" />\n"
"        </product>\n"
"        <origin t=\"float\" vx=\"float\" vy=\"float\" vz=\"float\" />\n"
"      </vertex>\n"
"      <random maxOccurs=\"1\" minOccurs=\"0\" seed1=\"int\" seed2=\"int\" seed3=\"int\" seed4=\"int\" />\n"
"      <userData description=\"string\" maxOccurs=\"unbounded\" minOccurs=\"0\">\n"
"        <userDataFloat data=\"float\" maxOccurs=\"unbounded\" meaning=\"string\" minOccurs=\"0\" />\n"
"        <userDataInt data=\"int\" maxOccurs=\"unbounded\" meaning=\"string\" minOccurs=\"0\" />\n"
"      </userData>\n"
"    </reaction>\n"
"    <hitView minOccurs=\"0\" version=\"2.0\">\n"
"      <centralDC minOccurs=\"0\">\n"
"        <cdcStraw maxOccurs=\"unbounded\" minOccurs=\"0\" ring=\"int\" straw=\"int\">\n"
"          <cdcStrawHit maxOccurs=\"unbounded\" q=\"float\" t=\"float\">\n"
"            <cdcDigihit minOccurs=\"0\" peakAmp=\"float\" />\n"
"            <cdcHitQF QF=\"float\" minOccurs=\"0\" />\n"
"          </cdcStrawHit>\n"
"          <cdcStrawTruthHit d=\"float\" itrack=\"int\" maxOccurs=\"unbounded\" ptype=\"int\" q=\"float\" t=\"float\" />\n"
"        </cdcStraw>\n"
"        <cdcTruthPoint dEdx=\"float\" dradius=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" t=\"float\" track=\"int\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </cdcTruthPoint>\n"
"      </centralDC>\n"
"      <forwardDC minOccurs=\"0\">\n"
"        <fdcChamber layer=\"int\" maxOccurs=\"unbounded\" module=\"int\">\n"
"          <fdcAnodeWire maxOccurs=\"unbounded\" minOccurs=\"0\" wire=\"int\">\n"
"            <fdcAnodeHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"            <fdcAnodeTruthHit d=\"float\" dE=\"float\" itrack=\"int\" maxOccurs=\"unbounded\" ptype=\"int\" t=\"float\" t_unsmeared=\"float\" />\n"
"          </fdcAnodeWire>\n"
"          <fdcCathodeStrip maxOccurs=\"unbounded\" minOccurs=\"0\" plane=\"int\" strip=\"int\">\n"
"            <fdcCathodeHit maxOccurs=\"unbounded\" q=\"float\" t=\"float\">\n"
"              <fdcDigihit minOccurs=\"0\" peakAmp=\"float\" />\n"
"            </fdcCathodeHit>\n"
"            <fdcCathodeTruthHit itrack=\"int\" maxOccurs=\"unbounded\" ptype=\"int\" q=\"float\" t=\"float\" />\n"
"          </fdcCathodeStrip>\n"
"          <fdcTruthPoint E=\"float\" dEdx=\"float\" dradius=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"            <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"          </fdcTruthPoint>\n"
"        </fdcChamber>\n"
"      </forwardDC>\n"
"      <startCntr minOccurs=\"0\">\n"
"        <stcPaddle maxOccurs=\"unbounded\" minOccurs=\"0\" sector=\"int\">\n"
"          <stcHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\">\n"
"            <stcDigihit minOccurs=\"0\" peakAmp=\"float\" />\n"
"          </stcHit>\n"
"          <stcTruthHit dE=\"float\" itrack=\"int\" maxOccurs=\"unbounded\" ptype=\"int\" t=\"float\" />\n"
"        </stcPaddle>\n"
"        <stcTruthPoint E=\"float\" dEdx=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" sector=\"int\" t=\"float\" track=\"int\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </stcTruthPoint>\n"
"      </startCntr>\n"
"      <barrelEMcal minOccurs=\"0\">\n"
"        <bcalCell layer=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" module=\"int\" sector=\"int\">\n"
"          <bcalSiPMUpHit E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"          <bcalSiPMDownHit E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"          <bcalSiPMSpectrum bin_width=\"float\" end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" tstart=\"float\" vals=\"string\">\n"
"            <bcalSiPMTruth E=\"float\" incident_id=\"int\" minOccurs=\"0\" />\n"
"          </bcalSiPMSpectrum>\n"
"          <bcalfADCHit E=\"float\" end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"          <bcalfADCDigiHit end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" pulse_integral=\"int\" pulse_time=\"int\">\n"
"            <bcalfADCPeak minOccurs=\"0\" peakAmp=\"float\" />\n"
"          </bcalfADCDigiHit>\n"
"          <bcalTDCHit end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"          <bcalTDCDigiHit end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" time=\"float\" />\n"
"          <bcalTruthHit E=\"float\" incident_id=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" zLocal=\"float\" />\n"
"        </bcalCell>\n"
"        <bcalTruthIncidentParticle id=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" x=\"float\" y=\"float\" z=\"float\" />\n"
"        <bcalTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" t=\"float\" track=\"int\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </bcalTruthShower>\n"
"      </barrelEMcal>\n"
"      <gapEMcal minOccurs=\"0\">\n"
"        <gcalCell maxOccurs=\"48\" minOccurs=\"0\" module=\"int\">\n"
"          <gcalHit E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" zLocal=\"float\" />\n"
"          <gcalTruthHit E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" zLocal=\"float\" />\n"
"        </gcalCell>\n"
"        <gcalTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" t=\"float\" track=\"int\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </gcalTruthShower>\n"
"      </gapEMcal>\n"
"      <Cerenkov minOccurs=\"0\">\n"
"        <cereSection maxOccurs=\"unbounded\" minOccurs=\"0\" sector=\"int\">\n"
"          <cereHit maxOccurs=\"unbounded\" pe=\"float\" t=\"float\" />\n"
"          <cereTruthHit maxOccurs=\"unbounded\" pe=\"float\" t=\"float\" />\n"
"        </cereSection>\n"
"        <cereTruthPoint E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </cereTruthPoint>\n"
"      </Cerenkov>\n"
"      <RICH minOccurs=\"0\">\n"
"        <richTruthHit maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" x=\"float\" y=\"float\" z=\"float\" />\n"
"        <richTruthPoint E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </richTruthPoint>\n"
"      </RICH>\n"
"      <DIRC minOccurs=\"0\">\n"
"        <dircTruthBarHit E=\"float\" bar=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" pdg=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"        <dircTruthPmtHit E=\"float\" ch=\"int\" key_bar=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <dircTruthPmtHitExtra bbrefl=\"boolean\" maxOccurs=\"unbounded\" minOccurs=\"0\" path=\"long\" refl=\"int\" t_fixed=\"float\" />\n"
"        </dircTruthPmtHit>\n"
"        <dircPmtHit ch=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"      </DIRC>\n"
"      <forwardTOF minOccurs=\"0\">\n"
"        <ftofCounter bar=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" plane=\"int\">\n"
"          <ftofHit dE=\"float\" end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\">\n"
"            <ftofDigihit minOccurs=\"0\" peakAmp=\"float\" />\n"
"          </ftofHit>\n"
"          <ftofTruthHit dE=\"float\" end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\">\n"
"            <ftofTruthExtra E=\"float\" dist=\"float\" itrack=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" x=\"float\" y=\"float\" z=\"float\" />\n"
"          </ftofTruthHit>\n"
"        </ftofCounter>\n"
"        <ftofTruthPoint E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </ftofTruthPoint>\n"
"      </forwardTOF>\n"
"      <forwardEMcal minOccurs=\"0\">\n"
"        <fcalBlock column=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" row=\"int\">\n"
"          <fcalHit E=\"float\" maxOccurs=\"unbounded\" t=\"float\">\n"
"            <fcalDigihit integralOverPeak=\"float\" minOccurs=\"0\" />\n"
"          </fcalHit>\n"
"          <fcalTruthHit E=\"float\" maxOccurs=\"unbounded\" t=\"float\">\n"
"            <fcalTruthLightGuide dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          </fcalTruthHit>\n"
"        </fcalBlock>\n"
"        <fcalTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </fcalTruthShower>\n"
"      </forwardEMcal>\n"
"      <ComptonEMcal minOccurs=\"0\">\n"
"        <ccalBlock column=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" row=\"int\">\n"
"          <ccalHit E=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          <ccalTruthHit E=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"        </ccalBlock>\n"
"        <ccalTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </ccalTruthShower>\n"
"      </ComptonEMcal>\n"
"      <upstreamEMveto minOccurs=\"0\">\n"
"        <upvPaddle layer=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" row=\"int\">\n"
"          <upvHit E=\"float\" end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"          <upvTruthHit E=\"float\" end=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" xlocal=\"float\" />\n"
"        </upvPaddle>\n"
"        <upvTruthShower E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </upvTruthShower>\n"
"      </upstreamEMveto>\n"
"      <tagger minOccurs=\"0\">\n"
"        <microChannel E=\"float\" column=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" row=\"int\">\n"
"          <taggerHit maxOccurs=\"unbounded\" minOccurs=\"0\" npe=\"int\" t=\"float\" tADC=\"float\" />\n"
"          <taggerTruthHit E=\"float\" bg=\"int\" dE=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"        </microChannel>\n"
"        <hodoChannel E=\"float\" counterId=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\">\n"
"          <taggerHit maxOccurs=\"unbounded\" minOccurs=\"0\" npe=\"int\" t=\"float\" tADC=\"float\" />\n"
"          <taggerTruthHit E=\"float\" bg=\"int\" dE=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" t=\"float\" />\n"
"        </hodoChannel>\n"
"      </tagger>\n"
"      <pairSpectrometerFine minOccurs=\"0\">\n"
"        <psTile arm=\"int\" column=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\">\n"
"          <psHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          <psTruthHit dE=\"float\" itrack=\"int\" maxOccurs=\"unbounded\" ptype=\"int\" t=\"float\" />\n"
"        </psTile>\n"
"        <psTruthPoint E=\"float\" arm=\"int\" column=\"int\" dEdx=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </psTruthPoint>\n"
"      </pairSpectrometerFine>\n"
"      <pairSpectrometerCoarse minOccurs=\"0\">\n"
"        <pscPaddle arm=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" module=\"int\">\n"
"          <pscHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          <pscTruthHit dE=\"float\" itrack=\"int\" maxOccurs=\"unbounded\" ptype=\"int\" t=\"float\" />\n"
"        </pscPaddle>\n"
"        <pscTruthPoint E=\"float\" arm=\"int\" dEdx=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" module=\"int\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </pscTruthPoint>\n"
"      </pairSpectrometerCoarse>\n"
"      <tripletPolarimeter minOccurs=\"0\">\n"
"        <tpolSector maxOccurs=\"unbounded\" minOccurs=\"0\" ring=\"int\" sector=\"int\">\n"
"          <tpolHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          <tpolTruthHit dE=\"float\" itrack=\"int\" maxOccurs=\"unbounded\" ptype=\"int\" t=\"float\" />\n"
"        </tpolSector>\n"
"        <tpolTruthPoint E=\"float\" dEdx=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" phi=\"float\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" r=\"float\" t=\"float\" track=\"int\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </tpolTruthPoint>\n"
"      </tripletPolarimeter>\n"
"      <mcTrajectory minOccurs=\"0\">\n"
"        <mcTrajectoryPoint E=\"float\" dE=\"float\" maxOccurs=\"unbounded\" mech=\"int\" minOccurs=\"0\" part=\"int\" primary_track=\"int\" px=\"float\" py=\"float\" pz=\"float\" radlen=\"float\" step=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\" />\n"
"      </mcTrajectory>\n"
"      <RFtime jtag=\"string\" minOccurs=\"0\" tsync=\"float\" tunit=\"ns\">\n"
"        <RFsubsystem jtag=\"string\" maxOccurs=\"unbounded\" minOccurs=\"0\" tsync=\"float\" tunit=\"ns\" />\n"
"      </RFtime>\n"
"      <forwardMWPC minOccurs=\"0\">\n"
"        <fmwpcChamber layer=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" wire=\"int\">\n"
"          <fmwpcTruthHit dE=\"float\" dx=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"          <fmwpcHit dE=\"float\" maxOccurs=\"unbounded\" t=\"float\" />\n"
"        </fmwpcChamber>\n"
"        <fmwpcTruthPoint E=\"float\" maxOccurs=\"unbounded\" minOccurs=\"0\" primary=\"boolean\" ptype=\"int\" px=\"float\" py=\"float\" pz=\"float\" t=\"float\" track=\"int\" x=\"float\" y=\"float\" z=\"float\">\n"
"          <trackID itrack=\"int\" minOccurs=\"0\" />\n"
"        </fmwpcTruthPoint>\n"
"      </forwardMWPC>\n"
"    </hitView>\n"
"    <reconView minOccurs=\"0\" version=\"1.0\">\n"
"      <tracktimebased FOM=\"float\" Ndof=\"int\" candidateid=\"int\" chisq=\"float\" id=\"int\" maxOccurs=\"unbounded\" minOccurs=\"0\" trackid=\"int\">\n"
"        <momentum E=\"float\" px=\"float\" py=\"float\" pz=\"float\" />\n"
"        <properties charge=\"int\" mass=\"float\" />\n"
"        <origin t=\"float\" vx=\"float\" vy=\"float\" vz=\"float\" />\n"
"        <errorMatrix Ncols=\"int\" Nrows=\"int\" type=\"string\" vals=\"string\" />\n"
"        <TrackingErrorMatrix Ncols=\"int\" Nrows=\"int\" type=\"string\" vals=\"string\" />\n"
"      </tracktimebased>\n"
"    </reconView>\n"
"  </physicsEvent>\n"
"</HDDM>\n"
   );
}

}
#endif /* SAW_s_HDDM */
