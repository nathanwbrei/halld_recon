/*
 * hddm_r.cpp - DO NOT EDIT THIS FILE
 *
 * This file was generated automatically by hddm-cpp from the file
 * libraries/HDDM/rest.xml

 * This c++ source implements the methods for the classes 
 * described in the data model (from libraries/HDDM/rest.xml). 
 *
 * The hddm data model tool set was written by
 * Richard Jones, University of Connecticut.
 *
 * For more information see the following web site
 *
 * http://zeus.phys.uconn.edu/halld/datamodel/doc
 */

#include <sstream>
#include "hddm_r.hpp"

#ifndef _FILE_OFFSET_BITS
# define _FILE_OFFSET_BITS 64
#endif

using namespace hddm_r;

std::atomic<int> threads::next_unique_ID(0);
thread_local int threads::ID(0);

static int tags_match(const std::string &a, const std::string &b)
{
   if (a == b) {
      return true;
   }
   else if (a.find("<HDDM ") == 0 && b.find("<HDDM ") == 0) {
      return true;
   }
   else {
      int len = a.length();
      int ia=0;
      int ib=0;
      for (; a[ia] == b[ib]; ++ia, ++ib, --len) {}
      for (; a[ia] == ' '; ++ia, --len) {}
      for (; a[ia] == '/'; ++ia, --len) {}
      for (; b[ib] == ' '; ++ib) {}
      for (; b[ib] == '/'; ++ib) {}
      return (a.substr(ia) == b.substr(ib));
   }
}

std::string Comment::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "comment"
        << " text=" << "\"" << m_text << "\""
             << std::endl;
   return ostr.str();
}

std::string Comment::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<comment"
        << " text=" << "\"" << getText() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DataVersionString::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dataVersionString"
        << " text=" << "\"" << m_text << "\""
             << std::endl;
   return ostr.str();
}

std::string DataVersionString::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dataVersionString"
        << " text=" << "\"" << getText() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CcdbContext::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ccdbContext"
        << " text=" << "\"" << m_text << "\""
             << std::endl;
   return ostr.str();
}

std::string CcdbContext::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ccdbContext"
        << " text=" << "\"" << getText() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Origin::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "origin"
        << " t=" << m_t
        << " vx=" << m_vx
        << " vy=" << m_vy
        << " vz=" << m_vz
             << std::endl;
   return ostr.str();
}

std::string Origin::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<origin"
        << " lunit=" << "\"" << getLunit() << "\""
        << " t=" << "\"" << getT() << "\""
        << " vx=" << "\"" << getVx() << "\""
        << " vy=" << "\"" << getVy() << "\""
        << " vz=" << "\"" << getVz() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Momentum::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "momentum"
        << " E=" << m_E
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
             << std::endl;
   return ostr.str();
}

std::string Momentum::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<momentum"
        << " E=" << "\"" << getE() << "\""
        << " Eunit=" << "\"" << getEunit() << "\""
        << " punit=" << "\"" << getPunit() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Product::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "product"
        << " id=" << m_id
        << " parentId=" << m_parentId
        << " pdgtype=" << m_pdgtype
             << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string Product::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<product"
        << " id=" << "\"" << getId() << "\""
        << " parentId=" << "\"" << getParentId() << "\""
        << " pdgtype=" << "\"" << getPdgtype() << "\""
        << ">" << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</product>"
        << std::endl;
   return ostr.str();
}

std::string Vertex::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "vertex"
             << std::endl;
   if (! m_origin_link.empty()) {
      ostr << m_origin_link.begin()->toString(indent + 2);
   }
   int ProductListCount=0;
   for (ProductList::iterator it = m_product_list.begin();
        it != m_product_list.end(); ++it)
   {
      if (++ProductListCount > m_product_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string Vertex::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<vertex"
        << ">" << std::endl;
   if (! m_origin_link.empty()) {
      ostr << m_origin_link.begin()->toXML(indent + 2);
   }
   int ProductListCount=0;
   for (ProductList::iterator it = m_product_list.begin();
        it != m_product_list.end(); ++it)
   {
      if (++ProductListCount > m_product_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</vertex>"
        << std::endl;
   return ostr.str();
}

std::string Reaction::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "reaction"
        << " Ebeam=" << m_Ebeam
        << " jtag=" << "\"" << m_jtag << "\""
        << " targetType=" << ParticleType((Particle_t)m_targetType)
        << " type=" << m_type
        << " weight=" << m_weight
             << std::endl;
   int VertexListCount=0;
   for (VertexList::iterator it = m_vertex_list.begin();
        it != m_vertex_list.end(); ++it)
   {
      if (++VertexListCount > m_vertex_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string Reaction::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<reaction"
        << " Ebeam=" << "\"" << getEbeam() << "\""
        << " Eunit=" << "\"" << getEunit() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " targetType=\"" << ParticleType((Particle_t)m_targetType) << "\""
        << " type=" << "\"" << getType() << "\""
        << " weight=" << "\"" << getWeight() << "\""
        << ">" << std::endl;
   int VertexListCount=0;
   for (VertexList::iterator it = m_vertex_list.begin();
        it != m_vertex_list.end(); ++it)
   {
      if (++VertexListCount > m_vertex_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</reaction>"
        << std::endl;
   return ostr.str();
}

std::string TagmBeamPhoton::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tagmBeamPhoton"
        << " E=" << m_E
        << " jtag=" << "\"" << m_jtag << "\""
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string TagmBeamPhoton::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tagmBeamPhoton"
        << " E=" << "\"" << getE() << "\""
        << " Eunit=" << "\"" << getEunit() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " t=" << "\"" << getT() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TaghBeamPhoton::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "taghBeamPhoton"
        << " E=" << m_E
        << " jtag=" << "\"" << m_jtag << "\""
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string TaghBeamPhoton::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<taghBeamPhoton"
        << " E=" << "\"" << getE() << "\""
        << " Eunit=" << "\"" << getEunit() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " t=" << "\"" << getT() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalCorrelations::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalCorrelations"
        << " Etcorr=" << m_Etcorr
        << " Excorr=" << m_Excorr
        << " Eycorr=" << m_Eycorr
        << " txcorr=" << m_txcorr
        << " tycorr=" << m_tycorr
             << std::endl;
   return ostr.str();
}

std::string FcalCorrelations::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalCorrelations"
        << " Etcorr=" << "\"" << getEtcorr() << "\""
        << " Excorr=" << "\"" << getExcorr() << "\""
        << " Eycorr=" << "\"" << getEycorr() << "\""
        << " txcorr=" << "\"" << getTxcorr() << "\""
        << " tycorr=" << "\"" << getTycorr() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalShowerClassification::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalShowerClassification"
        << " classifierOuput=" << m_classifierOuput
             << std::endl;
   return ostr.str();
}

std::string FcalShowerClassification::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalShowerClassification"
        << " classifierOuput=" << "\"" << getClassifierOuput() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalShowerProperties::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalShowerProperties"
        << " E1E9=" << m_E1E9
        << " E9E25=" << m_E9E25
        << " docaTrack=" << m_docaTrack
        << " sumU=" << m_sumU
        << " sumV=" << m_sumV
        << " timeTrack=" << m_timeTrack
             << std::endl;
   return ostr.str();
}

std::string FcalShowerProperties::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalShowerProperties"
        << " E1E9=" << "\"" << getE1E9() << "\""
        << " E9E25=" << "\"" << getE9E25() << "\""
        << " docaTrack=" << "\"" << getDocaTrack() << "\""
        << " sumU=" << "\"" << getSumU() << "\""
        << " sumV=" << "\"" << getSumV() << "\""
        << " timeTrack=" << "\"" << getTimeTrack() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalShowerNBlocks::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalShowerNBlocks"
        << " numBlocks=" << m_numBlocks
             << std::endl;
   return ostr.str();
}

std::string FcalShowerNBlocks::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalShowerNBlocks"
        << " numBlocks=" << "\"" << getNumBlocks() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalShower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalShower"
        << " E=" << m_E
        << " Eerr=" << m_Eerr
        << " Ezcorr=" << m_Ezcorr
        << " jtag=" << "\"" << m_jtag << "\""
        << " t=" << m_t
        << " terr=" << m_terr
        << " tzcorr=" << m_tzcorr
        << " x=" << m_x
        << " xerr=" << m_xerr
        << " xycorr=" << m_xycorr
        << " xzcorr=" << m_xzcorr
        << " y=" << m_y
        << " yerr=" << m_yerr
        << " yzcorr=" << m_yzcorr
        << " z=" << m_z
        << " zerr=" << m_zerr
             << std::endl;
   if (! m_fcalCorrelations_link.empty()) {
      ostr << m_fcalCorrelations_link.begin()->toString(indent + 2);
   }
   if (! m_fcalShowerClassification_link.empty()) {
      ostr << m_fcalShowerClassification_link.begin()->toString(indent + 2);
   }
   if (! m_fcalShowerProperties_link.empty()) {
      ostr << m_fcalShowerProperties_link.begin()->toString(indent + 2);
   }
   if (! m_fcalShowerNBlocks_link.empty()) {
      ostr << m_fcalShowerNBlocks_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string FcalShower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalShower"
        << " E=" << "\"" << getE() << "\""
        << " Eerr=" << "\"" << getEerr() << "\""
        << " Eunit=" << "\"" << getEunit() << "\""
        << " Ezcorr=" << "\"" << getEzcorr() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " t=" << "\"" << getT() << "\""
        << " terr=" << "\"" << getTerr() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " tzcorr=" << "\"" << getTzcorr() << "\""
        << " x=" << "\"" << getX() << "\""
        << " xerr=" << "\"" << getXerr() << "\""
        << " xycorr=" << "\"" << getXycorr() << "\""
        << " xzcorr=" << "\"" << getXzcorr() << "\""
        << " y=" << "\"" << getY() << "\""
        << " yerr=" << "\"" << getYerr() << "\""
        << " yzcorr=" << "\"" << getYzcorr() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " zerr=" << "\"" << getZerr() << "\""
        << ">" << std::endl;
   if (! m_fcalCorrelations_link.empty()) {
      ostr << m_fcalCorrelations_link.begin()->toXML(indent + 2);
   }
   if (! m_fcalShowerClassification_link.empty()) {
      ostr << m_fcalShowerClassification_link.begin()->toXML(indent + 2);
   }
   if (! m_fcalShowerProperties_link.empty()) {
      ostr << m_fcalShowerProperties_link.begin()->toXML(indent + 2);
   }
   if (! m_fcalShowerNBlocks_link.empty()) {
      ostr << m_fcalShowerNBlocks_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fcalShower>"
        << std::endl;
   return ostr.str();
}

std::string Preshower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "preshower"
        << " preshowerE=" << m_preshowerE
             << std::endl;
   return ostr.str();
}

std::string Preshower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<preshower"
        << " preshowerE=" << "\"" << getPreshowerE() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Width::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "width"
        << " sigLong=" << m_sigLong
        << " sigTheta=" << m_sigTheta
        << " sigTrans=" << m_sigTrans
             << std::endl;
   return ostr.str();
}

std::string Width::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<width"
        << " sigLong=" << "\"" << getSigLong() << "\""
        << " sigTheta=" << "\"" << getSigTheta() << "\""
        << " sigTrans=" << "\"" << getSigTrans() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalCluster::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalCluster"
        << " ncell=" << m_ncell
             << std::endl;
   return ostr.str();
}

std::string BcalCluster::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalCluster"
        << " ncell=" << "\"" << getNcell() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalCorrelations::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalCorrelations"
        << " Etcorr=" << m_Etcorr
        << " Excorr=" << m_Excorr
        << " Eycorr=" << m_Eycorr
        << " txcorr=" << m_txcorr
        << " tycorr=" << m_tycorr
             << std::endl;
   return ostr.str();
}

std::string BcalCorrelations::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalCorrelations"
        << " Etcorr=" << "\"" << getEtcorr() << "\""
        << " Excorr=" << "\"" << getExcorr() << "\""
        << " Eycorr=" << "\"" << getEycorr() << "\""
        << " txcorr=" << "\"" << getTxcorr() << "\""
        << " tycorr=" << "\"" << getTycorr() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalLayers::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalLayers"
        << " E_L2=" << m_E_L2
        << " E_L3=" << m_E_L3
        << " E_L4=" << m_E_L4
        << " rmsTime=" << m_rmsTime
             << std::endl;
   return ostr.str();
}

std::string BcalLayers::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalLayers"
        << " E_L2=" << "\"" << getE_L2() << "\""
        << " E_L3=" << "\"" << getE_L3() << "\""
        << " E_L4=" << "\"" << getE_L4() << "\""
        << " rmsTime=" << "\"" << getRmsTime() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalShower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalShower"
        << " E=" << m_E
        << " Eerr=" << m_Eerr
        << " Ezcorr=" << m_Ezcorr
        << " jtag=" << "\"" << m_jtag << "\""
        << " t=" << m_t
        << " terr=" << m_terr
        << " tzcorr=" << m_tzcorr
        << " x=" << m_x
        << " xerr=" << m_xerr
        << " xycorr=" << m_xycorr
        << " xzcorr=" << m_xzcorr
        << " y=" << m_y
        << " yerr=" << m_yerr
        << " yzcorr=" << m_yzcorr
        << " z=" << m_z
        << " zerr=" << m_zerr
             << std::endl;
   if (! m_preshower_link.empty()) {
      ostr << m_preshower_link.begin()->toString(indent + 2);
   }
   if (! m_width_link.empty()) {
      ostr << m_width_link.begin()->toString(indent + 2);
   }
   if (! m_bcalCluster_link.empty()) {
      ostr << m_bcalCluster_link.begin()->toString(indent + 2);
   }
   if (! m_bcalCorrelations_link.empty()) {
      ostr << m_bcalCorrelations_link.begin()->toString(indent + 2);
   }
   if (! m_bcalLayers_link.empty()) {
      ostr << m_bcalLayers_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string BcalShower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalShower"
        << " E=" << "\"" << getE() << "\""
        << " Eerr=" << "\"" << getEerr() << "\""
        << " Eunit=" << "\"" << getEunit() << "\""
        << " Ezcorr=" << "\"" << getEzcorr() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " t=" << "\"" << getT() << "\""
        << " terr=" << "\"" << getTerr() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " tzcorr=" << "\"" << getTzcorr() << "\""
        << " x=" << "\"" << getX() << "\""
        << " xerr=" << "\"" << getXerr() << "\""
        << " xycorr=" << "\"" << getXycorr() << "\""
        << " xzcorr=" << "\"" << getXzcorr() << "\""
        << " y=" << "\"" << getY() << "\""
        << " yerr=" << "\"" << getYerr() << "\""
        << " yzcorr=" << "\"" << getYzcorr() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " zerr=" << "\"" << getZerr() << "\""
        << ">" << std::endl;
   if (! m_preshower_link.empty()) {
      ostr << m_preshower_link.begin()->toXML(indent + 2);
   }
   if (! m_width_link.empty()) {
      ostr << m_width_link.begin()->toXML(indent + 2);
   }
   if (! m_bcalCluster_link.empty()) {
      ostr << m_bcalCluster_link.begin()->toXML(indent + 2);
   }
   if (! m_bcalCorrelations_link.empty()) {
      ostr << m_bcalCorrelations_link.begin()->toXML(indent + 2);
   }
   if (! m_bcalLayers_link.empty()) {
      ostr << m_bcalLayers_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</bcalShower>"
        << std::endl;
   return ostr.str();
}

std::string CcalShower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ccalShower"
        << " E=" << m_E
        << " Eerr=" << m_Eerr
        << " Emax=" << m_Emax
        << " chi2=" << m_chi2
        << " dime=" << m_dime
        << " id=" << m_id
        << " idmax=" << m_idmax
        << " jtag=" << "\"" << m_jtag << "\""
        << " t=" << m_t
        << " terr=" << m_terr
        << " type=" << m_type
        << " x=" << m_x
        << " x1=" << m_x1
        << " y=" << m_y
        << " y1=" << m_y1
        << " z=" << m_z
             << std::endl;
   return ostr.str();
}

std::string CcalShower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ccalShower"
        << " E=" << "\"" << getE() << "\""
        << " Eerr=" << "\"" << getEerr() << "\""
        << " Emax=" << "\"" << getEmax() << "\""
        << " Eunit=" << "\"" << getEunit() << "\""
        << " chi2=" << "\"" << getChi2() << "\""
        << " dime=" << "\"" << getDime() << "\""
        << " id=" << "\"" << getId() << "\""
        << " idmax=" << "\"" << getIdmax() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " t=" << "\"" << getT() << "\""
        << " terr=" << "\"" << getTerr() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " type=" << "\"" << getType() << "\""
        << " x=" << "\"" << getX() << "\""
        << " x1=" << "\"" << getX1() << "\""
        << " y=" << "\"" << getY() << "\""
        << " y1=" << "\"" << getY1() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TrackFit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "trackFit"
        << " Ndof=" << m_Ndof
        << " chisq=" << m_chisq
        << " e11=" << m_e11
        << " e12=" << m_e12
        << " e13=" << m_e13
        << " e14=" << m_e14
        << " e15=" << m_e15
        << " e22=" << m_e22
        << " e23=" << m_e23
        << " e24=" << m_e24
        << " e25=" << m_e25
        << " e33=" << m_e33
        << " e34=" << m_e34
        << " e35=" << m_e35
        << " e44=" << m_e44
        << " e45=" << m_e45
        << " e55=" << m_e55
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t0=" << m_t0
        << " t0det=" << m_t0det
        << " t0err=" << m_t0err
        << " x0=" << m_x0
        << " y0=" << m_y0
        << " z0=" << m_z0
             << std::endl;
   return ostr.str();
}

std::string TrackFit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<trackFit"
        << " Ndof=" << "\"" << getNdof() << "\""
        << " chisq=" << "\"" << getChisq() << "\""
        << " e11=" << "\"" << getE11() << "\""
        << " e12=" << "\"" << getE12() << "\""
        << " e13=" << "\"" << getE13() << "\""
        << " e14=" << "\"" << getE14() << "\""
        << " e15=" << "\"" << getE15() << "\""
        << " e22=" << "\"" << getE22() << "\""
        << " e23=" << "\"" << getE23() << "\""
        << " e24=" << "\"" << getE24() << "\""
        << " e25=" << "\"" << getE25() << "\""
        << " e33=" << "\"" << getE33() << "\""
        << " e34=" << "\"" << getE34() << "\""
        << " e35=" << "\"" << getE35() << "\""
        << " e44=" << "\"" << getE44() << "\""
        << " e45=" << "\"" << getE45() << "\""
        << " e55=" << "\"" << getE55() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " punit=" << "\"" << getPunit() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t0=" << "\"" << getT0() << "\""
        << " t0det=" << "\"" << getT0det() << "\""
        << " t0err=" << "\"" << getT0err() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " x0=" << "\"" << getX0() << "\""
        << " y0=" << "\"" << getY0() << "\""
        << " z0=" << "\"" << getZ0() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TrackFlags::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "trackFlags"
        << " flags=" << m_flags
             << std::endl;
   return ostr.str();
}

std::string TrackFlags::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<trackFlags"
        << " flags=" << "\"" << getFlags() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Hitlayers::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "hitlayers"
        << " CDCrings=" << m_CDCrings
        << " FDCplanes=" << m_FDCplanes
             << std::endl;
   return ostr.str();
}

std::string Hitlayers::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<hitlayers"
        << " CDCrings=" << "\"" << getCDCrings() << "\""
        << " FDCplanes=" << "\"" << getFDCplanes() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Expectedhits::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "expectedhits"
        << " expectedCDChits=" << m_expectedCDChits
        << " expectedFDChits=" << m_expectedFDChits
        << " measuredCDChits=" << m_measuredCDChits
        << " measuredFDChits=" << m_measuredFDChits
             << std::endl;
   return ostr.str();
}

std::string Expectedhits::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<expectedhits"
        << " expectedCDChits=" << "\"" << getExpectedCDChits() << "\""
        << " expectedFDChits=" << "\"" << getExpectedFDChits() << "\""
        << " measuredCDChits=" << "\"" << getMeasuredCDChits() << "\""
        << " measuredFDChits=" << "\"" << getMeasuredFDChits() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Mcmatch::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "mcmatch"
        << " ithrown=" << m_ithrown
        << " numhitsmatch=" << m_numhitsmatch
             << std::endl;
   return ostr.str();
}

std::string Mcmatch::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<mcmatch"
        << " ithrown=" << "\"" << getIthrown() << "\""
        << " numhitsmatch=" << "\"" << getNumhitsmatch() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CDCAmpdEdx::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "CDCAmpdEdx"
        << " dEdxCDCAmp=" << m_dEdxCDCAmp
        << " dxCDCAmp=" << m_dxCDCAmp
             << std::endl;
   return ostr.str();
}

std::string CDCAmpdEdx::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<CDCAmpdEdx"
        << " dEdxCDCAmp=" << "\"" << getDEdxCDCAmp() << "\""
        << " dxCDCAmp=" << "\"" << getDxCDCAmp() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DEdxDC::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dEdxDC"
        << " NsampleCDC=" << m_NsampleCDC
        << " NsampleFDC=" << m_NsampleFDC
        << " dEdxCDC=" << m_dEdxCDC
        << " dEdxFDC=" << m_dEdxFDC
        << " dxCDC=" << m_dxCDC
        << " dxFDC=" << m_dxFDC
             << std::endl;
   if (! m_CDCAmpdEdx_link.empty()) {
      ostr << m_CDCAmpdEdx_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string DEdxDC::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dEdxDC"
        << " NsampleCDC=" << "\"" << getNsampleCDC() << "\""
        << " NsampleFDC=" << "\"" << getNsampleFDC() << "\""
        << " dEdxCDC=" << "\"" << getDEdxCDC() << "\""
        << " dEdxFDC=" << "\"" << getDEdxFDC() << "\""
        << " dEdx_unit=" << "\"" << getDEdx_unit() << "\""
        << " dxCDC=" << "\"" << getDxCDC() << "\""
        << " dxFDC=" << "\"" << getDxFDC() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << ">" << std::endl;
   if (! m_CDCAmpdEdx_link.empty()) {
      ostr << m_CDCAmpdEdx_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</dEdxDC>"
        << std::endl;
   return ostr.str();
}

std::string ExitParams::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "exitParams"
        << " px1=" << m_px1
        << " py1=" << m_py1
        << " pz1=" << m_pz1
        << " t1=" << m_t1
        << " x1=" << m_x1
        << " y1=" << m_y1
        << " z1=" << m_z1
             << std::endl;
   return ostr.str();
}

std::string ExitParams::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<exitParams"
        << " lunit=" << "\"" << getLunit() << "\""
        << " punit=" << "\"" << getPunit() << "\""
        << " px1=" << "\"" << getPx1() << "\""
        << " py1=" << "\"" << getPy1() << "\""
        << " pz1=" << "\"" << getPz1() << "\""
        << " t1=" << "\"" << getT1() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " x1=" << "\"" << getX1() << "\""
        << " y1=" << "\"" << getY1() << "\""
        << " z1=" << "\"" << getZ1() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string ChargedTrack::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "chargedTrack"
        << " candidateId=" << m_candidateId
        << " jtag=" << "\"" << m_jtag << "\""
        << " ptype=" << ParticleType((Particle_t)m_ptype)
             << std::endl;
   if (! m_trackFit_link.empty()) {
      ostr << m_trackFit_link.begin()->toString(indent + 2);
   }
   if (! m_trackFlags_link.empty()) {
      ostr << m_trackFlags_link.begin()->toString(indent + 2);
   }
   if (! m_hitlayers_link.empty()) {
      ostr << m_hitlayers_link.begin()->toString(indent + 2);
   }
   if (! m_expectedhits_link.empty()) {
      ostr << m_expectedhits_link.begin()->toString(indent + 2);
   }
   if (! m_mcmatch_link.empty()) {
      ostr << m_mcmatch_link.begin()->toString(indent + 2);
   }
   if (! m_dEdxDC_link.empty()) {
      ostr << m_dEdxDC_link.begin()->toString(indent + 2);
   }
   if (! m_exitParams_link.empty()) {
      ostr << m_exitParams_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string ChargedTrack::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<chargedTrack"
        << " candidateId=" << "\"" << getCandidateId() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " ptype=\"" << ParticleType((Particle_t)m_ptype) << "\""
        << ">" << std::endl;
   if (! m_trackFit_link.empty()) {
      ostr << m_trackFit_link.begin()->toXML(indent + 2);
   }
   if (! m_trackFlags_link.empty()) {
      ostr << m_trackFlags_link.begin()->toXML(indent + 2);
   }
   if (! m_hitlayers_link.empty()) {
      ostr << m_hitlayers_link.begin()->toXML(indent + 2);
   }
   if (! m_expectedhits_link.empty()) {
      ostr << m_expectedhits_link.begin()->toXML(indent + 2);
   }
   if (! m_mcmatch_link.empty()) {
      ostr << m_mcmatch_link.begin()->toXML(indent + 2);
   }
   if (! m_dEdxDC_link.empty()) {
      ostr << m_dEdxDC_link.begin()->toXML(indent + 2);
   }
   if (! m_exitParams_link.empty()) {
      ostr << m_exitParams_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</chargedTrack>"
        << std::endl;
   return ostr.str();
}

std::string StartHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "startHit"
        << " dE=" << m_dE
        << " jtag=" << "\"" << m_jtag << "\""
        << " sector=" << m_sector
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string StartHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<startHit"
        << " Eunit=" << "\"" << getEunit() << "\""
        << " dE=" << "\"" << getDE() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " sector=" << "\"" << getSector() << "\""
        << " t=" << "\"" << getT() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TofStatus::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tofStatus"
        << " status=" << m_status
             << std::endl;
   return ostr.str();
}

std::string TofStatus::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tofStatus"
        << " status=" << "\"" << getStatus() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TofEnergyDeposition::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tofEnergyDeposition"
        << " dE1=" << m_dE1
        << " dE2=" << m_dE2
             << std::endl;
   return ostr.str();
}

std::string TofEnergyDeposition::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tofEnergyDeposition"
        << " dE1=" << "\"" << getDE1() << "\""
        << " dE2=" << "\"" << getDE2() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TofPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tofPoint"
        << " dE=" << m_dE
        << " jtag=" << "\"" << m_jtag << "\""
        << " t=" << m_t
        << " terr=" << m_terr
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_tofStatus_link.empty()) {
      ostr << m_tofStatus_link.begin()->toString(indent + 2);
   }
   if (! m_tofEnergyDeposition_link.empty()) {
      ostr << m_tofEnergyDeposition_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string TofPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tofPoint"
        << " Eunit=" << "\"" << getEunit() << "\""
        << " dE=" << "\"" << getDE() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " t=" << "\"" << getT() << "\""
        << " terr=" << "\"" << getTerr() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_tofStatus_link.empty()) {
      ostr << m_tofStatus_link.begin()->toXML(indent + 2);
   }
   if (! m_tofEnergyDeposition_link.empty()) {
      ostr << m_tofEnergyDeposition_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</tofPoint>"
        << std::endl;
   return ostr.str();
}

std::string DircHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dircHit"
        << " ch=" << m_ch
        << " jtag=" << "\"" << m_jtag << "\""
        << " t=" << m_t
        << " tot=" << m_tot
             << std::endl;
   return ostr.str();
}

std::string DircHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dircHit"
        << " ch=" << "\"" << getCh() << "\""
        << " jtag=" << "\"" << getJtag() << "\""
        << " t=" << "\"" << getT() << "\""
        << " tot=" << "\"" << getTot() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string RFtime::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "RFtime"
        << " jtag=" << "\"" << m_jtag << "\""
        << " tsync=" << m_tsync
             << std::endl;
   return ostr.str();
}

std::string RFtime::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<RFtime"
        << " jtag=" << "\"" << getJtag() << "\""
        << " tsync=" << "\"" << getTsync() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TriggerEnergySums::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "triggerEnergySums"
        << " BCALEnergySum=" << m_BCALEnergySum
        << " FCALEnergySum=" << m_FCALEnergySum
             << std::endl;
   return ostr.str();
}

std::string TriggerEnergySums::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<triggerEnergySums"
        << " BCALEnergySum=" << "\"" << getBCALEnergySum() << "\""
        << " FCALEnergySum=" << "\"" << getFCALEnergySum() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Trigger::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "trigger"
        << " jtag=" << "\"" << m_jtag << "\""
        << " l1_fp_trig_bits=" << m_l1_fp_trig_bits
        << " l1_trig_bits=" << m_l1_trig_bits
             << std::endl;
   if (! m_triggerEnergySums_link.empty()) {
      ostr << m_triggerEnergySums_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string Trigger::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<trigger"
        << " jtag=" << "\"" << getJtag() << "\""
        << " l1_fp_trig_bits=" << "\"" << getL1_fp_trig_bits() << "\""
        << " l1_trig_bits=" << "\"" << getL1_trig_bits() << "\""
        << ">" << std::endl;
   if (! m_triggerEnergySums_link.empty()) {
      ostr << m_triggerEnergySums_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</trigger>"
        << std::endl;
   return ostr.str();
}

std::string BcalMatchParams::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalMatchParams"
        << " deltaphi=" << m_deltaphi
        << " deltaz=" << m_deltaz
        << " dx=" << m_dx
        << " pathlength=" << m_pathlength
        << " shower=" << m_shower
        << " tflight=" << m_tflight
        << " tflightvar=" << m_tflightvar
        << " track=" << m_track
             << std::endl;
   return ostr.str();
}

std::string BcalMatchParams::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalMatchParams"
        << " deltaphi=" << "\"" << getDeltaphi() << "\""
        << " deltaz=" << "\"" << getDeltaz() << "\""
        << " dx=" << "\"" << getDx() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " pathlength=" << "\"" << getPathlength() << "\""
        << " shower=" << "\"" << getShower() << "\""
        << " tflight=" << "\"" << getTflight() << "\""
        << " tflightvar=" << "\"" << getTflightvar() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalMatchParams::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalMatchParams"
        << " doca=" << m_doca
        << " dx=" << m_dx
        << " pathlength=" << m_pathlength
        << " shower=" << m_shower
        << " tflight=" << m_tflight
        << " tflightvar=" << m_tflightvar
        << " track=" << m_track
             << std::endl;
   return ostr.str();
}

std::string FcalMatchParams::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalMatchParams"
        << " doca=" << "\"" << getDoca() << "\""
        << " dx=" << "\"" << getDx() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " pathlength=" << "\"" << getPathlength() << "\""
        << " shower=" << "\"" << getShower() << "\""
        << " tflight=" << "\"" << getTflight() << "\""
        << " tflightvar=" << "\"" << getTflightvar() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TofDedx::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tofDedx"
        << " dEdx1=" << m_dEdx1
        << " dEdx2=" << m_dEdx2
             << std::endl;
   return ostr.str();
}

std::string TofDedx::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tofDedx"
        << " dEdx1=" << "\"" << getDEdx1() << "\""
        << " dEdx2=" << "\"" << getDEdx2() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TofMatchParams::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tofMatchParams"
        << " dEdx=" << m_dEdx
        << " deltax=" << m_deltax
        << " deltay=" << m_deltay
        << " ehit=" << m_ehit
        << " hit=" << m_hit
        << " pathlength=" << m_pathlength
        << " tflight=" << m_tflight
        << " tflightvar=" << m_tflightvar
        << " thit=" << m_thit
        << " thitvar=" << m_thitvar
        << " track=" << m_track
             << std::endl;
   if (! m_tofDedx_link.empty()) {
      ostr << m_tofDedx_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string TofMatchParams::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tofMatchParams"
        << " dEdx=" << "\"" << getDEdx() << "\""
        << " dEdx_unit=" << "\"" << getDEdx_unit() << "\""
        << " deltax=" << "\"" << getDeltax() << "\""
        << " deltay=" << "\"" << getDeltay() << "\""
        << " ehit=" << "\"" << getEhit() << "\""
        << " hit=" << "\"" << getHit() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " pathlength=" << "\"" << getPathlength() << "\""
        << " tflight=" << "\"" << getTflight() << "\""
        << " tflightvar=" << "\"" << getTflightvar() << "\""
        << " thit=" << "\"" << getThit() << "\""
        << " thitvar=" << "\"" << getThitvar() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << ">" << std::endl;
   if (! m_tofDedx_link.empty()) {
      ostr << m_tofDedx_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</tofMatchParams>"
        << std::endl;
   return ostr.str();
}

std::string ScMatchParams::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "scMatchParams"
        << " dEdx=" << m_dEdx
        << " deltaphi=" << m_deltaphi
        << " ehit=" << m_ehit
        << " hit=" << m_hit
        << " pathlength=" << m_pathlength
        << " tflight=" << m_tflight
        << " tflightvar=" << m_tflightvar
        << " thit=" << m_thit
        << " thitvar=" << m_thitvar
        << " track=" << m_track
             << std::endl;
   return ostr.str();
}

std::string ScMatchParams::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<scMatchParams"
        << " Eunit=" << "\"" << getEunit() << "\""
        << " aunit=" << "\"" << getAunit() << "\""
        << " dEdx=" << "\"" << getDEdx() << "\""
        << " dEdx_unit=" << "\"" << getDEdx_unit() << "\""
        << " deltaphi=" << "\"" << getDeltaphi() << "\""
        << " ehit=" << "\"" << getEhit() << "\""
        << " hit=" << "\"" << getHit() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " pathlength=" << "\"" << getPathlength() << "\""
        << " tflight=" << "\"" << getTflight() << "\""
        << " tflightvar=" << "\"" << getTflightvar() << "\""
        << " thit=" << "\"" << getThit() << "\""
        << " thitvar=" << "\"" << getThitvar() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DircMatchParams::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dircMatchParams"
        << " deltat=" << m_deltat
        << " expectthetac=" << m_expectthetac
        << " lele=" << m_lele
        << " lk=" << m_lk
        << " lp=" << m_lp
        << " lpi=" << m_lpi
        << " nphotons=" << m_nphotons
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " thetac=" << m_thetac
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   return ostr.str();
}

std::string DircMatchParams::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dircMatchParams"
        << " deltat=" << "\"" << getDeltat() << "\""
        << " expectthetac=" << "\"" << getExpectthetac() << "\""
        << " lele=" << "\"" << getLele() << "\""
        << " lk=" << "\"" << getLk() << "\""
        << " lp=" << "\"" << getLp() << "\""
        << " lpi=" << "\"" << getLpi() << "\""
        << " nphotons=" << "\"" << getNphotons() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " thetac=" << "\"" << getThetac() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DircMatchHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dircMatchHit"
        << " hit=" << m_hit
        << " track=" << m_track
             << std::endl;
   return ostr.str();
}

std::string DircMatchHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dircMatchHit"
        << " hit=" << "\"" << getHit() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalDOCAtoTrack::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalDOCAtoTrack"
        << " deltaphi=" << m_deltaphi
        << " deltaz=" << m_deltaz
        << " shower=" << m_shower
             << std::endl;
   return ostr.str();
}

std::string BcalDOCAtoTrack::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalDOCAtoTrack"
        << " deltaphi=" << "\"" << getDeltaphi() << "\""
        << " deltaz=" << "\"" << getDeltaz() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " shower=" << "\"" << getShower() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalDOCAtoTrack::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalDOCAtoTrack"
        << " doca=" << m_doca
        << " shower=" << m_shower
             << std::endl;
   return ostr.str();
}

std::string FcalDOCAtoTrack::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalDOCAtoTrack"
        << " doca=" << "\"" << getDoca() << "\""
        << " lunit=" << "\"" << getLunit() << "\""
        << " shower=" << "\"" << getShower() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TflightPCorrelation::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tflightPCorrelation"
        << " correlation=" << m_correlation
        << " system=" << m_system
        << " track=" << m_track
             << std::endl;
   return ostr.str();
}

std::string TflightPCorrelation::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tflightPCorrelation"
        << " correlation=" << "\"" << getCorrelation() << "\""
        << " punit=" << "\"" << getPunit() << "\""
        << " system=" << "\"" << getSystem() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DetectorMatches::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "detectorMatches"
        << " jtag=" << "\"" << m_jtag << "\""
             << std::endl;
   int BcalMatchParamsListCount=0;
   for (BcalMatchParamsList::iterator it = m_bcalMatchParams_list.begin();
        it != m_bcalMatchParams_list.end(); ++it)
   {
      if (++BcalMatchParamsListCount > m_bcalMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FcalMatchParamsListCount=0;
   for (FcalMatchParamsList::iterator it = m_fcalMatchParams_list.begin();
        it != m_fcalMatchParams_list.end(); ++it)
   {
      if (++FcalMatchParamsListCount > m_fcalMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TofMatchParamsListCount=0;
   for (TofMatchParamsList::iterator it = m_tofMatchParams_list.begin();
        it != m_tofMatchParams_list.end(); ++it)
   {
      if (++TofMatchParamsListCount > m_tofMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int ScMatchParamsListCount=0;
   for (ScMatchParamsList::iterator it = m_scMatchParams_list.begin();
        it != m_scMatchParams_list.end(); ++it)
   {
      if (++ScMatchParamsListCount > m_scMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int DircMatchParamsListCount=0;
   for (DircMatchParamsList::iterator it = m_dircMatchParams_list.begin();
        it != m_dircMatchParams_list.end(); ++it)
   {
      if (++DircMatchParamsListCount > m_dircMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int DircMatchHitListCount=0;
   for (DircMatchHitList::iterator it = m_dircMatchHit_list.begin();
        it != m_dircMatchHit_list.end(); ++it)
   {
      if (++DircMatchHitListCount > m_dircMatchHit_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalDOCAtoTrackListCount=0;
   for (BcalDOCAtoTrackList::iterator it = m_bcalDOCAtoTrack_list.begin();
        it != m_bcalDOCAtoTrack_list.end(); ++it)
   {
      if (++BcalDOCAtoTrackListCount > m_bcalDOCAtoTrack_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FcalDOCAtoTrackListCount=0;
   for (FcalDOCAtoTrackList::iterator it = m_fcalDOCAtoTrack_list.begin();
        it != m_fcalDOCAtoTrack_list.end(); ++it)
   {
      if (++FcalDOCAtoTrackListCount > m_fcalDOCAtoTrack_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TflightPCorrelationListCount=0;
   for (TflightPCorrelationList::iterator it = m_tflightPCorrelation_list.begin();
        it != m_tflightPCorrelation_list.end(); ++it)
   {
      if (++TflightPCorrelationListCount > m_tflightPCorrelation_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string DetectorMatches::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<detectorMatches"
        << " jtag=" << "\"" << getJtag() << "\""
        << ">" << std::endl;
   int BcalMatchParamsListCount=0;
   for (BcalMatchParamsList::iterator it = m_bcalMatchParams_list.begin();
        it != m_bcalMatchParams_list.end(); ++it)
   {
      if (++BcalMatchParamsListCount > m_bcalMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FcalMatchParamsListCount=0;
   for (FcalMatchParamsList::iterator it = m_fcalMatchParams_list.begin();
        it != m_fcalMatchParams_list.end(); ++it)
   {
      if (++FcalMatchParamsListCount > m_fcalMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TofMatchParamsListCount=0;
   for (TofMatchParamsList::iterator it = m_tofMatchParams_list.begin();
        it != m_tofMatchParams_list.end(); ++it)
   {
      if (++TofMatchParamsListCount > m_tofMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int ScMatchParamsListCount=0;
   for (ScMatchParamsList::iterator it = m_scMatchParams_list.begin();
        it != m_scMatchParams_list.end(); ++it)
   {
      if (++ScMatchParamsListCount > m_scMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int DircMatchParamsListCount=0;
   for (DircMatchParamsList::iterator it = m_dircMatchParams_list.begin();
        it != m_dircMatchParams_list.end(); ++it)
   {
      if (++DircMatchParamsListCount > m_dircMatchParams_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int DircMatchHitListCount=0;
   for (DircMatchHitList::iterator it = m_dircMatchHit_list.begin();
        it != m_dircMatchHit_list.end(); ++it)
   {
      if (++DircMatchHitListCount > m_dircMatchHit_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalDOCAtoTrackListCount=0;
   for (BcalDOCAtoTrackList::iterator it = m_bcalDOCAtoTrack_list.begin();
        it != m_bcalDOCAtoTrack_list.end(); ++it)
   {
      if (++BcalDOCAtoTrackListCount > m_bcalDOCAtoTrack_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FcalDOCAtoTrackListCount=0;
   for (FcalDOCAtoTrackList::iterator it = m_fcalDOCAtoTrack_list.begin();
        it != m_fcalDOCAtoTrack_list.end(); ++it)
   {
      if (++FcalDOCAtoTrackListCount > m_fcalDOCAtoTrack_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TflightPCorrelationListCount=0;
   for (TflightPCorrelationList::iterator it = m_tflightPCorrelation_list.begin();
        it != m_tflightPCorrelation_list.end(); ++it)
   {
      if (++TflightPCorrelationListCount > m_tflightPCorrelation_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</detectorMatches>"
        << std::endl;
   return ostr.str();
}

std::string StartCounters::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "startCounters"
        << " count=" << m_count
             << std::endl;
   return ostr.str();
}

std::string StartCounters::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<startCounters"
        << " count=" << "\"" << getCount() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CdcStraws::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cdcStraws"
        << " count=" << m_count
             << std::endl;
   return ostr.str();
}

std::string CdcStraws::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cdcStraws"
        << " count=" << "\"" << getCount() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FdcPseudos::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcPseudos"
        << " count=" << m_count
             << std::endl;
   return ostr.str();
}

std::string FdcPseudos::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcPseudos"
        << " count=" << "\"" << getCount() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalCells::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalCells"
        << " count=" << m_count
             << std::endl;
   return ostr.str();
}

std::string BcalCells::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalCells"
        << " count=" << "\"" << getCount() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalBlocks::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalBlocks"
        << " count=" << m_count
             << std::endl;
   return ostr.str();
}

std::string FcalBlocks::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalBlocks"
        << " count=" << "\"" << getCount() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TofPaddles::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tofPaddles"
        << " count=" << m_count
             << std::endl;
   return ostr.str();
}

std::string TofPaddles::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tofPaddles"
        << " count=" << "\"" << getCount() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CcalBlocks::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ccalBlocks"
        << " count=" << m_count
             << std::endl;
   return ostr.str();
}

std::string CcalBlocks::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ccalBlocks"
        << " count=" << "\"" << getCount() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DircPMTs::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dircPMTs"
        << " count=" << m_count
             << std::endl;
   return ostr.str();
}

std::string DircPMTs::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dircPMTs"
        << " count=" << "\"" << getCount() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string HitStatistics::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "hitStatistics"
        << " jtag=" << "\"" << m_jtag << "\""
             << std::endl;
   if (! m_startCounters_link.empty()) {
      ostr << m_startCounters_link.begin()->toString(indent + 2);
   }
   if (! m_cdcStraws_link.empty()) {
      ostr << m_cdcStraws_link.begin()->toString(indent + 2);
   }
   if (! m_fdcPseudos_link.empty()) {
      ostr << m_fdcPseudos_link.begin()->toString(indent + 2);
   }
   if (! m_bcalCells_link.empty()) {
      ostr << m_bcalCells_link.begin()->toString(indent + 2);
   }
   if (! m_fcalBlocks_link.empty()) {
      ostr << m_fcalBlocks_link.begin()->toString(indent + 2);
   }
   if (! m_tofPaddles_link.empty()) {
      ostr << m_tofPaddles_link.begin()->toString(indent + 2);
   }
   if (! m_ccalBlocks_link.empty()) {
      ostr << m_ccalBlocks_link.begin()->toString(indent + 2);
   }
   if (! m_dircPMTs_link.empty()) {
      ostr << m_dircPMTs_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string HitStatistics::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<hitStatistics"
        << " jtag=" << "\"" << getJtag() << "\""
        << ">" << std::endl;
   if (! m_startCounters_link.empty()) {
      ostr << m_startCounters_link.begin()->toXML(indent + 2);
   }
   if (! m_cdcStraws_link.empty()) {
      ostr << m_cdcStraws_link.begin()->toXML(indent + 2);
   }
   if (! m_fdcPseudos_link.empty()) {
      ostr << m_fdcPseudos_link.begin()->toXML(indent + 2);
   }
   if (! m_bcalCells_link.empty()) {
      ostr << m_bcalCells_link.begin()->toXML(indent + 2);
   }
   if (! m_fcalBlocks_link.empty()) {
      ostr << m_fcalBlocks_link.begin()->toXML(indent + 2);
   }
   if (! m_tofPaddles_link.empty()) {
      ostr << m_tofPaddles_link.begin()->toXML(indent + 2);
   }
   if (! m_ccalBlocks_link.empty()) {
      ostr << m_ccalBlocks_link.begin()->toXML(indent + 2);
   }
   if (! m_dircPMTs_link.empty()) {
      ostr << m_dircPMTs_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</hitStatistics>"
        << std::endl;
   return ostr.str();
}

std::string ReconstructedPhysicsEvent::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "reconstructedPhysicsEvent"
        << " eventNo=" << m_eventNo
        << " runNo=" << m_runNo
             << std::endl;
   int CommentListCount=0;
   for (CommentList::iterator it = m_comment_list.begin();
        it != m_comment_list.end(); ++it)
   {
      if (++CommentListCount > m_comment_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int DataVersionStringListCount=0;
   for (DataVersionStringList::iterator it = m_dataVersionString_list.begin();
        it != m_dataVersionString_list.end(); ++it)
   {
      if (++DataVersionStringListCount > m_dataVersionString_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CcdbContextListCount=0;
   for (CcdbContextList::iterator it = m_ccdbContext_list.begin();
        it != m_ccdbContext_list.end(); ++it)
   {
      if (++CcdbContextListCount > m_ccdbContext_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int ReactionListCount=0;
   for (ReactionList::iterator it = m_reaction_list.begin();
        it != m_reaction_list.end(); ++it)
   {
      if (++ReactionListCount > m_reaction_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TagmBeamPhotonListCount=0;
   for (TagmBeamPhotonList::iterator it = m_tagmBeamPhoton_list.begin();
        it != m_tagmBeamPhoton_list.end(); ++it)
   {
      if (++TagmBeamPhotonListCount > m_tagmBeamPhoton_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TaghBeamPhotonListCount=0;
   for (TaghBeamPhotonList::iterator it = m_taghBeamPhoton_list.begin();
        it != m_taghBeamPhoton_list.end(); ++it)
   {
      if (++TaghBeamPhotonListCount > m_taghBeamPhoton_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FcalShowerListCount=0;
   for (FcalShowerList::iterator it = m_fcalShower_list.begin();
        it != m_fcalShower_list.end(); ++it)
   {
      if (++FcalShowerListCount > m_fcalShower_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalShowerListCount=0;
   for (BcalShowerList::iterator it = m_bcalShower_list.begin();
        it != m_bcalShower_list.end(); ++it)
   {
      if (++BcalShowerListCount > m_bcalShower_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CcalShowerListCount=0;
   for (CcalShowerList::iterator it = m_ccalShower_list.begin();
        it != m_ccalShower_list.end(); ++it)
   {
      if (++CcalShowerListCount > m_ccalShower_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int ChargedTrackListCount=0;
   for (ChargedTrackList::iterator it = m_chargedTrack_list.begin();
        it != m_chargedTrack_list.end(); ++it)
   {
      if (++ChargedTrackListCount > m_chargedTrack_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int StartHitListCount=0;
   for (StartHitList::iterator it = m_startHit_list.begin();
        it != m_startHit_list.end(); ++it)
   {
      if (++StartHitListCount > m_startHit_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TofPointListCount=0;
   for (TofPointList::iterator it = m_tofPoint_list.begin();
        it != m_tofPoint_list.end(); ++it)
   {
      if (++TofPointListCount > m_tofPoint_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int DircHitListCount=0;
   for (DircHitList::iterator it = m_dircHit_list.begin();
        it != m_dircHit_list.end(); ++it)
   {
      if (++DircHitListCount > m_dircHit_list.size()) {
         throw std::runtime_error("hddm_r::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   if (! m_RFtime_link.empty()) {
      ostr << m_RFtime_link.begin()->toString(indent + 2);
   }
   if (! m_trigger_link.empty()) {
      ostr << m_trigger_link.begin()->toString(indent + 2);
   }
   if (! m_detectorMatches_link.empty()) {
      ostr << m_detectorMatches_link.begin()->toString(indent + 2);
   }
   if (! m_hitStatistics_link.empty()) {
      ostr << m_hitStatistics_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string ReconstructedPhysicsEvent::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<reconstructedPhysicsEvent"
        << " eventNo=" << "\"" << getEventNo() << "\""
        << " runNo=" << "\"" << getRunNo() << "\""
        << ">" << std::endl;
   int CommentListCount=0;
   for (CommentList::iterator it = m_comment_list.begin();
        it != m_comment_list.end(); ++it)
   {
      if (++CommentListCount > m_comment_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int DataVersionStringListCount=0;
   for (DataVersionStringList::iterator it = m_dataVersionString_list.begin();
        it != m_dataVersionString_list.end(); ++it)
   {
      if (++DataVersionStringListCount > m_dataVersionString_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CcdbContextListCount=0;
   for (CcdbContextList::iterator it = m_ccdbContext_list.begin();
        it != m_ccdbContext_list.end(); ++it)
   {
      if (++CcdbContextListCount > m_ccdbContext_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int ReactionListCount=0;
   for (ReactionList::iterator it = m_reaction_list.begin();
        it != m_reaction_list.end(); ++it)
   {
      if (++ReactionListCount > m_reaction_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TagmBeamPhotonListCount=0;
   for (TagmBeamPhotonList::iterator it = m_tagmBeamPhoton_list.begin();
        it != m_tagmBeamPhoton_list.end(); ++it)
   {
      if (++TagmBeamPhotonListCount > m_tagmBeamPhoton_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TaghBeamPhotonListCount=0;
   for (TaghBeamPhotonList::iterator it = m_taghBeamPhoton_list.begin();
        it != m_taghBeamPhoton_list.end(); ++it)
   {
      if (++TaghBeamPhotonListCount > m_taghBeamPhoton_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FcalShowerListCount=0;
   for (FcalShowerList::iterator it = m_fcalShower_list.begin();
        it != m_fcalShower_list.end(); ++it)
   {
      if (++FcalShowerListCount > m_fcalShower_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalShowerListCount=0;
   for (BcalShowerList::iterator it = m_bcalShower_list.begin();
        it != m_bcalShower_list.end(); ++it)
   {
      if (++BcalShowerListCount > m_bcalShower_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CcalShowerListCount=0;
   for (CcalShowerList::iterator it = m_ccalShower_list.begin();
        it != m_ccalShower_list.end(); ++it)
   {
      if (++CcalShowerListCount > m_ccalShower_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int ChargedTrackListCount=0;
   for (ChargedTrackList::iterator it = m_chargedTrack_list.begin();
        it != m_chargedTrack_list.end(); ++it)
   {
      if (++ChargedTrackListCount > m_chargedTrack_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int StartHitListCount=0;
   for (StartHitList::iterator it = m_startHit_list.begin();
        it != m_startHit_list.end(); ++it)
   {
      if (++StartHitListCount > m_startHit_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TofPointListCount=0;
   for (TofPointList::iterator it = m_tofPoint_list.begin();
        it != m_tofPoint_list.end(); ++it)
   {
      if (++TofPointListCount > m_tofPoint_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int DircHitListCount=0;
   for (DircHitList::iterator it = m_dircHit_list.begin();
        it != m_dircHit_list.end(); ++it)
   {
      if (++DircHitListCount > m_dircHit_list.size()) {
         throw std::runtime_error("hddm_r::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   if (! m_RFtime_link.empty()) {
      ostr << m_RFtime_link.begin()->toXML(indent + 2);
   }
   if (! m_trigger_link.empty()) {
      ostr << m_trigger_link.begin()->toXML(indent + 2);
   }
   if (! m_detectorMatches_link.empty()) {
      ostr << m_detectorMatches_link.begin()->toXML(indent + 2);
   }
   if (! m_hitStatistics_link.empty()) {
      ostr << m_hitStatistics_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</reconstructedPhysicsEvent>"
        << std::endl;
   return ostr.str();
}

std::string HDDM::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "HDDM"
             << std::endl;
   if (! m_reconstructedPhysicsEvent_link.empty()) {
      ostr << m_reconstructedPhysicsEvent_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string HDDM::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<HDDM"
        << " class=" << "\"" << getClass() << "\""
        << " version=" << "\"" << getVersion() << "\""
        << " xmlns=" << "\"" << getXmlns() << "\""
        << ">" << std::endl;
   if (! m_reconstructedPhysicsEvent_link.empty()) {
      ostr << m_reconstructedPhysicsEvent_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</HDDM>"
        << std::endl;
   return ostr.str();
}


streamposition::streamposition()
 : block_start(), block_offset(), block_status() {}

streamposition::streamposition(uint64_t start, uint32_t offset, uint32_t status)
 : block_start(start), block_offset(offset), block_status(status) {}

istream::istream(std::istream &src)
 : m_istr(src),
   m_status_bits(0)
{
   char hdr[10];
   src.getline(hdr,7);
   m_documentString = hdr;
   if (m_documentString != "<HDDM ") {
      throw std::runtime_error("hddm_r::istream::istream error - invalid hddm header");
   }
   src.clear();
   std::string line;
   while (std::getline(src,line).good()) {
      m_documentString += line + "\n";
      if (line == "</HDDM>") {
         break;
      }
   }
   if (src.bad()) {
      throw std::runtime_error("hddm_r::istream::istream error - invalid hddm header");
   }
   pthread_mutex_init(&m_streambuf_mutex,0);
   for (int i=0; i<threads::max_threads; ++i) {
      my_thread_private[i] = 0;
   }
   m_leftovers[0] = 0;
   init_private_data();
}

istream::~istream() {
   pthread_mutex_destroy(&m_streambuf_mutex);
   for (int i=0; i<threads::max_threads; ++i) {
      thread_private_data *my_private = my_thread_private[i];
      if (my_private != 0) {
         if (MY(istr))
            delete MY(istr);
         if (MY(xcmp))
            delete MY(xcmp);
         if (MY(xstr))
            delete MY(xstr);
         if (MY(sbuf))
            delete MY(sbuf);
         delete [] MY(event_buffer);
         delete my_private;
      }
   }
}

void istream::init_private_data() {
   int threadID = threads::getID();
   if (my_thread_private[threadID] == 0) {
      my_thread_private[threadID] = new thread_private_data;
   }
   MY_SETUP
   MY(genome).m_tagname = "HDDM";
   MY(genome).m_sequence = synthesize(m_documentString,0,HDDM::DocumentString(),0);
   MY(event_buffer) = new char[MY(event_buffer_size) = 100000];
   MY(sbuf) = new istreambuffer(MY(event_buffer),MY(event_buffer_size));
   MY(xstr) = new xstream::xdr::istream(MY(sbuf));
   MY(istr) = new std::istream(m_istr.rdbuf());
   MY(xcmp) = 0;
   MY(event_size) = 0;
   MY(last_start) = 0;
   MY(last_offset) = 0;
   MY(next_start) = 0;
   MY(events_to_skip) = 0;
   MY(status_bits) = 0;
   MY(mutex_lock) = 0;
   MY(bytes_read) = 0;
   MY(records_read) = 0;
   MY(sequencing) = 0;
   MY(hit_eof) = 0;
}

streamposition istream::getPosition() {
   MY_SETUP
   streamposition pos;
   pos.block_start = MY(last_start);
   pos.block_offset = MY(last_offset);
   pos.block_status = MY(status_bits);
   return pos;
}

void istream::setPosition(const streamposition &pos) {
   MY_SETUP
   m_status_bits = pos.block_status;
   lock_streambufs();
   update_streambufs();
   unlock_streambufs();
   if (MY(status_bits) & (k_bz2_compression | k_z_compression)) {
      if (((int)m_status_bits & k_bits_compression) != 0 &&
          ((int)m_status_bits & k_can_reposition) == 0)
      {
         throw std::runtime_error("hddm_r::istream::setPosition error - "
                                  "old-format hddm input file does not support repositioning.");
      }
      else if (MY(xcmp) == 0) {
         throw std::runtime_error("hddm_r::istream::setPosition error - "
                                  "compressed stream encountered but no decompressor configured.");
      }
      if (MY(status_bits) & k_z_compression) {
         ((xstream::z::istreambuf*)MY(xcmp))->
             set_new_position(pos.block_start, pos.block_offset);
      }
      else if (MY(status_bits) & k_bz2_compression) {
         ((xstream::bz::istreambuf*)MY(xcmp))->
             set_new_position(pos.block_start, pos.block_offset);
      }
   }
   else {
      MY(next_start) = pos.block_start;
   }
}

void istream::update_streambufs() {
   MY_SETUP
   if ((int)m_status_bits != MY(status_bits)) {
      configure_streambufs();
   }
}

void istream::configure_streambufs() {
   MY_SETUP
   int oldcmp = MY(status_bits) & k_bits_compression;
   int newcmp = (int)m_status_bits & k_bits_compression;
   if (oldcmp != newcmp) {
      if (oldcmp != k_no_compression) {
         MY(istr)->rdbuf(m_istr.rdbuf());
         delete MY(xcmp);
         MY(xcmp) = 0;
      }
      if (newcmp == k_z_compression) {
         //std::cerr << "input switched on z compression" << std::endl;
         MY(xcmp) = new xstream::z::istreambuf(m_istr.rdbuf(), m_leftovers,
                                                        sizeof(m_leftovers));
         MY(istr)->rdbuf(MY(xcmp));
      }
      else if (newcmp == k_bz2_compression) {
         //std::cerr << "input switched on bz2 compression" << std::endl;
         MY(xcmp) = new xstream::bz::istreambuf(m_istr.rdbuf(), m_leftovers,
                                                         sizeof(m_leftovers));
         MY(istr)->rdbuf(MY(xcmp));
      }
      else if (newcmp != k_no_compression) {
         throw std::runtime_error("hddm_r::istream::configure_streambufs error - "
                                  "unrecognized compression flag requested.");
      }
   }
   MY(status_bits) = m_status_bits;
}

void istream::lock_streambufs() {
   MY_SETUP
   if (MY(mutex_lock) != 0) {
      unlock_streambufs();
      throw std::runtime_error("hddm_r::istream::lock_streambufs error - "
                               "mutex lock requested when lock already held.");
   }
   if ((MY(status_bits) & k_bits_compression) == k_no_compression) {
      pthread_mutex_lock(&m_streambuf_mutex);
      MY(mutex_lock) = 1;
   }
   else if ((MY(status_bits) & k_bits_compression) == k_z_compression) {
      ((xstream::z::istreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);
      MY(mutex_lock) = 2;
   }
   else if ((MY(status_bits) & k_bits_compression) == k_bz2_compression) {
      ((xstream::bz::istreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);
      MY(mutex_lock) = 3;
   }
   else {
      MY(mutex_lock) = -1;
   }
}

void istream::unlock_streambufs() {
   MY_SETUP
   if (MY(mutex_lock) == 0) {
      throw std::runtime_error("hddm_r::istream::unlock_streambufs error - "
                               "mutex unlock requested when lock not held.");
   }
   else if (MY(mutex_lock) == 1) {
      pthread_mutex_unlock(&m_streambuf_mutex);
   }
   else if (MY(mutex_lock) == 2) {
      ((xstream::z::istreambuf*)MY(xcmp))->set_streambuf_mutex(0);
   }
   else if (MY(mutex_lock) == 3) {
      ((xstream::bz::istreambuf*)MY(xcmp))->set_streambuf_mutex(0);
   }
   MY(mutex_lock) = 0;
}

istream &istream::operator>>(HDDM &record) {
   MY_SETUP
   while (1 == 1) {
      lock_streambufs();
      MY(event_size) = 0;
      while (MY(event_size) == 0) {
         update_streambufs();
         if (MY(status_bits) & (k_bz2_compression | k_z_compression)) {
            if (MY(status_bits) & k_can_reposition) {
               MY(istr)->clear();
               MY(istr)->read(MY(event_buffer),4);
               MY(bytes_read) += MY(istr)->gcount();
               if (!MY(istr)->good()) {
                  unlock_streambufs();
                  MY(hit_eof) = 1;
                  return *this;
               }
               if (MY(status_bits) & k_bz2_compression) {
                  MY(last_start)  = dynamic_cast<xstream::bz::istreambuf*>
                                    (MY(xcmp))->get_block_start();
                  MY(last_offset) = dynamic_cast<xstream::bz::istreambuf*>
                                    (MY(xcmp))->get_block_offset();
               }
               else {
                  MY(last_start)  = dynamic_cast<xstream::z::istreambuf*>
                                    (MY(xcmp))->get_block_start();
                  MY(last_offset) = dynamic_cast<xstream::z::istreambuf*>
                                    (MY(xcmp))->get_block_offset();
               }
               MY(last_offset) -= 4;
            }
            else {
               MY(last_start) = 0;
               MY(last_offset) = 0;
            }
         }
         else {
            if (MY(next_start) > 0) {
               m_istr.seekg(MY(next_start), std::ios_base::beg);
               MY(istr)->clear();
               MY(last_start) = MY(next_start);
               MY(last_offset) = 0;
               MY(next_start) = 0;
            }
            else {
               MY(last_start) = m_istr.tellg();
               MY(last_offset) = 0;
            }
            MY(istr)->read(MY(event_buffer),4);
            MY(bytes_read) += MY(istr)->gcount();
            if (!MY(istr)->good()) {
               unlock_streambufs();
               MY(hit_eof) = 1;
               return *this;
            }
         }
         MY(hit_eof) = 0;
         MY(sbuf)->reset();
         *MY(xstr) >> MY(event_size);
         if (MY(event_size) == 1) {
            MY(istr)->read(MY(event_buffer)+4,4);
            MY(bytes_read) += MY(istr)->gcount();
            if (!MY(istr)->good()) {
               unlock_streambufs();
               throw std::runtime_error("hddm_r::istream::operator>> error -"
                                        " read error on token input!");
            }
            int size;
            *MY(xstr) >> size;
            MY(istr)->read(MY(event_buffer)+8,size);
            MY(bytes_read) += MY(istr)->gcount();
            if (!MY(istr)->good()) {
               unlock_streambufs();
               throw std::runtime_error("hddm_r::istream::operator>> error -"
                                        " read error on token input!");
            }
            int format, flags;
            *MY(xstr) >> format >> flags;
            if (format != 0) {
               unlock_streambufs();
               throw std::runtime_error("hddm_r::istream::operator>> error - "
                                        "unsupported compression format!");
            }
            m_status_bits.store(flags);
            MY(event_size) = 0;
         }
      }
      if (MY(event_size)+8 > MY(event_buffer_size)) {
         delete MY(xstr);
         delete MY(sbuf);
         char *newbuf = new char[MY(event_buffer_size) = MY(event_size)+1000];
         MY(sbuf) = new istreambuffer(newbuf, MY(event_buffer_size));
         MY(xstr) = new xstream::xdr::istream(MY(sbuf));
         memcpy(newbuf,MY(event_buffer),4);
         delete [] MY(event_buffer);
         MY(event_buffer) = newbuf;
      }
      MY(istr)->read(MY(event_buffer)+4,MY(event_size));
      MY(bytes_read) += MY(istr)->gcount();
      MY(records_read)++;
      if (!MY(istr)->good()) {
         unlock_streambufs();
         throw std::runtime_error("hddm_r::istream::operator>> error -"
                                  " read error in mid-record!");
      }
      if ((MY(status_bits) & k_crc32_integrity) != 0) {
         unsigned int recorded_crc;
         char crcbuf[10];
         istreambuffer sbuf(crcbuf,10);
         xstream::xdr::istream xstr(&sbuf);
         MY(istr)->read(crcbuf,4);
         MY(bytes_read) += MY(istr)->gcount();
         xstr >> recorded_crc;
         xstream::digest::crc32 crc;
         std::ostream out(&crc);
         out.write(MY(event_buffer),MY(event_size)+4);
         out.flush();
         if (crc.digest() != recorded_crc) {
            char errmsg[] = 
                 "WARNING: crc data integrity check failed"
                 " on hddm_r input stream!"
                 "\nThis may be the result of a bug in the"
                 " xstream library if you are analyzing a data"
                 " file that was generated by code prior to svn"
                 " rev 18530.\nIf this concerns you, regenerate"
                 " using a newer build of the sim-recon tools"
                 " and it should go away.\n";
            if ((MY(status_bits) & 0x02) == 0) {
               std::cerr << errmsg << std::endl;
               MY(status_bits) |= 0x02;
            }
            //unlock_streambufs();
            //throw std::runtime_error("hddm_r::istream::operator>> error -"
            //                 " crc check error on input stream!");
         }
      }
      unlock_streambufs();
      if (MY(events_to_skip) > 0) {
         --MY(events_to_skip);
      }
      else {
         break;
      }
   }
   MY(sbuf)->reset();
   MY(sequencing) = 0;
   MY(codon) = &MY(genome);
   *this >> (streamable&)record;
   return *this;
}

ostream::ostream(std::ostream &src)
 : m_ostr(src),
   m_status_bits(k_default_status)
{
   m_ostr << HDDM::DocumentString();
   if (!m_ostr.good()) {
      throw std::runtime_error("hddm_r::ostream::ostream(ostream) "
                               "error - write error on header output!");
   }
   pthread_mutex_init(&m_streambuf_mutex,0);
   for (int i=0; i<threads::max_threads; ++i) {
      my_thread_private[i] = 0;
   }
   init_private_data();
}

ostream::~ostream() {
   pthread_mutex_destroy(&m_streambuf_mutex);
   for (int i=0; i<threads::max_threads; ++i) {
      thread_private_data *my_private = my_thread_private[i];
      if (my_private != 0) {
         if (MY(xstr)) {
            delete MY(xstr);
         }
         if (MY(sbuf)) {
            delete MY(sbuf);
         }
         if (MY(xcmp)) {
            MY(xcmp)->pubsync();
            MY(ostr)->rdbuf(m_ostr.rdbuf());
            delete MY(xcmp);
         }
         if (MY(ostr)) {
            MY(ostr)->flush();
            delete MY(ostr);
         }
         delete [] MY(event_buffer);
         delete my_private;
      }
   }
}

void ostream::init_private_data() {
   int threadID = threads::getID();
   if (my_thread_private[threadID] == 0) {
      my_thread_private[threadID] = new thread_private_data;
   }
   MY_SETUP
   MY(event_buffer) = new char[MY(event_buffer_size) = 100000];
   MY(sbuf) = new ostreambuffer(MY(event_buffer),MY(event_buffer_size));
   MY(xstr) = new xstream::xdr::ostream(MY(sbuf));
   MY(ostr) = new std::ostream(m_ostr.rdbuf());
   MY(xcmp) = 0;
   MY(last_start) = 0;
   MY(last_offset) = 0;
   MY(records_written) = 0;
   MY(bytes_written) = 0;
   MY(status_bits) = 0;
   MY(mutex_lock) = 0;
}

void ostream::setCompression(int flags) {
   MY_SETUP
   int oldcmp = (int)m_status_bits & k_bits_compression;
   int newcmp = flags & k_bits_compression;
   if (oldcmp != newcmp) {
      m_status_bits.fetch_and(~k_bits_compression | flags);
      m_status_bits.fetch_or(k_bits_compression & flags);
      if (newcmp != 0)
         m_status_bits.fetch_or(k_can_reposition);
      MY(sbuf)->reset();
      *MY(xstr) << 1 << 8 << 0 << (int)m_status_bits;
      lock_streambufs();
      MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());
      if (!MY(ostr)->good()) {
         unlock_streambufs();
         throw std::runtime_error("hddm_r::ostream::setCompression"
                                  " error - write error on token output!");
      }
      MY(ostr)->flush();
      update_streambufs();
      unlock_streambufs();
   }
}

void ostream::setIntegrityChecks(int flags) {
   MY_SETUP
   int oldint = (int)m_status_bits & k_bits_integrity;
   int newint = flags & k_bits_integrity;
   if (oldint != newint) {
      m_status_bits.fetch_and(~k_bits_integrity | flags);
      m_status_bits.fetch_or(k_bits_integrity & flags);
      MY(sbuf)->reset();
      *MY(xstr) << 1 << 8 << 0 << (int)m_status_bits;
      lock_streambufs();
      MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());
      if (!MY(ostr)->good()) {
         unlock_streambufs();
         throw std::runtime_error("hddm_r::ostream::setIntegrityChecks"
                                 " error - write error on token output!");
      }
      MY(ostr)->flush();
      update_streambufs();
      unlock_streambufs();
   }
}

streamposition ostream::getPosition() {
   MY_SETUP
   streamposition pos;
   pos.block_start = MY(last_start);
   pos.block_start = MY(last_offset);
   pos.block_status = MY(status_bits);
   return pos;
}

void ostream::update_streambufs() {
   MY_SETUP
   if ((int)m_status_bits != MY(status_bits)) {
      configure_streambufs();
   }
}

void ostream::configure_streambufs() {
   MY_SETUP
   int oldcmp = MY(status_bits) & k_bits_compression;
   int newcmp = (int)m_status_bits & k_bits_compression;
   if (oldcmp != newcmp) {
      if (oldcmp != k_no_compression) {
         MY(ostr)->rdbuf(m_ostr.rdbuf());
         delete MY(xcmp);
         MY(xcmp) = 0;
      }
      if (newcmp == k_z_compression) {
         //std::cerr << "output switched on z compression" << std::endl;
         MY(xcmp) = new xstream::z::ostreambuf(m_ostr.rdbuf());
         MY(ostr)->rdbuf(MY(xcmp));
      }
      else if (newcmp == k_bz2_compression) {
         //std::cerr << "output switched on bz2 compression" << std::endl;
         MY(xcmp )= new xstream::bz::ostreambuf(m_ostr.rdbuf());
         MY(ostr)->rdbuf(MY(xcmp));
      }
      else if (newcmp != k_no_compression) {
         throw std::runtime_error("hddm_r::ostream::configure_streambufs error - "
                                  "unrecognized compression flag requested.");
      }
   }
   MY(status_bits) = m_status_bits;
}

void ostream::lock_streambufs() {
   MY_SETUP
   if (MY(mutex_lock) != 0) {
      unlock_streambufs();
      throw std::runtime_error("hddm_r::ostream::lock_streambufs error - "
                               "mutex lock requested when lock already held.");
   }
   if ((MY(status_bits) & k_bits_compression) == k_no_compression) {
      pthread_mutex_lock(&m_streambuf_mutex);
      MY(mutex_lock) = 1;
   }
   else if ((MY(status_bits) & k_bits_compression) == k_z_compression) {
      ((xstream::z::ostreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);
      MY(mutex_lock) = 2;
   }
   else if ((MY(status_bits) & k_bits_compression) == k_bz2_compression) {
      ((xstream::bz::ostreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);
      MY(mutex_lock) = 3;
   }
   else {
      MY(mutex_lock) = -1;
   }
}

void ostream::unlock_streambufs() {
   MY_SETUP
   if (MY(mutex_lock) == 0) {
      throw std::runtime_error("hddm_r::ostream::unlock_streambufs error - "
                               "mutex unlock requested when lock not held.");
   }
   else if (MY(mutex_lock) == 1) {
      pthread_mutex_unlock(&m_streambuf_mutex);
   }
   else if (MY(mutex_lock) == 2) {
      ((xstream::z::ostreambuf*)MY(xcmp))->set_streambuf_mutex(0);
   }
   else if (MY(mutex_lock) == 3) {
      ((xstream::bz::ostreambuf*)MY(xcmp))->set_streambuf_mutex(0);
   }
   MY(mutex_lock) = 0;
}

int istream::getTag(const std::string &src, int start,
                    std::string &tag, int &level)
{
   tag = "";
   size_t p_btag = src.find("<",start);
   size_t p_bline = src.find_last_of("\n",p_btag);
   if (p_bline == std::string::npos)
   {
      p_bline = 0;
   }
   else
   {
      ++p_bline;
   }
   level = (p_btag-p_bline)/2;
   size_t p_etag = p_btag;
   for (size_t quotes=0; p_etag < src.size(); ++p_etag) {
      if (src[p_etag] == '"') {
         tag += "\"";
         ++quotes;
      }
      else if (quotes/2*2 != quotes) {
         tag += src[p_etag];
      }
      else if (src.find_first_of(" \t\n",p_etag) == 0) {
         tag += " ";
         p_etag = src.find_first_not_of(" \t\n",p_etag)-1;
      }
      else if (src[p_etag] == '>') {
         tag += ">";
         break;
      }
      else {
         tag += src[p_etag];
      }
   }
   if (p_etag == src.size()) {
      std::stringstream sstr;
      sstr << "hddm_r::istream::getTag"
           << " error - bad header format" << std::endl
           << "   tag " << tag << " at position " << start
           << std::endl;
      throw std::runtime_error(sstr.str());
   }
   return p_etag+2;
}

int istream::getEndTag(const std::string &src, int start,
                       const std::string &tag)
{
   if (tag.rfind("/>") == tag.size()-2) {
      return src.find(tag,start) + tag.size()+1;
   }
   else {
      std::string etag = "</";
      etag += tag.substr(1,tag.find_first_of(' ')-1) + ">";
      size_t p_etag = src.find(etag,start);
      size_t p_quote = src.find_first_of('"',start);
      while (p_quote != std::string::npos && p_quote < p_etag) {
         p_quote = src.find_first_of('"',p_quote+1);
         if (p_quote > p_etag) {
            p_etag = src.find(etag,p_quote+1);
         }
         p_quote = src.find_first_of('"',p_quote+1);
      }
      if (p_etag == std::string::npos) {
         std::stringstream sstr;
         sstr << "hddm_r::istream::getEndTag"
              << " error - bad header format" << std::endl
              << "   tag " << tag << " at position " << start
              << std::endl
              << "   end tag " << etag << " not found."
              << std::endl;
         throw std::runtime_error(sstr.str());
      }
      return p_etag + etag.size()+1;
   }
}

void istream::collide(const std::string &itag, const std::string &rtag) {
   std::string itagname = itag.substr(1,itag.find(" ")-1);
   std::string rtagname = rtag.substr(1,rtag.find(" ")-1);
   std::string errmsg = "hddm_r::istream::collide warning:\n"
         "tag " + itagname + " in input file "
         "does not match c++ header hddm_r.hpp\n"
         "  input file: " + itag + "\n"
         "  c++ header: " + rtag + "\n"
         "  === Tag " + itagname + " will be ignored,"
         " rebuild to cure the problem ===";
   if (itagname != "HDDM") {
      std::cerr << errmsg << std::endl;
   }
   else {
      throw std::runtime_error(errmsg);
   }
}

chromosome istream::synthesize(const std::string &src, int p_src,
                               const std::string &ref, int p_ref)
{
   chromosome chrom;
   int slevel, rlevel;
   std::string stag, rtag;
   p_src = getTag(src,p_src,stag,slevel);
   p_ref = getTag(ref,p_ref,rtag,rlevel);
   std::string stagname = stag.substr(1,stag.find(" ")-1);
   std::string rtagname = rtag.substr(1,rtag.find(" ")-1);
   if (stagname != rtagname) {
      throw std::runtime_error("hddm_r::istream::synthesize error - matching algorithm error #2");
   }
   else if (!tags_match(stag,rtag)) {
      collide(stag,rtag);
      return chrom;
   }

   int p2_src, p2_ref;
   int s2level, r2level;
   std::string s2tag, r2tag;
   getTag(src,p2_src=p_src,s2tag,s2level);
   while (s2level > slevel) {
      codon *gene = new codon();
      std::string s2tagname = s2tag.substr(1,s2tag.find(" ")-1);
      getTag(ref,p2_ref=p_ref,r2tag,r2level);
      int order_of_this_tag_in_ref = 1;
      while (r2level == s2level) {
         std::string r2tagname = r2tag.substr(1,r2tag.find(" ")-1);
         if (s2tagname == r2tagname) {
            if (!tags_match(s2tag,r2tag)) {
               collide(s2tag,r2tag);
               break;
            }
            else {
               gene->m_order = order_of_this_tag_in_ref;
            }
            gene->m_sequence = synthesize(src,p2_src,ref,p2_ref);
            break;
         }
         p2_ref = getEndTag(ref,p2_ref,r2tag);
         getTag(ref,p2_ref,r2tag,r2level);
         ++order_of_this_tag_in_ref;
      }
      gene->m_tagname = s2tagname;
      chrom.push_back(*gene);
      delete gene;
      p2_src = getEndTag(src,p2_src,s2tag);
      getTag(src,p2_src,s2tag,s2level);
   }
   return chrom;
}
