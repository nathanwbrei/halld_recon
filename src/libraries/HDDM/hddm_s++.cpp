/*
 * hddm_s.cpp - DO NOT EDIT THIS FILE
 *
 * This file was generated automatically by hddm-cpp from the file
 * libraries/HDDM/event.xml

 * This c++ source implements the methods for the classes 
 * described in the data model (from libraries/HDDM/event.xml). 
 *
 * The hddm data model tool set was written by
 * Richard Jones, University of Connecticut.
 *
 * For more information see the following web site
 *
 * http://zeus.phys.uconn.edu/halld/datamodel/doc
 */

#include <sstream>
#include "hddm_s.hpp"

#ifndef _FILE_OFFSET_BITS
# define _FILE_OFFSET_BITS 64
#endif

using namespace hddm_s;

std::atomic<int> threads::next_unique_ID(0);
thread_local int threads::ID(0);

static int tags_match(const std::string &a, const std::string &b)
{
   if (a == b) {
      return true;
   }
   else if (a.find("<HDDM ") == 0 && b.find("<HDDM ") == 0) {
      return true;
   }
   else {
      int len = a.length();
      int ia=0;
      int ib=0;
      for (; a[ia] == b[ib]; ++ia, ++ib, --len) {}
      for (; a[ia] == ' '; ++ia, --len) {}
      for (; a[ia] == '/'; ++ia, --len) {}
      for (; b[ib] == ' '; ++ib) {}
      for (; b[ib] == '/'; ++ib) {}
      return (a.substr(ia) == b.substr(ib));
   }
}

std::string Geometry::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "geometry"
        << " md5reconstruction=" << "\"" << m_md5reconstruction << "\""
        << " md5simulation=" << "\"" << m_md5simulation << "\""
        << " md5smear=" << "\"" << m_md5smear << "\""
             << std::endl;
   return ostr.str();
}

std::string Geometry::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<geometry"
        << " md5reconstruction=" << "\"" << getMd5reconstruction() << "\""
        << " md5simulation=" << "\"" << getMd5simulation() << "\""
        << " md5smear=" << "\"" << getMd5smear() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DataVersionString::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dataVersionString"
        << " text=" << "\"" << m_text << "\""
             << std::endl;
   return ostr.str();
}

std::string DataVersionString::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dataVersionString"
        << " text=" << "\"" << getText() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CcdbContext::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ccdbContext"
        << " text=" << "\"" << m_text << "\""
             << std::endl;
   return ostr.str();
}

std::string CcdbContext::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ccdbContext"
        << " text=" << "\"" << getText() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Momentum::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "momentum"
        << " E=" << m_E
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
             << std::endl;
   return ostr.str();
}

std::string Momentum::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<momentum"
        << " E=" << "\"" << getE() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Polarization::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "polarization"
        << " Px=" << m_Px
        << " Py=" << m_Py
        << " Pz=" << m_Pz
             << std::endl;
   return ostr.str();
}

std::string Polarization::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<polarization"
        << " Px=" << "\"" << getPx() << "\""
        << " Py=" << "\"" << getPy() << "\""
        << " Pz=" << "\"" << getPz() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Properties::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "properties"
        << " charge=" << m_charge
        << " mass=" << m_mass
             << std::endl;
   return ostr.str();
}

std::string Properties::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<properties"
        << " charge=" << "\"" << getCharge() << "\""
        << " mass=" << "\"" << getMass() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Beam::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "beam"
        << " type=" << ParticleType((Particle_t)m_type)
             << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toString(indent + 2);
   }
   if (! m_polarization_link.empty()) {
      ostr << m_polarization_link.begin()->toString(indent + 2);
   }
   if (! m_properties_link.empty()) {
      ostr << m_properties_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string Beam::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<beam"
        << " type=\"" << ParticleType((Particle_t)m_type) << "\""
        << ">" << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toXML(indent + 2);
   }
   if (! m_polarization_link.empty()) {
      ostr << m_polarization_link.begin()->toXML(indent + 2);
   }
   if (! m_properties_link.empty()) {
      ostr << m_properties_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</beam>"
        << std::endl;
   return ostr.str();
}

std::string Target::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "target"
        << " type=" << ParticleType((Particle_t)m_type)
             << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toString(indent + 2);
   }
   if (! m_polarization_link.empty()) {
      ostr << m_polarization_link.begin()->toString(indent + 2);
   }
   if (! m_properties_link.empty()) {
      ostr << m_properties_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string Target::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<target"
        << " type=\"" << ParticleType((Particle_t)m_type) << "\""
        << ">" << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toXML(indent + 2);
   }
   if (! m_polarization_link.empty()) {
      ostr << m_polarization_link.begin()->toXML(indent + 2);
   }
   if (! m_properties_link.empty()) {
      ostr << m_properties_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</target>"
        << std::endl;
   return ostr.str();
}

std::string Product::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "product"
        << " decayVertex=" << m_decayVertex
        << " id=" << m_id
        << " mech=" << m_mech
        << " parentid=" << m_parentid
        << " pdgtype=" << m_pdgtype
        << " type=" << ParticleType((Particle_t)m_type)
             << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toString(indent + 2);
   }
   if (! m_polarization_link.empty()) {
      ostr << m_polarization_link.begin()->toString(indent + 2);
   }
   if (! m_properties_link.empty()) {
      ostr << m_properties_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string Product::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<product"
        << " decayVertex=" << "\"" << getDecayVertex() << "\""
        << " id=" << "\"" << getId() << "\""
        << " mech=" << "\"" << getMech() << "\""
        << " parentid=" << "\"" << getParentid() << "\""
        << " pdgtype=" << "\"" << getPdgtype() << "\""
        << " type=\"" << ParticleType((Particle_t)m_type) << "\""
        << ">" << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toXML(indent + 2);
   }
   if (! m_polarization_link.empty()) {
      ostr << m_polarization_link.begin()->toXML(indent + 2);
   }
   if (! m_properties_link.empty()) {
      ostr << m_properties_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</product>"
        << std::endl;
   return ostr.str();
}

std::string Origin::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "origin"
        << " t=" << m_t
        << " vx=" << m_vx
        << " vy=" << m_vy
        << " vz=" << m_vz
             << std::endl;
   return ostr.str();
}

std::string Origin::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<origin"
        << " t=" << "\"" << getT() << "\""
        << " vx=" << "\"" << getVx() << "\""
        << " vy=" << "\"" << getVy() << "\""
        << " vz=" << "\"" << getVz() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Vertex::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "vertex"
             << std::endl;
   int ProductListCount=0;
   for (ProductList::iterator it = m_product_list.begin();
        it != m_product_list.end(); ++it)
   {
      if (++ProductListCount > m_product_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   if (! m_origin_link.empty()) {
      ostr << m_origin_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string Vertex::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<vertex"
        << ">" << std::endl;
   int ProductListCount=0;
   for (ProductList::iterator it = m_product_list.begin();
        it != m_product_list.end(); ++it)
   {
      if (++ProductListCount > m_product_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   if (! m_origin_link.empty()) {
      ostr << m_origin_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</vertex>"
        << std::endl;
   return ostr.str();
}

std::string Random::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "random"
        << " seed1=" << m_seed1
        << " seed2=" << m_seed2
        << " seed3=" << m_seed3
        << " seed4=" << m_seed4
             << std::endl;
   return ostr.str();
}

std::string Random::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<random"
        << " seed1=" << "\"" << getSeed1() << "\""
        << " seed2=" << "\"" << getSeed2() << "\""
        << " seed3=" << "\"" << getSeed3() << "\""
        << " seed4=" << "\"" << getSeed4() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string UserDataFloat::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "userDataFloat"
        << " data=" << m_data
        << " meaning=" << "\"" << m_meaning << "\""
             << std::endl;
   return ostr.str();
}

std::string UserDataFloat::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<userDataFloat"
        << " data=" << "\"" << getData() << "\""
        << " meaning=" << "\"" << getMeaning() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string UserDataInt::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "userDataInt"
        << " data=" << m_data
        << " meaning=" << "\"" << m_meaning << "\""
             << std::endl;
   return ostr.str();
}

std::string UserDataInt::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<userDataInt"
        << " data=" << "\"" << getData() << "\""
        << " meaning=" << "\"" << getMeaning() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string UserData::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "userData"
        << " description=" << "\"" << m_description << "\""
             << std::endl;
   int UserDataFloatListCount=0;
   for (UserDataFloatList::iterator it = m_userDataFloat_list.begin();
        it != m_userDataFloat_list.end(); ++it)
   {
      if (++UserDataFloatListCount > m_userDataFloat_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int UserDataIntListCount=0;
   for (UserDataIntList::iterator it = m_userDataInt_list.begin();
        it != m_userDataInt_list.end(); ++it)
   {
      if (++UserDataIntListCount > m_userDataInt_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string UserData::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<userData"
        << " description=" << "\"" << getDescription() << "\""
        << ">" << std::endl;
   int UserDataFloatListCount=0;
   for (UserDataFloatList::iterator it = m_userDataFloat_list.begin();
        it != m_userDataFloat_list.end(); ++it)
   {
      if (++UserDataFloatListCount > m_userDataFloat_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int UserDataIntListCount=0;
   for (UserDataIntList::iterator it = m_userDataInt_list.begin();
        it != m_userDataInt_list.end(); ++it)
   {
      if (++UserDataIntListCount > m_userDataInt_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</userData>"
        << std::endl;
   return ostr.str();
}

std::string Reaction::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "reaction"
        << " type=" << m_type
        << " weight=" << m_weight
             << std::endl;
   if (! m_beam_link.empty()) {
      ostr << m_beam_link.begin()->toString(indent + 2);
   }
   if (! m_target_link.empty()) {
      ostr << m_target_link.begin()->toString(indent + 2);
   }
   int VertexListCount=0;
   for (VertexList::iterator it = m_vertex_list.begin();
        it != m_vertex_list.end(); ++it)
   {
      if (++VertexListCount > m_vertex_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   if (! m_random_link.empty()) {
      ostr << m_random_link.begin()->toString(indent + 2);
   }
   int UserDataListCount=0;
   for (UserDataList::iterator it = m_userData_list.begin();
        it != m_userData_list.end(); ++it)
   {
      if (++UserDataListCount > m_userData_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string Reaction::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<reaction"
        << " type=" << "\"" << getType() << "\""
        << " weight=" << "\"" << getWeight() << "\""
        << ">" << std::endl;
   if (! m_beam_link.empty()) {
      ostr << m_beam_link.begin()->toXML(indent + 2);
   }
   if (! m_target_link.empty()) {
      ostr << m_target_link.begin()->toXML(indent + 2);
   }
   int VertexListCount=0;
   for (VertexList::iterator it = m_vertex_list.begin();
        it != m_vertex_list.end(); ++it)
   {
      if (++VertexListCount > m_vertex_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   if (! m_random_link.empty()) {
      ostr << m_random_link.begin()->toXML(indent + 2);
   }
   int UserDataListCount=0;
   for (UserDataList::iterator it = m_userData_list.begin();
        it != m_userData_list.end(); ++it)
   {
      if (++UserDataListCount > m_userData_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</reaction>"
        << std::endl;
   return ostr.str();
}

std::string CdcDigihit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cdcDigihit"
        << " peakAmp=" << m_peakAmp
             << std::endl;
   return ostr.str();
}

std::string CdcDigihit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cdcDigihit"
        << " peakAmp=" << "\"" << getPeakAmp() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CdcHitQF::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cdcHitQF"
        << " QF=" << m_QF
             << std::endl;
   return ostr.str();
}

std::string CdcHitQF::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cdcHitQF"
        << " QF=" << "\"" << getQF() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CdcStrawHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cdcStrawHit"
        << " q=" << m_q
        << " t=" << m_t
             << std::endl;
   if (! m_cdcDigihit_link.empty()) {
      ostr << m_cdcDigihit_link.begin()->toString(indent + 2);
   }
   if (! m_cdcHitQF_link.empty()) {
      ostr << m_cdcHitQF_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string CdcStrawHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cdcStrawHit"
        << " q=" << "\"" << getQ() << "\""
        << " t=" << "\"" << getT() << "\""
        << ">" << std::endl;
   if (! m_cdcDigihit_link.empty()) {
      ostr << m_cdcDigihit_link.begin()->toXML(indent + 2);
   }
   if (! m_cdcHitQF_link.empty()) {
      ostr << m_cdcHitQF_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</cdcStrawHit>"
        << std::endl;
   return ostr.str();
}

std::string CdcStrawTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cdcStrawTruthHit"
        << " d=" << m_d
        << " itrack=" << m_itrack
        << " ptype=" << m_ptype
        << " q=" << m_q
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string CdcStrawTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cdcStrawTruthHit"
        << " d=" << "\"" << getD() << "\""
        << " itrack=" << "\"" << getItrack() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " q=" << "\"" << getQ() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CdcStraw::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cdcStraw"
        << " ring=" << m_ring
        << " straw=" << m_straw
             << std::endl;
   int CdcStrawHitListCount=0;
   for (CdcStrawHitList::iterator it = m_cdcStrawHit_list.begin();
        it != m_cdcStrawHit_list.end(); ++it)
   {
      if (++CdcStrawHitListCount > m_cdcStrawHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CdcStrawTruthHitListCount=0;
   for (CdcStrawTruthHitList::iterator it = m_cdcStrawTruthHit_list.begin();
        it != m_cdcStrawTruthHit_list.end(); ++it)
   {
      if (++CdcStrawTruthHitListCount > m_cdcStrawTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string CdcStraw::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cdcStraw"
        << " ring=" << "\"" << getRing() << "\""
        << " straw=" << "\"" << getStraw() << "\""
        << ">" << std::endl;
   int CdcStrawHitListCount=0;
   for (CdcStrawHitList::iterator it = m_cdcStrawHit_list.begin();
        it != m_cdcStrawHit_list.end(); ++it)
   {
      if (++CdcStrawHitListCount > m_cdcStrawHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CdcStrawTruthHitListCount=0;
   for (CdcStrawTruthHitList::iterator it = m_cdcStrawTruthHit_list.begin();
        it != m_cdcStrawTruthHit_list.end(); ++it)
   {
      if (++CdcStrawTruthHitListCount > m_cdcStrawTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</cdcStraw>"
        << std::endl;
   return ostr.str();
}

std::string TrackID::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "trackID"
        << " itrack=" << m_itrack
             << std::endl;
   return ostr.str();
}

std::string TrackID::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<trackID"
        << " itrack=" << "\"" << getItrack() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CdcTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cdcTruthPoint"
        << " dEdx=" << m_dEdx
        << " dradius=" << m_dradius
        << " phi=" << m_phi
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " r=" << m_r
        << " t=" << m_t
        << " track=" << m_track
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string CdcTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cdcTruthPoint"
        << " dEdx=" << "\"" << getDEdx() << "\""
        << " dradius=" << "\"" << getDradius() << "\""
        << " phi=" << "\"" << getPhi() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " r=" << "\"" << getR() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</cdcTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string CentralDC::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "centralDC"
             << std::endl;
   int CdcStrawListCount=0;
   for (CdcStrawList::iterator it = m_cdcStraw_list.begin();
        it != m_cdcStraw_list.end(); ++it)
   {
      if (++CdcStrawListCount > m_cdcStraw_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CdcTruthPointListCount=0;
   for (CdcTruthPointList::iterator it = m_cdcTruthPoint_list.begin();
        it != m_cdcTruthPoint_list.end(); ++it)
   {
      if (++CdcTruthPointListCount > m_cdcTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string CentralDC::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<centralDC"
        << ">" << std::endl;
   int CdcStrawListCount=0;
   for (CdcStrawList::iterator it = m_cdcStraw_list.begin();
        it != m_cdcStraw_list.end(); ++it)
   {
      if (++CdcStrawListCount > m_cdcStraw_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CdcTruthPointListCount=0;
   for (CdcTruthPointList::iterator it = m_cdcTruthPoint_list.begin();
        it != m_cdcTruthPoint_list.end(); ++it)
   {
      if (++CdcTruthPointListCount > m_cdcTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</centralDC>"
        << std::endl;
   return ostr.str();
}

std::string FdcAnodeHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcAnodeHit"
        << " dE=" << m_dE
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string FdcAnodeHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcAnodeHit"
        << " dE=" << "\"" << getDE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FdcAnodeTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcAnodeTruthHit"
        << " d=" << m_d
        << " dE=" << m_dE
        << " itrack=" << m_itrack
        << " ptype=" << m_ptype
        << " t=" << m_t
        << " t_unsmeared=" << m_t_unsmeared
             << std::endl;
   return ostr.str();
}

std::string FdcAnodeTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcAnodeTruthHit"
        << " d=" << "\"" << getD() << "\""
        << " dE=" << "\"" << getDE() << "\""
        << " itrack=" << "\"" << getItrack() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " t=" << "\"" << getT() << "\""
        << " t_unsmeared=" << "\"" << getT_unsmeared() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FdcAnodeWire::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcAnodeWire"
        << " wire=" << m_wire
             << std::endl;
   int FdcAnodeHitListCount=0;
   for (FdcAnodeHitList::iterator it = m_fdcAnodeHit_list.begin();
        it != m_fdcAnodeHit_list.end(); ++it)
   {
      if (++FdcAnodeHitListCount > m_fdcAnodeHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FdcAnodeTruthHitListCount=0;
   for (FdcAnodeTruthHitList::iterator it = m_fdcAnodeTruthHit_list.begin();
        it != m_fdcAnodeTruthHit_list.end(); ++it)
   {
      if (++FdcAnodeTruthHitListCount > m_fdcAnodeTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string FdcAnodeWire::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcAnodeWire"
        << " wire=" << "\"" << getWire() << "\""
        << ">" << std::endl;
   int FdcAnodeHitListCount=0;
   for (FdcAnodeHitList::iterator it = m_fdcAnodeHit_list.begin();
        it != m_fdcAnodeHit_list.end(); ++it)
   {
      if (++FdcAnodeHitListCount > m_fdcAnodeHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FdcAnodeTruthHitListCount=0;
   for (FdcAnodeTruthHitList::iterator it = m_fdcAnodeTruthHit_list.begin();
        it != m_fdcAnodeTruthHit_list.end(); ++it)
   {
      if (++FdcAnodeTruthHitListCount > m_fdcAnodeTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fdcAnodeWire>"
        << std::endl;
   return ostr.str();
}

std::string FdcDigihit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcDigihit"
        << " peakAmp=" << m_peakAmp
             << std::endl;
   return ostr.str();
}

std::string FdcDigihit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcDigihit"
        << " peakAmp=" << "\"" << getPeakAmp() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FdcCathodeHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcCathodeHit"
        << " q=" << m_q
        << " t=" << m_t
             << std::endl;
   if (! m_fdcDigihit_link.empty()) {
      ostr << m_fdcDigihit_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string FdcCathodeHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcCathodeHit"
        << " q=" << "\"" << getQ() << "\""
        << " t=" << "\"" << getT() << "\""
        << ">" << std::endl;
   if (! m_fdcDigihit_link.empty()) {
      ostr << m_fdcDigihit_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fdcCathodeHit>"
        << std::endl;
   return ostr.str();
}

std::string FdcCathodeTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcCathodeTruthHit"
        << " itrack=" << m_itrack
        << " ptype=" << m_ptype
        << " q=" << m_q
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string FdcCathodeTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcCathodeTruthHit"
        << " itrack=" << "\"" << getItrack() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " q=" << "\"" << getQ() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FdcCathodeStrip::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcCathodeStrip"
        << " plane=" << m_plane
        << " strip=" << m_strip
             << std::endl;
   int FdcCathodeHitListCount=0;
   for (FdcCathodeHitList::iterator it = m_fdcCathodeHit_list.begin();
        it != m_fdcCathodeHit_list.end(); ++it)
   {
      if (++FdcCathodeHitListCount > m_fdcCathodeHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FdcCathodeTruthHitListCount=0;
   for (FdcCathodeTruthHitList::iterator it = m_fdcCathodeTruthHit_list.begin();
        it != m_fdcCathodeTruthHit_list.end(); ++it)
   {
      if (++FdcCathodeTruthHitListCount > m_fdcCathodeTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string FdcCathodeStrip::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcCathodeStrip"
        << " plane=" << "\"" << getPlane() << "\""
        << " strip=" << "\"" << getStrip() << "\""
        << ">" << std::endl;
   int FdcCathodeHitListCount=0;
   for (FdcCathodeHitList::iterator it = m_fdcCathodeHit_list.begin();
        it != m_fdcCathodeHit_list.end(); ++it)
   {
      if (++FdcCathodeHitListCount > m_fdcCathodeHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FdcCathodeTruthHitListCount=0;
   for (FdcCathodeTruthHitList::iterator it = m_fdcCathodeTruthHit_list.begin();
        it != m_fdcCathodeTruthHit_list.end(); ++it)
   {
      if (++FdcCathodeTruthHitListCount > m_fdcCathodeTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fdcCathodeStrip>"
        << std::endl;
   return ostr.str();
}

std::string FdcTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcTruthPoint"
        << " E=" << m_E
        << " dEdx=" << m_dEdx
        << " dradius=" << m_dradius
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string FdcTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " dEdx=" << "\"" << getDEdx() << "\""
        << " dradius=" << "\"" << getDradius() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fdcTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string FdcChamber::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fdcChamber"
        << " layer=" << m_layer
        << " module=" << m_module
             << std::endl;
   int FdcAnodeWireListCount=0;
   for (FdcAnodeWireList::iterator it = m_fdcAnodeWire_list.begin();
        it != m_fdcAnodeWire_list.end(); ++it)
   {
      if (++FdcAnodeWireListCount > m_fdcAnodeWire_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FdcCathodeStripListCount=0;
   for (FdcCathodeStripList::iterator it = m_fdcCathodeStrip_list.begin();
        it != m_fdcCathodeStrip_list.end(); ++it)
   {
      if (++FdcCathodeStripListCount > m_fdcCathodeStrip_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FdcTruthPointListCount=0;
   for (FdcTruthPointList::iterator it = m_fdcTruthPoint_list.begin();
        it != m_fdcTruthPoint_list.end(); ++it)
   {
      if (++FdcTruthPointListCount > m_fdcTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string FdcChamber::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fdcChamber"
        << " layer=" << "\"" << getLayer() << "\""
        << " module=" << "\"" << getModule() << "\""
        << ">" << std::endl;
   int FdcAnodeWireListCount=0;
   for (FdcAnodeWireList::iterator it = m_fdcAnodeWire_list.begin();
        it != m_fdcAnodeWire_list.end(); ++it)
   {
      if (++FdcAnodeWireListCount > m_fdcAnodeWire_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FdcCathodeStripListCount=0;
   for (FdcCathodeStripList::iterator it = m_fdcCathodeStrip_list.begin();
        it != m_fdcCathodeStrip_list.end(); ++it)
   {
      if (++FdcCathodeStripListCount > m_fdcCathodeStrip_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FdcTruthPointListCount=0;
   for (FdcTruthPointList::iterator it = m_fdcTruthPoint_list.begin();
        it != m_fdcTruthPoint_list.end(); ++it)
   {
      if (++FdcTruthPointListCount > m_fdcTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fdcChamber>"
        << std::endl;
   return ostr.str();
}

std::string ForwardDC::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "forwardDC"
             << std::endl;
   int FdcChamberListCount=0;
   for (FdcChamberList::iterator it = m_fdcChamber_list.begin();
        it != m_fdcChamber_list.end(); ++it)
   {
      if (++FdcChamberListCount > m_fdcChamber_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string ForwardDC::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<forwardDC"
        << ">" << std::endl;
   int FdcChamberListCount=0;
   for (FdcChamberList::iterator it = m_fdcChamber_list.begin();
        it != m_fdcChamber_list.end(); ++it)
   {
      if (++FdcChamberListCount > m_fdcChamber_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</forwardDC>"
        << std::endl;
   return ostr.str();
}

std::string StcDigihit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "stcDigihit"
        << " peakAmp=" << m_peakAmp
             << std::endl;
   return ostr.str();
}

std::string StcDigihit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<stcDigihit"
        << " peakAmp=" << "\"" << getPeakAmp() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string StcHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "stcHit"
        << " dE=" << m_dE
        << " t=" << m_t
             << std::endl;
   if (! m_stcDigihit_link.empty()) {
      ostr << m_stcDigihit_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string StcHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<stcHit"
        << " dE=" << "\"" << getDE() << "\""
        << " t=" << "\"" << getT() << "\""
        << ">" << std::endl;
   if (! m_stcDigihit_link.empty()) {
      ostr << m_stcDigihit_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</stcHit>"
        << std::endl;
   return ostr.str();
}

std::string StcTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "stcTruthHit"
        << " dE=" << m_dE
        << " itrack=" << m_itrack
        << " ptype=" << m_ptype
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string StcTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<stcTruthHit"
        << " dE=" << "\"" << getDE() << "\""
        << " itrack=" << "\"" << getItrack() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string StcPaddle::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "stcPaddle"
        << " sector=" << m_sector
             << std::endl;
   int StcHitListCount=0;
   for (StcHitList::iterator it = m_stcHit_list.begin();
        it != m_stcHit_list.end(); ++it)
   {
      if (++StcHitListCount > m_stcHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int StcTruthHitListCount=0;
   for (StcTruthHitList::iterator it = m_stcTruthHit_list.begin();
        it != m_stcTruthHit_list.end(); ++it)
   {
      if (++StcTruthHitListCount > m_stcTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string StcPaddle::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<stcPaddle"
        << " sector=" << "\"" << getSector() << "\""
        << ">" << std::endl;
   int StcHitListCount=0;
   for (StcHitList::iterator it = m_stcHit_list.begin();
        it != m_stcHit_list.end(); ++it)
   {
      if (++StcHitListCount > m_stcHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int StcTruthHitListCount=0;
   for (StcTruthHitList::iterator it = m_stcTruthHit_list.begin();
        it != m_stcTruthHit_list.end(); ++it)
   {
      if (++StcTruthHitListCount > m_stcTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</stcPaddle>"
        << std::endl;
   return ostr.str();
}

std::string StcTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "stcTruthPoint"
        << " E=" << m_E
        << " dEdx=" << m_dEdx
        << " phi=" << m_phi
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " r=" << m_r
        << " sector=" << m_sector
        << " t=" << m_t
        << " track=" << m_track
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string StcTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<stcTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " dEdx=" << "\"" << getDEdx() << "\""
        << " phi=" << "\"" << getPhi() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " r=" << "\"" << getR() << "\""
        << " sector=" << "\"" << getSector() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</stcTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string StartCntr::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "startCntr"
             << std::endl;
   int StcPaddleListCount=0;
   for (StcPaddleList::iterator it = m_stcPaddle_list.begin();
        it != m_stcPaddle_list.end(); ++it)
   {
      if (++StcPaddleListCount > m_stcPaddle_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int StcTruthPointListCount=0;
   for (StcTruthPointList::iterator it = m_stcTruthPoint_list.begin();
        it != m_stcTruthPoint_list.end(); ++it)
   {
      if (++StcTruthPointListCount > m_stcTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string StartCntr::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<startCntr"
        << ">" << std::endl;
   int StcPaddleListCount=0;
   for (StcPaddleList::iterator it = m_stcPaddle_list.begin();
        it != m_stcPaddle_list.end(); ++it)
   {
      if (++StcPaddleListCount > m_stcPaddle_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int StcTruthPointListCount=0;
   for (StcTruthPointList::iterator it = m_stcTruthPoint_list.begin();
        it != m_stcTruthPoint_list.end(); ++it)
   {
      if (++StcTruthPointListCount > m_stcTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</startCntr>"
        << std::endl;
   return ostr.str();
}

std::string BcalSiPMUpHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalSiPMUpHit"
        << " E=" << m_E
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string BcalSiPMUpHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalSiPMUpHit"
        << " E=" << "\"" << getE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalSiPMDownHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalSiPMDownHit"
        << " E=" << m_E
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string BcalSiPMDownHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalSiPMDownHit"
        << " E=" << "\"" << getE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalSiPMTruth::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalSiPMTruth"
        << " E=" << m_E
        << " incident_id=" << m_incident_id
             << std::endl;
   return ostr.str();
}

std::string BcalSiPMTruth::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalSiPMTruth"
        << " E=" << "\"" << getE() << "\""
        << " incident_id=" << "\"" << getIncident_id() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalSiPMSpectrum::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalSiPMSpectrum"
        << " bin_width=" << m_bin_width
        << " end=" << m_end
        << " tstart=" << m_tstart
        << " vals=" << "\"" << m_vals << "\""
             << std::endl;
   if (! m_bcalSiPMTruth_link.empty()) {
      ostr << m_bcalSiPMTruth_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string BcalSiPMSpectrum::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalSiPMSpectrum"
        << " bin_width=" << "\"" << getBin_width() << "\""
        << " end=" << "\"" << getEnd() << "\""
        << " tstart=" << "\"" << getTstart() << "\""
        << " vals=" << "\"" << getVals() << "\""
        << ">" << std::endl;
   if (! m_bcalSiPMTruth_link.empty()) {
      ostr << m_bcalSiPMTruth_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</bcalSiPMSpectrum>"
        << std::endl;
   return ostr.str();
}

std::string BcalfADCHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalfADCHit"
        << " E=" << m_E
        << " end=" << m_end
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string BcalfADCHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalfADCHit"
        << " E=" << "\"" << getE() << "\""
        << " end=" << "\"" << getEnd() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalfADCPeak::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalfADCPeak"
        << " peakAmp=" << m_peakAmp
             << std::endl;
   return ostr.str();
}

std::string BcalfADCPeak::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalfADCPeak"
        << " peakAmp=" << "\"" << getPeakAmp() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalfADCDigiHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalfADCDigiHit"
        << " end=" << m_end
        << " pulse_integral=" << m_pulse_integral
        << " pulse_time=" << m_pulse_time
             << std::endl;
   if (! m_bcalfADCPeak_link.empty()) {
      ostr << m_bcalfADCPeak_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string BcalfADCDigiHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalfADCDigiHit"
        << " end=" << "\"" << getEnd() << "\""
        << " pulse_integral=" << "\"" << getPulse_integral() << "\""
        << " pulse_time=" << "\"" << getPulse_time() << "\""
        << ">" << std::endl;
   if (! m_bcalfADCPeak_link.empty()) {
      ostr << m_bcalfADCPeak_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</bcalfADCDigiHit>"
        << std::endl;
   return ostr.str();
}

std::string BcalTDCHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalTDCHit"
        << " end=" << m_end
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string BcalTDCHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalTDCHit"
        << " end=" << "\"" << getEnd() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalTDCDigiHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalTDCDigiHit"
        << " end=" << m_end
        << " time=" << m_time
             << std::endl;
   return ostr.str();
}

std::string BcalTDCDigiHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalTDCDigiHit"
        << " end=" << "\"" << getEnd() << "\""
        << " time=" << "\"" << getTime() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalTruthHit"
        << " E=" << m_E
        << " incident_id=" << m_incident_id
        << " t=" << m_t
        << " zLocal=" << m_zLocal
             << std::endl;
   return ostr.str();
}

std::string BcalTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalTruthHit"
        << " E=" << "\"" << getE() << "\""
        << " incident_id=" << "\"" << getIncident_id() << "\""
        << " t=" << "\"" << getT() << "\""
        << " zLocal=" << "\"" << getZLocal() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalCell::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalCell"
        << " layer=" << m_layer
        << " module=" << m_module
        << " sector=" << m_sector
             << std::endl;
   int BcalSiPMUpHitListCount=0;
   for (BcalSiPMUpHitList::iterator it = m_bcalSiPMUpHit_list.begin();
        it != m_bcalSiPMUpHit_list.end(); ++it)
   {
      if (++BcalSiPMUpHitListCount > m_bcalSiPMUpHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalSiPMDownHitListCount=0;
   for (BcalSiPMDownHitList::iterator it = m_bcalSiPMDownHit_list.begin();
        it != m_bcalSiPMDownHit_list.end(); ++it)
   {
      if (++BcalSiPMDownHitListCount > m_bcalSiPMDownHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalSiPMSpectrumListCount=0;
   for (BcalSiPMSpectrumList::iterator it = m_bcalSiPMSpectrum_list.begin();
        it != m_bcalSiPMSpectrum_list.end(); ++it)
   {
      if (++BcalSiPMSpectrumListCount > m_bcalSiPMSpectrum_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalfADCHitListCount=0;
   for (BcalfADCHitList::iterator it = m_bcalfADCHit_list.begin();
        it != m_bcalfADCHit_list.end(); ++it)
   {
      if (++BcalfADCHitListCount > m_bcalfADCHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalfADCDigiHitListCount=0;
   for (BcalfADCDigiHitList::iterator it = m_bcalfADCDigiHit_list.begin();
        it != m_bcalfADCDigiHit_list.end(); ++it)
   {
      if (++BcalfADCDigiHitListCount > m_bcalfADCDigiHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalTDCHitListCount=0;
   for (BcalTDCHitList::iterator it = m_bcalTDCHit_list.begin();
        it != m_bcalTDCHit_list.end(); ++it)
   {
      if (++BcalTDCHitListCount > m_bcalTDCHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalTDCDigiHitListCount=0;
   for (BcalTDCDigiHitList::iterator it = m_bcalTDCDigiHit_list.begin();
        it != m_bcalTDCDigiHit_list.end(); ++it)
   {
      if (++BcalTDCDigiHitListCount > m_bcalTDCDigiHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalTruthHitListCount=0;
   for (BcalTruthHitList::iterator it = m_bcalTruthHit_list.begin();
        it != m_bcalTruthHit_list.end(); ++it)
   {
      if (++BcalTruthHitListCount > m_bcalTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string BcalCell::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalCell"
        << " layer=" << "\"" << getLayer() << "\""
        << " module=" << "\"" << getModule() << "\""
        << " sector=" << "\"" << getSector() << "\""
        << ">" << std::endl;
   int BcalSiPMUpHitListCount=0;
   for (BcalSiPMUpHitList::iterator it = m_bcalSiPMUpHit_list.begin();
        it != m_bcalSiPMUpHit_list.end(); ++it)
   {
      if (++BcalSiPMUpHitListCount > m_bcalSiPMUpHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalSiPMDownHitListCount=0;
   for (BcalSiPMDownHitList::iterator it = m_bcalSiPMDownHit_list.begin();
        it != m_bcalSiPMDownHit_list.end(); ++it)
   {
      if (++BcalSiPMDownHitListCount > m_bcalSiPMDownHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalSiPMSpectrumListCount=0;
   for (BcalSiPMSpectrumList::iterator it = m_bcalSiPMSpectrum_list.begin();
        it != m_bcalSiPMSpectrum_list.end(); ++it)
   {
      if (++BcalSiPMSpectrumListCount > m_bcalSiPMSpectrum_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalfADCHitListCount=0;
   for (BcalfADCHitList::iterator it = m_bcalfADCHit_list.begin();
        it != m_bcalfADCHit_list.end(); ++it)
   {
      if (++BcalfADCHitListCount > m_bcalfADCHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalfADCDigiHitListCount=0;
   for (BcalfADCDigiHitList::iterator it = m_bcalfADCDigiHit_list.begin();
        it != m_bcalfADCDigiHit_list.end(); ++it)
   {
      if (++BcalfADCDigiHitListCount > m_bcalfADCDigiHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalTDCHitListCount=0;
   for (BcalTDCHitList::iterator it = m_bcalTDCHit_list.begin();
        it != m_bcalTDCHit_list.end(); ++it)
   {
      if (++BcalTDCHitListCount > m_bcalTDCHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalTDCDigiHitListCount=0;
   for (BcalTDCDigiHitList::iterator it = m_bcalTDCDigiHit_list.begin();
        it != m_bcalTDCDigiHit_list.end(); ++it)
   {
      if (++BcalTDCDigiHitListCount > m_bcalTDCDigiHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalTruthHitListCount=0;
   for (BcalTruthHitList::iterator it = m_bcalTruthHit_list.begin();
        it != m_bcalTruthHit_list.end(); ++it)
   {
      if (++BcalTruthHitListCount > m_bcalTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</bcalCell>"
        << std::endl;
   return ostr.str();
}

std::string BcalTruthIncidentParticle::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalTruthIncidentParticle"
        << " id=" << m_id
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   return ostr.str();
}

std::string BcalTruthIncidentParticle::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalTruthIncidentParticle"
        << " id=" << "\"" << getId() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string BcalTruthShower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "bcalTruthShower"
        << " E=" << m_E
        << " phi=" << m_phi
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " r=" << m_r
        << " t=" << m_t
        << " track=" << m_track
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string BcalTruthShower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<bcalTruthShower"
        << " E=" << "\"" << getE() << "\""
        << " phi=" << "\"" << getPhi() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " r=" << "\"" << getR() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</bcalTruthShower>"
        << std::endl;
   return ostr.str();
}

std::string BarrelEMcal::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "barrelEMcal"
             << std::endl;
   int BcalCellListCount=0;
   for (BcalCellList::iterator it = m_bcalCell_list.begin();
        it != m_bcalCell_list.end(); ++it)
   {
      if (++BcalCellListCount > m_bcalCell_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalTruthIncidentParticleListCount=0;
   for (BcalTruthIncidentParticleList::iterator it = m_bcalTruthIncidentParticle_list.begin();
        it != m_bcalTruthIncidentParticle_list.end(); ++it)
   {
      if (++BcalTruthIncidentParticleListCount > m_bcalTruthIncidentParticle_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int BcalTruthShowerListCount=0;
   for (BcalTruthShowerList::iterator it = m_bcalTruthShower_list.begin();
        it != m_bcalTruthShower_list.end(); ++it)
   {
      if (++BcalTruthShowerListCount > m_bcalTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string BarrelEMcal::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<barrelEMcal"
        << ">" << std::endl;
   int BcalCellListCount=0;
   for (BcalCellList::iterator it = m_bcalCell_list.begin();
        it != m_bcalCell_list.end(); ++it)
   {
      if (++BcalCellListCount > m_bcalCell_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalTruthIncidentParticleListCount=0;
   for (BcalTruthIncidentParticleList::iterator it = m_bcalTruthIncidentParticle_list.begin();
        it != m_bcalTruthIncidentParticle_list.end(); ++it)
   {
      if (++BcalTruthIncidentParticleListCount > m_bcalTruthIncidentParticle_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int BcalTruthShowerListCount=0;
   for (BcalTruthShowerList::iterator it = m_bcalTruthShower_list.begin();
        it != m_bcalTruthShower_list.end(); ++it)
   {
      if (++BcalTruthShowerListCount > m_bcalTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</barrelEMcal>"
        << std::endl;
   return ostr.str();
}

std::string GcalHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "gcalHit"
        << " E=" << m_E
        << " t=" << m_t
        << " zLocal=" << m_zLocal
             << std::endl;
   return ostr.str();
}

std::string GcalHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<gcalHit"
        << " E=" << "\"" << getE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " zLocal=" << "\"" << getZLocal() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string GcalTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "gcalTruthHit"
        << " E=" << m_E
        << " t=" << m_t
        << " zLocal=" << m_zLocal
             << std::endl;
   return ostr.str();
}

std::string GcalTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<gcalTruthHit"
        << " E=" << "\"" << getE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " zLocal=" << "\"" << getZLocal() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string GcalCell::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "gcalCell"
        << " module=" << m_module
             << std::endl;
   int GcalHitListCount=0;
   for (GcalHitList::iterator it = m_gcalHit_list.begin();
        it != m_gcalHit_list.end(); ++it)
   {
      if (++GcalHitListCount > m_gcalHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int GcalTruthHitListCount=0;
   for (GcalTruthHitList::iterator it = m_gcalTruthHit_list.begin();
        it != m_gcalTruthHit_list.end(); ++it)
   {
      if (++GcalTruthHitListCount > m_gcalTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string GcalCell::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<gcalCell"
        << " module=" << "\"" << getModule() << "\""
        << ">" << std::endl;
   int GcalHitListCount=0;
   for (GcalHitList::iterator it = m_gcalHit_list.begin();
        it != m_gcalHit_list.end(); ++it)
   {
      if (++GcalHitListCount > m_gcalHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int GcalTruthHitListCount=0;
   for (GcalTruthHitList::iterator it = m_gcalTruthHit_list.begin();
        it != m_gcalTruthHit_list.end(); ++it)
   {
      if (++GcalTruthHitListCount > m_gcalTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</gcalCell>"
        << std::endl;
   return ostr.str();
}

std::string GcalTruthShower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "gcalTruthShower"
        << " E=" << m_E
        << " phi=" << m_phi
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " r=" << m_r
        << " t=" << m_t
        << " track=" << m_track
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string GcalTruthShower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<gcalTruthShower"
        << " E=" << "\"" << getE() << "\""
        << " phi=" << "\"" << getPhi() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " r=" << "\"" << getR() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</gcalTruthShower>"
        << std::endl;
   return ostr.str();
}

std::string GapEMcal::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "gapEMcal"
             << std::endl;
   int GcalCellListCount=0;
   for (GcalCellList::iterator it = m_gcalCell_list.begin();
        it != m_gcalCell_list.end(); ++it)
   {
      if (++GcalCellListCount > m_gcalCell_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int GcalTruthShowerListCount=0;
   for (GcalTruthShowerList::iterator it = m_gcalTruthShower_list.begin();
        it != m_gcalTruthShower_list.end(); ++it)
   {
      if (++GcalTruthShowerListCount > m_gcalTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string GapEMcal::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<gapEMcal"
        << ">" << std::endl;
   int GcalCellListCount=0;
   for (GcalCellList::iterator it = m_gcalCell_list.begin();
        it != m_gcalCell_list.end(); ++it)
   {
      if (++GcalCellListCount > m_gcalCell_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int GcalTruthShowerListCount=0;
   for (GcalTruthShowerList::iterator it = m_gcalTruthShower_list.begin();
        it != m_gcalTruthShower_list.end(); ++it)
   {
      if (++GcalTruthShowerListCount > m_gcalTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</gapEMcal>"
        << std::endl;
   return ostr.str();
}

std::string CereHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cereHit"
        << " pe=" << m_pe
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string CereHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cereHit"
        << " pe=" << "\"" << getPe() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CereTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cereTruthHit"
        << " pe=" << m_pe
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string CereTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cereTruthHit"
        << " pe=" << "\"" << getPe() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CereSection::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cereSection"
        << " sector=" << m_sector
             << std::endl;
   int CereHitListCount=0;
   for (CereHitList::iterator it = m_cereHit_list.begin();
        it != m_cereHit_list.end(); ++it)
   {
      if (++CereHitListCount > m_cereHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CereTruthHitListCount=0;
   for (CereTruthHitList::iterator it = m_cereTruthHit_list.begin();
        it != m_cereTruthHit_list.end(); ++it)
   {
      if (++CereTruthHitListCount > m_cereTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string CereSection::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cereSection"
        << " sector=" << "\"" << getSector() << "\""
        << ">" << std::endl;
   int CereHitListCount=0;
   for (CereHitList::iterator it = m_cereHit_list.begin();
        it != m_cereHit_list.end(); ++it)
   {
      if (++CereHitListCount > m_cereHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CereTruthHitListCount=0;
   for (CereTruthHitList::iterator it = m_cereTruthHit_list.begin();
        it != m_cereTruthHit_list.end(); ++it)
   {
      if (++CereTruthHitListCount > m_cereTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</cereSection>"
        << std::endl;
   return ostr.str();
}

std::string CereTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "cereTruthPoint"
        << " E=" << m_E
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string CereTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<cereTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</cereTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string Cerenkov::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "Cerenkov"
             << std::endl;
   int CereSectionListCount=0;
   for (CereSectionList::iterator it = m_cereSection_list.begin();
        it != m_cereSection_list.end(); ++it)
   {
      if (++CereSectionListCount > m_cereSection_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CereTruthPointListCount=0;
   for (CereTruthPointList::iterator it = m_cereTruthPoint_list.begin();
        it != m_cereTruthPoint_list.end(); ++it)
   {
      if (++CereTruthPointListCount > m_cereTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string Cerenkov::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<Cerenkov"
        << ">" << std::endl;
   int CereSectionListCount=0;
   for (CereSectionList::iterator it = m_cereSection_list.begin();
        it != m_cereSection_list.end(); ++it)
   {
      if (++CereSectionListCount > m_cereSection_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CereTruthPointListCount=0;
   for (CereTruthPointList::iterator it = m_cereTruthPoint_list.begin();
        it != m_cereTruthPoint_list.end(); ++it)
   {
      if (++CereTruthPointListCount > m_cereTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</Cerenkov>"
        << std::endl;
   return ostr.str();
}

std::string RichTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "richTruthHit"
        << " t=" << m_t
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   return ostr.str();
}

std::string RichTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<richTruthHit"
        << " t=" << "\"" << getT() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string RichTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "richTruthPoint"
        << " E=" << m_E
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string RichTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<richTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</richTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string RICH::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "RICH"
             << std::endl;
   int RichTruthHitListCount=0;
   for (RichTruthHitList::iterator it = m_richTruthHit_list.begin();
        it != m_richTruthHit_list.end(); ++it)
   {
      if (++RichTruthHitListCount > m_richTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int RichTruthPointListCount=0;
   for (RichTruthPointList::iterator it = m_richTruthPoint_list.begin();
        it != m_richTruthPoint_list.end(); ++it)
   {
      if (++RichTruthPointListCount > m_richTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string RICH::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<RICH"
        << ">" << std::endl;
   int RichTruthHitListCount=0;
   for (RichTruthHitList::iterator it = m_richTruthHit_list.begin();
        it != m_richTruthHit_list.end(); ++it)
   {
      if (++RichTruthHitListCount > m_richTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int RichTruthPointListCount=0;
   for (RichTruthPointList::iterator it = m_richTruthPoint_list.begin();
        it != m_richTruthPoint_list.end(); ++it)
   {
      if (++RichTruthPointListCount > m_richTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</RICH>"
        << std::endl;
   return ostr.str();
}

std::string DircTruthBarHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dircTruthBarHit"
        << " E=" << m_E
        << " bar=" << m_bar
        << " pdg=" << m_pdg
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   return ostr.str();
}

std::string DircTruthBarHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dircTruthBarHit"
        << " E=" << "\"" << getE() << "\""
        << " bar=" << "\"" << getBar() << "\""
        << " pdg=" << "\"" << getPdg() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DircTruthPmtHitExtra::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dircTruthPmtHitExtra"
        << " bbrefl=" << ((m_bbrefl == 0)? "true" : "false")
        << " path=" << m_path
        << " refl=" << m_refl
        << " t_fixed=" << m_t_fixed
             << std::endl;
   return ostr.str();
}

std::string DircTruthPmtHitExtra::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dircTruthPmtHitExtra"
        << " bbrefl=" << ((m_bbrefl == 0)? "\"true\"" : "\"false\"")
        << " path=" << "\"" << getPath() << "\""
        << " refl=" << "\"" << getRefl() << "\""
        << " t_fixed=" << "\"" << getT_fixed() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DircTruthPmtHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dircTruthPmtHit"
        << " E=" << m_E
        << " ch=" << m_ch
        << " key_bar=" << m_key_bar
        << " t=" << m_t
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   int DircTruthPmtHitExtraListCount=0;
   for (DircTruthPmtHitExtraList::iterator it = m_dircTruthPmtHitExtra_list.begin();
        it != m_dircTruthPmtHitExtra_list.end(); ++it)
   {
      if (++DircTruthPmtHitExtraListCount > m_dircTruthPmtHitExtra_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string DircTruthPmtHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dircTruthPmtHit"
        << " E=" << "\"" << getE() << "\""
        << " ch=" << "\"" << getCh() << "\""
        << " key_bar=" << "\"" << getKey_bar() << "\""
        << " t=" << "\"" << getT() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   int DircTruthPmtHitExtraListCount=0;
   for (DircTruthPmtHitExtraList::iterator it = m_dircTruthPmtHitExtra_list.begin();
        it != m_dircTruthPmtHitExtra_list.end(); ++it)
   {
      if (++DircTruthPmtHitExtraListCount > m_dircTruthPmtHitExtra_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</dircTruthPmtHit>"
        << std::endl;
   return ostr.str();
}

std::string DircPmtHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "dircPmtHit"
        << " ch=" << m_ch
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string DircPmtHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<dircPmtHit"
        << " ch=" << "\"" << getCh() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string DIRC::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "DIRC"
             << std::endl;
   int DircTruthBarHitListCount=0;
   for (DircTruthBarHitList::iterator it = m_dircTruthBarHit_list.begin();
        it != m_dircTruthBarHit_list.end(); ++it)
   {
      if (++DircTruthBarHitListCount > m_dircTruthBarHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int DircTruthPmtHitListCount=0;
   for (DircTruthPmtHitList::iterator it = m_dircTruthPmtHit_list.begin();
        it != m_dircTruthPmtHit_list.end(); ++it)
   {
      if (++DircTruthPmtHitListCount > m_dircTruthPmtHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int DircPmtHitListCount=0;
   for (DircPmtHitList::iterator it = m_dircPmtHit_list.begin();
        it != m_dircPmtHit_list.end(); ++it)
   {
      if (++DircPmtHitListCount > m_dircPmtHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string DIRC::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<DIRC"
        << ">" << std::endl;
   int DircTruthBarHitListCount=0;
   for (DircTruthBarHitList::iterator it = m_dircTruthBarHit_list.begin();
        it != m_dircTruthBarHit_list.end(); ++it)
   {
      if (++DircTruthBarHitListCount > m_dircTruthBarHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int DircTruthPmtHitListCount=0;
   for (DircTruthPmtHitList::iterator it = m_dircTruthPmtHit_list.begin();
        it != m_dircTruthPmtHit_list.end(); ++it)
   {
      if (++DircTruthPmtHitListCount > m_dircTruthPmtHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int DircPmtHitListCount=0;
   for (DircPmtHitList::iterator it = m_dircPmtHit_list.begin();
        it != m_dircPmtHit_list.end(); ++it)
   {
      if (++DircPmtHitListCount > m_dircPmtHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</DIRC>"
        << std::endl;
   return ostr.str();
}

std::string FtofDigihit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ftofDigihit"
        << " peakAmp=" << m_peakAmp
             << std::endl;
   return ostr.str();
}

std::string FtofDigihit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ftofDigihit"
        << " peakAmp=" << "\"" << getPeakAmp() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FtofHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ftofHit"
        << " dE=" << m_dE
        << " end=" << m_end
        << " t=" << m_t
             << std::endl;
   if (! m_ftofDigihit_link.empty()) {
      ostr << m_ftofDigihit_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string FtofHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ftofHit"
        << " dE=" << "\"" << getDE() << "\""
        << " end=" << "\"" << getEnd() << "\""
        << " t=" << "\"" << getT() << "\""
        << ">" << std::endl;
   if (! m_ftofDigihit_link.empty()) {
      ostr << m_ftofDigihit_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</ftofHit>"
        << std::endl;
   return ostr.str();
}

std::string FtofTruthExtra::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ftofTruthExtra"
        << " E=" << m_E
        << " dist=" << m_dist
        << " itrack=" << m_itrack
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   return ostr.str();
}

std::string FtofTruthExtra::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ftofTruthExtra"
        << " E=" << "\"" << getE() << "\""
        << " dist=" << "\"" << getDist() << "\""
        << " itrack=" << "\"" << getItrack() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FtofTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ftofTruthHit"
        << " dE=" << m_dE
        << " end=" << m_end
        << " t=" << m_t
             << std::endl;
   int FtofTruthExtraListCount=0;
   for (FtofTruthExtraList::iterator it = m_ftofTruthExtra_list.begin();
        it != m_ftofTruthExtra_list.end(); ++it)
   {
      if (++FtofTruthExtraListCount > m_ftofTruthExtra_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string FtofTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ftofTruthHit"
        << " dE=" << "\"" << getDE() << "\""
        << " end=" << "\"" << getEnd() << "\""
        << " t=" << "\"" << getT() << "\""
        << ">" << std::endl;
   int FtofTruthExtraListCount=0;
   for (FtofTruthExtraList::iterator it = m_ftofTruthExtra_list.begin();
        it != m_ftofTruthExtra_list.end(); ++it)
   {
      if (++FtofTruthExtraListCount > m_ftofTruthExtra_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</ftofTruthHit>"
        << std::endl;
   return ostr.str();
}

std::string FtofCounter::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ftofCounter"
        << " bar=" << m_bar
        << " plane=" << m_plane
             << std::endl;
   int FtofHitListCount=0;
   for (FtofHitList::iterator it = m_ftofHit_list.begin();
        it != m_ftofHit_list.end(); ++it)
   {
      if (++FtofHitListCount > m_ftofHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FtofTruthHitListCount=0;
   for (FtofTruthHitList::iterator it = m_ftofTruthHit_list.begin();
        it != m_ftofTruthHit_list.end(); ++it)
   {
      if (++FtofTruthHitListCount > m_ftofTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string FtofCounter::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ftofCounter"
        << " bar=" << "\"" << getBar() << "\""
        << " plane=" << "\"" << getPlane() << "\""
        << ">" << std::endl;
   int FtofHitListCount=0;
   for (FtofHitList::iterator it = m_ftofHit_list.begin();
        it != m_ftofHit_list.end(); ++it)
   {
      if (++FtofHitListCount > m_ftofHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FtofTruthHitListCount=0;
   for (FtofTruthHitList::iterator it = m_ftofTruthHit_list.begin();
        it != m_ftofTruthHit_list.end(); ++it)
   {
      if (++FtofTruthHitListCount > m_ftofTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</ftofCounter>"
        << std::endl;
   return ostr.str();
}

std::string FtofTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ftofTruthPoint"
        << " E=" << m_E
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string FtofTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ftofTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</ftofTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string ForwardTOF::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "forwardTOF"
             << std::endl;
   int FtofCounterListCount=0;
   for (FtofCounterList::iterator it = m_ftofCounter_list.begin();
        it != m_ftofCounter_list.end(); ++it)
   {
      if (++FtofCounterListCount > m_ftofCounter_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FtofTruthPointListCount=0;
   for (FtofTruthPointList::iterator it = m_ftofTruthPoint_list.begin();
        it != m_ftofTruthPoint_list.end(); ++it)
   {
      if (++FtofTruthPointListCount > m_ftofTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string ForwardTOF::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<forwardTOF"
        << ">" << std::endl;
   int FtofCounterListCount=0;
   for (FtofCounterList::iterator it = m_ftofCounter_list.begin();
        it != m_ftofCounter_list.end(); ++it)
   {
      if (++FtofCounterListCount > m_ftofCounter_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FtofTruthPointListCount=0;
   for (FtofTruthPointList::iterator it = m_ftofTruthPoint_list.begin();
        it != m_ftofTruthPoint_list.end(); ++it)
   {
      if (++FtofTruthPointListCount > m_ftofTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</forwardTOF>"
        << std::endl;
   return ostr.str();
}

std::string FcalDigihit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalDigihit"
        << " integralOverPeak=" << m_integralOverPeak
             << std::endl;
   return ostr.str();
}

std::string FcalDigihit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalDigihit"
        << " integralOverPeak=" << "\"" << getIntegralOverPeak() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalHit"
        << " E=" << m_E
        << " t=" << m_t
             << std::endl;
   if (! m_fcalDigihit_link.empty()) {
      ostr << m_fcalDigihit_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string FcalHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalHit"
        << " E=" << "\"" << getE() << "\""
        << " t=" << "\"" << getT() << "\""
        << ">" << std::endl;
   if (! m_fcalDigihit_link.empty()) {
      ostr << m_fcalDigihit_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fcalHit>"
        << std::endl;
   return ostr.str();
}

std::string FcalTruthLightGuide::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalTruthLightGuide"
        << " dE=" << m_dE
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string FcalTruthLightGuide::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalTruthLightGuide"
        << " dE=" << "\"" << getDE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FcalTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalTruthHit"
        << " E=" << m_E
        << " t=" << m_t
             << std::endl;
   int FcalTruthLightGuideListCount=0;
   for (FcalTruthLightGuideList::iterator it = m_fcalTruthLightGuide_list.begin();
        it != m_fcalTruthLightGuide_list.end(); ++it)
   {
      if (++FcalTruthLightGuideListCount > m_fcalTruthLightGuide_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string FcalTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalTruthHit"
        << " E=" << "\"" << getE() << "\""
        << " t=" << "\"" << getT() << "\""
        << ">" << std::endl;
   int FcalTruthLightGuideListCount=0;
   for (FcalTruthLightGuideList::iterator it = m_fcalTruthLightGuide_list.begin();
        it != m_fcalTruthLightGuide_list.end(); ++it)
   {
      if (++FcalTruthLightGuideListCount > m_fcalTruthLightGuide_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fcalTruthHit>"
        << std::endl;
   return ostr.str();
}

std::string FcalBlock::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalBlock"
        << " column=" << m_column
        << " row=" << m_row
             << std::endl;
   int FcalHitListCount=0;
   for (FcalHitList::iterator it = m_fcalHit_list.begin();
        it != m_fcalHit_list.end(); ++it)
   {
      if (++FcalHitListCount > m_fcalHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FcalTruthHitListCount=0;
   for (FcalTruthHitList::iterator it = m_fcalTruthHit_list.begin();
        it != m_fcalTruthHit_list.end(); ++it)
   {
      if (++FcalTruthHitListCount > m_fcalTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string FcalBlock::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalBlock"
        << " column=" << "\"" << getColumn() << "\""
        << " row=" << "\"" << getRow() << "\""
        << ">" << std::endl;
   int FcalHitListCount=0;
   for (FcalHitList::iterator it = m_fcalHit_list.begin();
        it != m_fcalHit_list.end(); ++it)
   {
      if (++FcalHitListCount > m_fcalHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FcalTruthHitListCount=0;
   for (FcalTruthHitList::iterator it = m_fcalTruthHit_list.begin();
        it != m_fcalTruthHit_list.end(); ++it)
   {
      if (++FcalTruthHitListCount > m_fcalTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fcalBlock>"
        << std::endl;
   return ostr.str();
}

std::string FcalTruthShower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fcalTruthShower"
        << " E=" << m_E
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string FcalTruthShower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fcalTruthShower"
        << " E=" << "\"" << getE() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fcalTruthShower>"
        << std::endl;
   return ostr.str();
}

std::string ForwardEMcal::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "forwardEMcal"
             << std::endl;
   int FcalBlockListCount=0;
   for (FcalBlockList::iterator it = m_fcalBlock_list.begin();
        it != m_fcalBlock_list.end(); ++it)
   {
      if (++FcalBlockListCount > m_fcalBlock_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FcalTruthShowerListCount=0;
   for (FcalTruthShowerList::iterator it = m_fcalTruthShower_list.begin();
        it != m_fcalTruthShower_list.end(); ++it)
   {
      if (++FcalTruthShowerListCount > m_fcalTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string ForwardEMcal::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<forwardEMcal"
        << ">" << std::endl;
   int FcalBlockListCount=0;
   for (FcalBlockList::iterator it = m_fcalBlock_list.begin();
        it != m_fcalBlock_list.end(); ++it)
   {
      if (++FcalBlockListCount > m_fcalBlock_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FcalTruthShowerListCount=0;
   for (FcalTruthShowerList::iterator it = m_fcalTruthShower_list.begin();
        it != m_fcalTruthShower_list.end(); ++it)
   {
      if (++FcalTruthShowerListCount > m_fcalTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</forwardEMcal>"
        << std::endl;
   return ostr.str();
}

std::string CcalHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ccalHit"
        << " E=" << m_E
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string CcalHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ccalHit"
        << " E=" << "\"" << getE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CcalTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ccalTruthHit"
        << " E=" << m_E
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string CcalTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ccalTruthHit"
        << " E=" << "\"" << getE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string CcalBlock::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ccalBlock"
        << " column=" << m_column
        << " row=" << m_row
             << std::endl;
   int CcalHitListCount=0;
   for (CcalHitList::iterator it = m_ccalHit_list.begin();
        it != m_ccalHit_list.end(); ++it)
   {
      if (++CcalHitListCount > m_ccalHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CcalTruthHitListCount=0;
   for (CcalTruthHitList::iterator it = m_ccalTruthHit_list.begin();
        it != m_ccalTruthHit_list.end(); ++it)
   {
      if (++CcalTruthHitListCount > m_ccalTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string CcalBlock::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ccalBlock"
        << " column=" << "\"" << getColumn() << "\""
        << " row=" << "\"" << getRow() << "\""
        << ">" << std::endl;
   int CcalHitListCount=0;
   for (CcalHitList::iterator it = m_ccalHit_list.begin();
        it != m_ccalHit_list.end(); ++it)
   {
      if (++CcalHitListCount > m_ccalHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CcalTruthHitListCount=0;
   for (CcalTruthHitList::iterator it = m_ccalTruthHit_list.begin();
        it != m_ccalTruthHit_list.end(); ++it)
   {
      if (++CcalTruthHitListCount > m_ccalTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</ccalBlock>"
        << std::endl;
   return ostr.str();
}

std::string CcalTruthShower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ccalTruthShower"
        << " E=" << m_E
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string CcalTruthShower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ccalTruthShower"
        << " E=" << "\"" << getE() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</ccalTruthShower>"
        << std::endl;
   return ostr.str();
}

std::string ComptonEMcal::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "ComptonEMcal"
             << std::endl;
   int CcalBlockListCount=0;
   for (CcalBlockList::iterator it = m_ccalBlock_list.begin();
        it != m_ccalBlock_list.end(); ++it)
   {
      if (++CcalBlockListCount > m_ccalBlock_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CcalTruthShowerListCount=0;
   for (CcalTruthShowerList::iterator it = m_ccalTruthShower_list.begin();
        it != m_ccalTruthShower_list.end(); ++it)
   {
      if (++CcalTruthShowerListCount > m_ccalTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string ComptonEMcal::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<ComptonEMcal"
        << ">" << std::endl;
   int CcalBlockListCount=0;
   for (CcalBlockList::iterator it = m_ccalBlock_list.begin();
        it != m_ccalBlock_list.end(); ++it)
   {
      if (++CcalBlockListCount > m_ccalBlock_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CcalTruthShowerListCount=0;
   for (CcalTruthShowerList::iterator it = m_ccalTruthShower_list.begin();
        it != m_ccalTruthShower_list.end(); ++it)
   {
      if (++CcalTruthShowerListCount > m_ccalTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</ComptonEMcal>"
        << std::endl;
   return ostr.str();
}

std::string UpvHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "upvHit"
        << " E=" << m_E
        << " end=" << m_end
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string UpvHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<upvHit"
        << " E=" << "\"" << getE() << "\""
        << " end=" << "\"" << getEnd() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string UpvTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "upvTruthHit"
        << " E=" << m_E
        << " end=" << m_end
        << " t=" << m_t
        << " xlocal=" << m_xlocal
             << std::endl;
   return ostr.str();
}

std::string UpvTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<upvTruthHit"
        << " E=" << "\"" << getE() << "\""
        << " end=" << "\"" << getEnd() << "\""
        << " t=" << "\"" << getT() << "\""
        << " xlocal=" << "\"" << getXlocal() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string UpvPaddle::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "upvPaddle"
        << " layer=" << m_layer
        << " row=" << m_row
             << std::endl;
   int UpvHitListCount=0;
   for (UpvHitList::iterator it = m_upvHit_list.begin();
        it != m_upvHit_list.end(); ++it)
   {
      if (++UpvHitListCount > m_upvHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int UpvTruthHitListCount=0;
   for (UpvTruthHitList::iterator it = m_upvTruthHit_list.begin();
        it != m_upvTruthHit_list.end(); ++it)
   {
      if (++UpvTruthHitListCount > m_upvTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string UpvPaddle::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<upvPaddle"
        << " layer=" << "\"" << getLayer() << "\""
        << " row=" << "\"" << getRow() << "\""
        << ">" << std::endl;
   int UpvHitListCount=0;
   for (UpvHitList::iterator it = m_upvHit_list.begin();
        it != m_upvHit_list.end(); ++it)
   {
      if (++UpvHitListCount > m_upvHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int UpvTruthHitListCount=0;
   for (UpvTruthHitList::iterator it = m_upvTruthHit_list.begin();
        it != m_upvTruthHit_list.end(); ++it)
   {
      if (++UpvTruthHitListCount > m_upvTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</upvPaddle>"
        << std::endl;
   return ostr.str();
}

std::string UpvTruthShower::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "upvTruthShower"
        << " E=" << m_E
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string UpvTruthShower::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<upvTruthShower"
        << " E=" << "\"" << getE() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</upvTruthShower>"
        << std::endl;
   return ostr.str();
}

std::string UpstreamEMveto::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "upstreamEMveto"
             << std::endl;
   int UpvPaddleListCount=0;
   for (UpvPaddleList::iterator it = m_upvPaddle_list.begin();
        it != m_upvPaddle_list.end(); ++it)
   {
      if (++UpvPaddleListCount > m_upvPaddle_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int UpvTruthShowerListCount=0;
   for (UpvTruthShowerList::iterator it = m_upvTruthShower_list.begin();
        it != m_upvTruthShower_list.end(); ++it)
   {
      if (++UpvTruthShowerListCount > m_upvTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string UpstreamEMveto::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<upstreamEMveto"
        << ">" << std::endl;
   int UpvPaddleListCount=0;
   for (UpvPaddleList::iterator it = m_upvPaddle_list.begin();
        it != m_upvPaddle_list.end(); ++it)
   {
      if (++UpvPaddleListCount > m_upvPaddle_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int UpvTruthShowerListCount=0;
   for (UpvTruthShowerList::iterator it = m_upvTruthShower_list.begin();
        it != m_upvTruthShower_list.end(); ++it)
   {
      if (++UpvTruthShowerListCount > m_upvTruthShower_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</upstreamEMveto>"
        << std::endl;
   return ostr.str();
}

std::string TaggerHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "taggerHit"
        << " npe=" << m_npe
        << " t=" << m_t
        << " tADC=" << m_tADC
             << std::endl;
   return ostr.str();
}

std::string TaggerHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<taggerHit"
        << " npe=" << "\"" << getNpe() << "\""
        << " t=" << "\"" << getT() << "\""
        << " tADC=" << "\"" << getTADC() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TaggerTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "taggerTruthHit"
        << " E=" << m_E
        << " bg=" << m_bg
        << " dE=" << m_dE
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string TaggerTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<taggerTruthHit"
        << " E=" << "\"" << getE() << "\""
        << " bg=" << "\"" << getBg() << "\""
        << " dE=" << "\"" << getDE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string MicroChannel::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "microChannel"
        << " E=" << m_E
        << " column=" << m_column
        << " row=" << m_row
             << std::endl;
   int TaggerHitListCount=0;
   for (TaggerHitList::iterator it = m_taggerHit_list.begin();
        it != m_taggerHit_list.end(); ++it)
   {
      if (++TaggerHitListCount > m_taggerHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TaggerTruthHitListCount=0;
   for (TaggerTruthHitList::iterator it = m_taggerTruthHit_list.begin();
        it != m_taggerTruthHit_list.end(); ++it)
   {
      if (++TaggerTruthHitListCount > m_taggerTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string MicroChannel::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<microChannel"
        << " E=" << "\"" << getE() << "\""
        << " column=" << "\"" << getColumn() << "\""
        << " row=" << "\"" << getRow() << "\""
        << ">" << std::endl;
   int TaggerHitListCount=0;
   for (TaggerHitList::iterator it = m_taggerHit_list.begin();
        it != m_taggerHit_list.end(); ++it)
   {
      if (++TaggerHitListCount > m_taggerHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TaggerTruthHitListCount=0;
   for (TaggerTruthHitList::iterator it = m_taggerTruthHit_list.begin();
        it != m_taggerTruthHit_list.end(); ++it)
   {
      if (++TaggerTruthHitListCount > m_taggerTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</microChannel>"
        << std::endl;
   return ostr.str();
}

std::string HodoChannel::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "hodoChannel"
        << " E=" << m_E
        << " counterId=" << m_counterId
             << std::endl;
   int TaggerHitListCount=0;
   for (TaggerHitList::iterator it = m_taggerHit_list.begin();
        it != m_taggerHit_list.end(); ++it)
   {
      if (++TaggerHitListCount > m_taggerHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TaggerTruthHitListCount=0;
   for (TaggerTruthHitList::iterator it = m_taggerTruthHit_list.begin();
        it != m_taggerTruthHit_list.end(); ++it)
   {
      if (++TaggerTruthHitListCount > m_taggerTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string HodoChannel::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<hodoChannel"
        << " E=" << "\"" << getE() << "\""
        << " counterId=" << "\"" << getCounterId() << "\""
        << ">" << std::endl;
   int TaggerHitListCount=0;
   for (TaggerHitList::iterator it = m_taggerHit_list.begin();
        it != m_taggerHit_list.end(); ++it)
   {
      if (++TaggerHitListCount > m_taggerHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TaggerTruthHitListCount=0;
   for (TaggerTruthHitList::iterator it = m_taggerTruthHit_list.begin();
        it != m_taggerTruthHit_list.end(); ++it)
   {
      if (++TaggerTruthHitListCount > m_taggerTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</hodoChannel>"
        << std::endl;
   return ostr.str();
}

std::string Tagger::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tagger"
             << std::endl;
   int MicroChannelListCount=0;
   for (MicroChannelList::iterator it = m_microChannel_list.begin();
        it != m_microChannel_list.end(); ++it)
   {
      if (++MicroChannelListCount > m_microChannel_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int HodoChannelListCount=0;
   for (HodoChannelList::iterator it = m_hodoChannel_list.begin();
        it != m_hodoChannel_list.end(); ++it)
   {
      if (++HodoChannelListCount > m_hodoChannel_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string Tagger::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tagger"
        << ">" << std::endl;
   int MicroChannelListCount=0;
   for (MicroChannelList::iterator it = m_microChannel_list.begin();
        it != m_microChannel_list.end(); ++it)
   {
      if (++MicroChannelListCount > m_microChannel_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int HodoChannelListCount=0;
   for (HodoChannelList::iterator it = m_hodoChannel_list.begin();
        it != m_hodoChannel_list.end(); ++it)
   {
      if (++HodoChannelListCount > m_hodoChannel_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</tagger>"
        << std::endl;
   return ostr.str();
}

std::string PsHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "psHit"
        << " dE=" << m_dE
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string PsHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<psHit"
        << " dE=" << "\"" << getDE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string PsTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "psTruthHit"
        << " dE=" << m_dE
        << " itrack=" << m_itrack
        << " ptype=" << m_ptype
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string PsTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<psTruthHit"
        << " dE=" << "\"" << getDE() << "\""
        << " itrack=" << "\"" << getItrack() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string PsTile::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "psTile"
        << " arm=" << m_arm
        << " column=" << m_column
             << std::endl;
   int PsHitListCount=0;
   for (PsHitList::iterator it = m_psHit_list.begin();
        it != m_psHit_list.end(); ++it)
   {
      if (++PsHitListCount > m_psHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int PsTruthHitListCount=0;
   for (PsTruthHitList::iterator it = m_psTruthHit_list.begin();
        it != m_psTruthHit_list.end(); ++it)
   {
      if (++PsTruthHitListCount > m_psTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string PsTile::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<psTile"
        << " arm=" << "\"" << getArm() << "\""
        << " column=" << "\"" << getColumn() << "\""
        << ">" << std::endl;
   int PsHitListCount=0;
   for (PsHitList::iterator it = m_psHit_list.begin();
        it != m_psHit_list.end(); ++it)
   {
      if (++PsHitListCount > m_psHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int PsTruthHitListCount=0;
   for (PsTruthHitList::iterator it = m_psTruthHit_list.begin();
        it != m_psTruthHit_list.end(); ++it)
   {
      if (++PsTruthHitListCount > m_psTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</psTile>"
        << std::endl;
   return ostr.str();
}

std::string PsTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "psTruthPoint"
        << " E=" << m_E
        << " arm=" << m_arm
        << " column=" << m_column
        << " dEdx=" << m_dEdx
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string PsTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<psTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " arm=" << "\"" << getArm() << "\""
        << " column=" << "\"" << getColumn() << "\""
        << " dEdx=" << "\"" << getDEdx() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</psTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string PairSpectrometerFine::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "pairSpectrometerFine"
             << std::endl;
   int PsTileListCount=0;
   for (PsTileList::iterator it = m_psTile_list.begin();
        it != m_psTile_list.end(); ++it)
   {
      if (++PsTileListCount > m_psTile_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int PsTruthPointListCount=0;
   for (PsTruthPointList::iterator it = m_psTruthPoint_list.begin();
        it != m_psTruthPoint_list.end(); ++it)
   {
      if (++PsTruthPointListCount > m_psTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string PairSpectrometerFine::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<pairSpectrometerFine"
        << ">" << std::endl;
   int PsTileListCount=0;
   for (PsTileList::iterator it = m_psTile_list.begin();
        it != m_psTile_list.end(); ++it)
   {
      if (++PsTileListCount > m_psTile_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int PsTruthPointListCount=0;
   for (PsTruthPointList::iterator it = m_psTruthPoint_list.begin();
        it != m_psTruthPoint_list.end(); ++it)
   {
      if (++PsTruthPointListCount > m_psTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</pairSpectrometerFine>"
        << std::endl;
   return ostr.str();
}

std::string PscHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "pscHit"
        << " dE=" << m_dE
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string PscHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<pscHit"
        << " dE=" << "\"" << getDE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string PscTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "pscTruthHit"
        << " dE=" << m_dE
        << " itrack=" << m_itrack
        << " ptype=" << m_ptype
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string PscTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<pscTruthHit"
        << " dE=" << "\"" << getDE() << "\""
        << " itrack=" << "\"" << getItrack() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string PscPaddle::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "pscPaddle"
        << " arm=" << m_arm
        << " module=" << m_module
             << std::endl;
   int PscHitListCount=0;
   for (PscHitList::iterator it = m_pscHit_list.begin();
        it != m_pscHit_list.end(); ++it)
   {
      if (++PscHitListCount > m_pscHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int PscTruthHitListCount=0;
   for (PscTruthHitList::iterator it = m_pscTruthHit_list.begin();
        it != m_pscTruthHit_list.end(); ++it)
   {
      if (++PscTruthHitListCount > m_pscTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string PscPaddle::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<pscPaddle"
        << " arm=" << "\"" << getArm() << "\""
        << " module=" << "\"" << getModule() << "\""
        << ">" << std::endl;
   int PscHitListCount=0;
   for (PscHitList::iterator it = m_pscHit_list.begin();
        it != m_pscHit_list.end(); ++it)
   {
      if (++PscHitListCount > m_pscHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int PscTruthHitListCount=0;
   for (PscTruthHitList::iterator it = m_pscTruthHit_list.begin();
        it != m_pscTruthHit_list.end(); ++it)
   {
      if (++PscTruthHitListCount > m_pscTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</pscPaddle>"
        << std::endl;
   return ostr.str();
}

std::string PscTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "pscTruthPoint"
        << " E=" << m_E
        << " arm=" << m_arm
        << " dEdx=" << m_dEdx
        << " module=" << m_module
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string PscTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<pscTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " arm=" << "\"" << getArm() << "\""
        << " dEdx=" << "\"" << getDEdx() << "\""
        << " module=" << "\"" << getModule() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</pscTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string PairSpectrometerCoarse::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "pairSpectrometerCoarse"
             << std::endl;
   int PscPaddleListCount=0;
   for (PscPaddleList::iterator it = m_pscPaddle_list.begin();
        it != m_pscPaddle_list.end(); ++it)
   {
      if (++PscPaddleListCount > m_pscPaddle_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int PscTruthPointListCount=0;
   for (PscTruthPointList::iterator it = m_pscTruthPoint_list.begin();
        it != m_pscTruthPoint_list.end(); ++it)
   {
      if (++PscTruthPointListCount > m_pscTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string PairSpectrometerCoarse::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<pairSpectrometerCoarse"
        << ">" << std::endl;
   int PscPaddleListCount=0;
   for (PscPaddleList::iterator it = m_pscPaddle_list.begin();
        it != m_pscPaddle_list.end(); ++it)
   {
      if (++PscPaddleListCount > m_pscPaddle_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int PscTruthPointListCount=0;
   for (PscTruthPointList::iterator it = m_pscTruthPoint_list.begin();
        it != m_pscTruthPoint_list.end(); ++it)
   {
      if (++PscTruthPointListCount > m_pscTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</pairSpectrometerCoarse>"
        << std::endl;
   return ostr.str();
}

std::string TpolHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tpolHit"
        << " dE=" << m_dE
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string TpolHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tpolHit"
        << " dE=" << "\"" << getDE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TpolTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tpolTruthHit"
        << " dE=" << m_dE
        << " itrack=" << m_itrack
        << " ptype=" << m_ptype
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string TpolTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tpolTruthHit"
        << " dE=" << "\"" << getDE() << "\""
        << " itrack=" << "\"" << getItrack() << "\""
        << " ptype=" << "\"" << getPtype() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TpolSector::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tpolSector"
        << " ring=" << m_ring
        << " sector=" << m_sector
             << std::endl;
   int TpolHitListCount=0;
   for (TpolHitList::iterator it = m_tpolHit_list.begin();
        it != m_tpolHit_list.end(); ++it)
   {
      if (++TpolHitListCount > m_tpolHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TpolTruthHitListCount=0;
   for (TpolTruthHitList::iterator it = m_tpolTruthHit_list.begin();
        it != m_tpolTruthHit_list.end(); ++it)
   {
      if (++TpolTruthHitListCount > m_tpolTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string TpolSector::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tpolSector"
        << " ring=" << "\"" << getRing() << "\""
        << " sector=" << "\"" << getSector() << "\""
        << ">" << std::endl;
   int TpolHitListCount=0;
   for (TpolHitList::iterator it = m_tpolHit_list.begin();
        it != m_tpolHit_list.end(); ++it)
   {
      if (++TpolHitListCount > m_tpolHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TpolTruthHitListCount=0;
   for (TpolTruthHitList::iterator it = m_tpolTruthHit_list.begin();
        it != m_tpolTruthHit_list.end(); ++it)
   {
      if (++TpolTruthHitListCount > m_tpolTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</tpolSector>"
        << std::endl;
   return ostr.str();
}

std::string TpolTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tpolTruthPoint"
        << " E=" << m_E
        << " dEdx=" << m_dEdx
        << " phi=" << m_phi
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " r=" << m_r
        << " t=" << m_t
        << " track=" << m_track
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string TpolTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tpolTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " dEdx=" << "\"" << getDEdx() << "\""
        << " phi=" << "\"" << getPhi() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " r=" << "\"" << getR() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</tpolTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string TripletPolarimeter::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tripletPolarimeter"
             << std::endl;
   int TpolSectorListCount=0;
   for (TpolSectorList::iterator it = m_tpolSector_list.begin();
        it != m_tpolSector_list.end(); ++it)
   {
      if (++TpolSectorListCount > m_tpolSector_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int TpolTruthPointListCount=0;
   for (TpolTruthPointList::iterator it = m_tpolTruthPoint_list.begin();
        it != m_tpolTruthPoint_list.end(); ++it)
   {
      if (++TpolTruthPointListCount > m_tpolTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string TripletPolarimeter::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tripletPolarimeter"
        << ">" << std::endl;
   int TpolSectorListCount=0;
   for (TpolSectorList::iterator it = m_tpolSector_list.begin();
        it != m_tpolSector_list.end(); ++it)
   {
      if (++TpolSectorListCount > m_tpolSector_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int TpolTruthPointListCount=0;
   for (TpolTruthPointList::iterator it = m_tpolTruthPoint_list.begin();
        it != m_tpolTruthPoint_list.end(); ++it)
   {
      if (++TpolTruthPointListCount > m_tpolTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</tripletPolarimeter>"
        << std::endl;
   return ostr.str();
}

std::string McTrajectoryPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "mcTrajectoryPoint"
        << " E=" << m_E
        << " dE=" << m_dE
        << " mech=" << m_mech
        << " part=" << m_part
        << " primary_track=" << m_primary_track
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " radlen=" << m_radlen
        << " step=" << m_step
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   return ostr.str();
}

std::string McTrajectoryPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<mcTrajectoryPoint"
        << " E=" << "\"" << getE() << "\""
        << " dE=" << "\"" << getDE() << "\""
        << " mech=" << "\"" << getMech() << "\""
        << " part=" << "\"" << getPart() << "\""
        << " primary_track=" << "\"" << getPrimary_track() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " radlen=" << "\"" << getRadlen() << "\""
        << " step=" << "\"" << getStep() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string McTrajectory::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "mcTrajectory"
             << std::endl;
   int McTrajectoryPointListCount=0;
   for (McTrajectoryPointList::iterator it = m_mcTrajectoryPoint_list.begin();
        it != m_mcTrajectoryPoint_list.end(); ++it)
   {
      if (++McTrajectoryPointListCount > m_mcTrajectoryPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string McTrajectory::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<mcTrajectory"
        << ">" << std::endl;
   int McTrajectoryPointListCount=0;
   for (McTrajectoryPointList::iterator it = m_mcTrajectoryPoint_list.begin();
        it != m_mcTrajectoryPoint_list.end(); ++it)
   {
      if (++McTrajectoryPointListCount > m_mcTrajectoryPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</mcTrajectory>"
        << std::endl;
   return ostr.str();
}

std::string RFsubsystem::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "RFsubsystem"
        << " jtag=" << "\"" << m_jtag << "\""
        << " tsync=" << m_tsync
             << std::endl;
   return ostr.str();
}

std::string RFsubsystem::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<RFsubsystem"
        << " jtag=" << "\"" << getJtag() << "\""
        << " tsync=" << "\"" << getTsync() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string RFtime::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "RFtime"
        << " jtag=" << "\"" << m_jtag << "\""
        << " tsync=" << m_tsync
             << std::endl;
   int RFsubsystemListCount=0;
   for (RFsubsystemList::iterator it = m_RFsubsystem_list.begin();
        it != m_RFsubsystem_list.end(); ++it)
   {
      if (++RFsubsystemListCount > m_RFsubsystem_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string RFtime::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<RFtime"
        << " jtag=" << "\"" << getJtag() << "\""
        << " tsync=" << "\"" << getTsync() << "\""
        << " tunit=" << "\"" << getTunit() << "\""
        << ">" << std::endl;
   int RFsubsystemListCount=0;
   for (RFsubsystemList::iterator it = m_RFsubsystem_list.begin();
        it != m_RFsubsystem_list.end(); ++it)
   {
      if (++RFsubsystemListCount > m_RFsubsystem_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</RFtime>"
        << std::endl;
   return ostr.str();
}

std::string FmwpcTruthHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fmwpcTruthHit"
        << " dE=" << m_dE
        << " dx=" << m_dx
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string FmwpcTruthHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fmwpcTruthHit"
        << " dE=" << "\"" << getDE() << "\""
        << " dx=" << "\"" << getDx() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FmwpcHit::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fmwpcHit"
        << " dE=" << m_dE
        << " t=" << m_t
             << std::endl;
   return ostr.str();
}

std::string FmwpcHit::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fmwpcHit"
        << " dE=" << "\"" << getDE() << "\""
        << " t=" << "\"" << getT() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string FmwpcChamber::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fmwpcChamber"
        << " layer=" << m_layer
        << " wire=" << m_wire
             << std::endl;
   int FmwpcTruthHitListCount=0;
   for (FmwpcTruthHitList::iterator it = m_fmwpcTruthHit_list.begin();
        it != m_fmwpcTruthHit_list.end(); ++it)
   {
      if (++FmwpcTruthHitListCount > m_fmwpcTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FmwpcHitListCount=0;
   for (FmwpcHitList::iterator it = m_fmwpcHit_list.begin();
        it != m_fmwpcHit_list.end(); ++it)
   {
      if (++FmwpcHitListCount > m_fmwpcHit_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string FmwpcChamber::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fmwpcChamber"
        << " layer=" << "\"" << getLayer() << "\""
        << " wire=" << "\"" << getWire() << "\""
        << ">" << std::endl;
   int FmwpcTruthHitListCount=0;
   for (FmwpcTruthHitList::iterator it = m_fmwpcTruthHit_list.begin();
        it != m_fmwpcTruthHit_list.end(); ++it)
   {
      if (++FmwpcTruthHitListCount > m_fmwpcTruthHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FmwpcHitListCount=0;
   for (FmwpcHitList::iterator it = m_fmwpcHit_list.begin();
        it != m_fmwpcHit_list.end(); ++it)
   {
      if (++FmwpcHitListCount > m_fmwpcHit_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fmwpcChamber>"
        << std::endl;
   return ostr.str();
}

std::string FmwpcTruthPoint::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "fmwpcTruthPoint"
        << " E=" << m_E
        << " primary=" << ((m_primary == 0)? "true" : "false")
        << " ptype=" << m_ptype
        << " px=" << m_px
        << " py=" << m_py
        << " pz=" << m_pz
        << " t=" << m_t
        << " track=" << m_track
        << " x=" << m_x
        << " y=" << m_y
        << " z=" << m_z
             << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string FmwpcTruthPoint::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<fmwpcTruthPoint"
        << " E=" << "\"" << getE() << "\""
        << " primary=" << ((m_primary == 0)? "\"true\"" : "\"false\"")
        << " ptype=" << "\"" << getPtype() << "\""
        << " px=" << "\"" << getPx() << "\""
        << " py=" << "\"" << getPy() << "\""
        << " pz=" << "\"" << getPz() << "\""
        << " t=" << "\"" << getT() << "\""
        << " track=" << "\"" << getTrack() << "\""
        << " x=" << "\"" << getX() << "\""
        << " y=" << "\"" << getY() << "\""
        << " z=" << "\"" << getZ() << "\""
        << ">" << std::endl;
   if (! m_trackID_link.empty()) {
      ostr << m_trackID_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</fmwpcTruthPoint>"
        << std::endl;
   return ostr.str();
}

std::string ForwardMWPC::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "forwardMWPC"
             << std::endl;
   int FmwpcChamberListCount=0;
   for (FmwpcChamberList::iterator it = m_fmwpcChamber_list.begin();
        it != m_fmwpcChamber_list.end(); ++it)
   {
      if (++FmwpcChamberListCount > m_fmwpcChamber_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int FmwpcTruthPointListCount=0;
   for (FmwpcTruthPointList::iterator it = m_fmwpcTruthPoint_list.begin();
        it != m_fmwpcTruthPoint_list.end(); ++it)
   {
      if (++FmwpcTruthPointListCount > m_fmwpcTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string ForwardMWPC::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<forwardMWPC"
        << ">" << std::endl;
   int FmwpcChamberListCount=0;
   for (FmwpcChamberList::iterator it = m_fmwpcChamber_list.begin();
        it != m_fmwpcChamber_list.end(); ++it)
   {
      if (++FmwpcChamberListCount > m_fmwpcChamber_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int FmwpcTruthPointListCount=0;
   for (FmwpcTruthPointList::iterator it = m_fmwpcTruthPoint_list.begin();
        it != m_fmwpcTruthPoint_list.end(); ++it)
   {
      if (++FmwpcTruthPointListCount > m_fmwpcTruthPoint_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</forwardMWPC>"
        << std::endl;
   return ostr.str();
}

std::string HitView::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "hitView"
             << std::endl;
   if (! m_centralDC_link.empty()) {
      ostr << m_centralDC_link.begin()->toString(indent + 2);
   }
   if (! m_forwardDC_link.empty()) {
      ostr << m_forwardDC_link.begin()->toString(indent + 2);
   }
   if (! m_startCntr_link.empty()) {
      ostr << m_startCntr_link.begin()->toString(indent + 2);
   }
   if (! m_barrelEMcal_link.empty()) {
      ostr << m_barrelEMcal_link.begin()->toString(indent + 2);
   }
   if (! m_gapEMcal_link.empty()) {
      ostr << m_gapEMcal_link.begin()->toString(indent + 2);
   }
   if (! m_Cerenkov_link.empty()) {
      ostr << m_Cerenkov_link.begin()->toString(indent + 2);
   }
   if (! m_RICH_link.empty()) {
      ostr << m_RICH_link.begin()->toString(indent + 2);
   }
   if (! m_DIRC_link.empty()) {
      ostr << m_DIRC_link.begin()->toString(indent + 2);
   }
   if (! m_forwardTOF_link.empty()) {
      ostr << m_forwardTOF_link.begin()->toString(indent + 2);
   }
   if (! m_forwardEMcal_link.empty()) {
      ostr << m_forwardEMcal_link.begin()->toString(indent + 2);
   }
   if (! m_ComptonEMcal_link.empty()) {
      ostr << m_ComptonEMcal_link.begin()->toString(indent + 2);
   }
   if (! m_upstreamEMveto_link.empty()) {
      ostr << m_upstreamEMveto_link.begin()->toString(indent + 2);
   }
   if (! m_tagger_link.empty()) {
      ostr << m_tagger_link.begin()->toString(indent + 2);
   }
   if (! m_pairSpectrometerFine_link.empty()) {
      ostr << m_pairSpectrometerFine_link.begin()->toString(indent + 2);
   }
   if (! m_pairSpectrometerCoarse_link.empty()) {
      ostr << m_pairSpectrometerCoarse_link.begin()->toString(indent + 2);
   }
   if (! m_tripletPolarimeter_link.empty()) {
      ostr << m_tripletPolarimeter_link.begin()->toString(indent + 2);
   }
   if (! m_mcTrajectory_link.empty()) {
      ostr << m_mcTrajectory_link.begin()->toString(indent + 2);
   }
   if (! m_RFtime_link.empty()) {
      ostr << m_RFtime_link.begin()->toString(indent + 2);
   }
   if (! m_forwardMWPC_link.empty()) {
      ostr << m_forwardMWPC_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string HitView::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<hitView"
        << " version=" << "\"" << getVersion() << "\""
        << ">" << std::endl;
   if (! m_centralDC_link.empty()) {
      ostr << m_centralDC_link.begin()->toXML(indent + 2);
   }
   if (! m_forwardDC_link.empty()) {
      ostr << m_forwardDC_link.begin()->toXML(indent + 2);
   }
   if (! m_startCntr_link.empty()) {
      ostr << m_startCntr_link.begin()->toXML(indent + 2);
   }
   if (! m_barrelEMcal_link.empty()) {
      ostr << m_barrelEMcal_link.begin()->toXML(indent + 2);
   }
   if (! m_gapEMcal_link.empty()) {
      ostr << m_gapEMcal_link.begin()->toXML(indent + 2);
   }
   if (! m_Cerenkov_link.empty()) {
      ostr << m_Cerenkov_link.begin()->toXML(indent + 2);
   }
   if (! m_RICH_link.empty()) {
      ostr << m_RICH_link.begin()->toXML(indent + 2);
   }
   if (! m_DIRC_link.empty()) {
      ostr << m_DIRC_link.begin()->toXML(indent + 2);
   }
   if (! m_forwardTOF_link.empty()) {
      ostr << m_forwardTOF_link.begin()->toXML(indent + 2);
   }
   if (! m_forwardEMcal_link.empty()) {
      ostr << m_forwardEMcal_link.begin()->toXML(indent + 2);
   }
   if (! m_ComptonEMcal_link.empty()) {
      ostr << m_ComptonEMcal_link.begin()->toXML(indent + 2);
   }
   if (! m_upstreamEMveto_link.empty()) {
      ostr << m_upstreamEMveto_link.begin()->toXML(indent + 2);
   }
   if (! m_tagger_link.empty()) {
      ostr << m_tagger_link.begin()->toXML(indent + 2);
   }
   if (! m_pairSpectrometerFine_link.empty()) {
      ostr << m_pairSpectrometerFine_link.begin()->toXML(indent + 2);
   }
   if (! m_pairSpectrometerCoarse_link.empty()) {
      ostr << m_pairSpectrometerCoarse_link.begin()->toXML(indent + 2);
   }
   if (! m_tripletPolarimeter_link.empty()) {
      ostr << m_tripletPolarimeter_link.begin()->toXML(indent + 2);
   }
   if (! m_mcTrajectory_link.empty()) {
      ostr << m_mcTrajectory_link.begin()->toXML(indent + 2);
   }
   if (! m_RFtime_link.empty()) {
      ostr << m_RFtime_link.begin()->toXML(indent + 2);
   }
   if (! m_forwardMWPC_link.empty()) {
      ostr << m_forwardMWPC_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</hitView>"
        << std::endl;
   return ostr.str();
}

std::string ErrorMatrix::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "errorMatrix"
        << " Ncols=" << m_Ncols
        << " Nrows=" << m_Nrows
        << " type=" << "\"" << m_type << "\""
        << " vals=" << "\"" << m_vals << "\""
             << std::endl;
   return ostr.str();
}

std::string ErrorMatrix::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<errorMatrix"
        << " Ncols=" << "\"" << getNcols() << "\""
        << " Nrows=" << "\"" << getNrows() << "\""
        << " type=" << "\"" << getType() << "\""
        << " vals=" << "\"" << getVals() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string TrackingErrorMatrix::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "TrackingErrorMatrix"
        << " Ncols=" << m_Ncols
        << " Nrows=" << m_Nrows
        << " type=" << "\"" << m_type << "\""
        << " vals=" << "\"" << m_vals << "\""
             << std::endl;
   return ostr.str();
}

std::string TrackingErrorMatrix::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<TrackingErrorMatrix"
        << " Ncols=" << "\"" << getNcols() << "\""
        << " Nrows=" << "\"" << getNrows() << "\""
        << " type=" << "\"" << getType() << "\""
        << " vals=" << "\"" << getVals() << "\""
        << " />" << std::endl;
   return ostr.str();
}

std::string Tracktimebased::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "tracktimebased"
        << " FOM=" << m_FOM
        << " Ndof=" << m_Ndof
        << " candidateid=" << m_candidateid
        << " chisq=" << m_chisq
        << " id=" << m_id
        << " trackid=" << m_trackid
             << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toString(indent + 2);
   }
   if (! m_properties_link.empty()) {
      ostr << m_properties_link.begin()->toString(indent + 2);
   }
   if (! m_origin_link.empty()) {
      ostr << m_origin_link.begin()->toString(indent + 2);
   }
   if (! m_errorMatrix_link.empty()) {
      ostr << m_errorMatrix_link.begin()->toString(indent + 2);
   }
   if (! m_TrackingErrorMatrix_link.empty()) {
      ostr << m_TrackingErrorMatrix_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string Tracktimebased::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<tracktimebased"
        << " FOM=" << "\"" << getFOM() << "\""
        << " Ndof=" << "\"" << getNdof() << "\""
        << " candidateid=" << "\"" << getCandidateid() << "\""
        << " chisq=" << "\"" << getChisq() << "\""
        << " id=" << "\"" << getId() << "\""
        << " trackid=" << "\"" << getTrackid() << "\""
        << ">" << std::endl;
   if (! m_momentum_link.empty()) {
      ostr << m_momentum_link.begin()->toXML(indent + 2);
   }
   if (! m_properties_link.empty()) {
      ostr << m_properties_link.begin()->toXML(indent + 2);
   }
   if (! m_origin_link.empty()) {
      ostr << m_origin_link.begin()->toXML(indent + 2);
   }
   if (! m_errorMatrix_link.empty()) {
      ostr << m_errorMatrix_link.begin()->toXML(indent + 2);
   }
   if (! m_TrackingErrorMatrix_link.empty()) {
      ostr << m_TrackingErrorMatrix_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</tracktimebased>"
        << std::endl;
   return ostr.str();
}

std::string ReconView::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "reconView"
             << std::endl;
   int TracktimebasedListCount=0;
   for (TracktimebasedList::iterator it = m_tracktimebased_list.begin();
        it != m_tracktimebased_list.end(); ++it)
   {
      if (++TracktimebasedListCount > m_tracktimebased_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string ReconView::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<reconView"
        << " version=" << "\"" << getVersion() << "\""
        << ">" << std::endl;
   int TracktimebasedListCount=0;
   for (TracktimebasedList::iterator it = m_tracktimebased_list.begin();
        it != m_tracktimebased_list.end(); ++it)
   {
      if (++TracktimebasedListCount > m_tracktimebased_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</reconView>"
        << std::endl;
   return ostr.str();
}

std::string PhysicsEvent::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "physicsEvent"
        << " eventNo=" << m_eventNo
        << " runNo=" << m_runNo
             << std::endl;
   int DataVersionStringListCount=0;
   for (DataVersionStringList::iterator it = m_dataVersionString_list.begin();
        it != m_dataVersionString_list.end(); ++it)
   {
      if (++DataVersionStringListCount > m_dataVersionString_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int CcdbContextListCount=0;
   for (CcdbContextList::iterator it = m_ccdbContext_list.begin();
        it != m_ccdbContext_list.end(); ++it)
   {
      if (++CcdbContextListCount > m_ccdbContext_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   int ReactionListCount=0;
   for (ReactionList::iterator it = m_reaction_list.begin();
        it != m_reaction_list.end(); ++it)
   {
      if (++ReactionListCount > m_reaction_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   if (! m_hitView_link.empty()) {
      ostr << m_hitView_link.begin()->toString(indent + 2);
   }
   if (! m_reconView_link.empty()) {
      ostr << m_reconView_link.begin()->toString(indent + 2);
   }
   return ostr.str();
}

std::string PhysicsEvent::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<physicsEvent"
        << " eventNo=" << "\"" << getEventNo() << "\""
        << " runNo=" << "\"" << getRunNo() << "\""
        << ">" << std::endl;
   int DataVersionStringListCount=0;
   for (DataVersionStringList::iterator it = m_dataVersionString_list.begin();
        it != m_dataVersionString_list.end(); ++it)
   {
      if (++DataVersionStringListCount > m_dataVersionString_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int CcdbContextListCount=0;
   for (CcdbContextList::iterator it = m_ccdbContext_list.begin();
        it != m_ccdbContext_list.end(); ++it)
   {
      if (++CcdbContextListCount > m_ccdbContext_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   int ReactionListCount=0;
   for (ReactionList::iterator it = m_reaction_list.begin();
        it != m_reaction_list.end(); ++it)
   {
      if (++ReactionListCount > m_reaction_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   if (! m_hitView_link.empty()) {
      ostr << m_hitView_link.begin()->toXML(indent + 2);
   }
   if (! m_reconView_link.empty()) {
      ostr << m_reconView_link.begin()->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</physicsEvent>"
        << std::endl;
   return ostr.str();
}

std::string HDDM::toString(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "HDDM"
             << std::endl;
   if (! m_geometry_link.empty()) {
      ostr << m_geometry_link.begin()->toString(indent + 2);
   }
   int PhysicsEventListCount=0;
   for (PhysicsEventList::iterator it = m_physicsEvent_list.begin();
        it != m_physicsEvent_list.end(); ++it)
   {
      if (++PhysicsEventListCount > m_physicsEvent_list.size()) {
         throw std::runtime_error("hddm_s::toString error - list improperly terminated!");
      }
      ostr << it->toString(indent + 2);
   }
   return ostr.str();
}

std::string HDDM::toXML(int indent) {
   std::stringstream ostr;
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "<HDDM"
        << " class=" << "\"" << getClass() << "\""
        << " version=" << "\"" << getVersion() << "\""
        << " xmlns=" << "\"" << getXmlns() << "\""
        << ">" << std::endl;
   if (! m_geometry_link.empty()) {
      ostr << m_geometry_link.begin()->toXML(indent + 2);
   }
   int PhysicsEventListCount=0;
   for (PhysicsEventList::iterator it = m_physicsEvent_list.begin();
        it != m_physicsEvent_list.end(); ++it)
   {
      if (++PhysicsEventListCount > m_physicsEvent_list.size()) {
         throw std::runtime_error("hddm_s::toXML error - list improperly terminated!");
      }
      ostr << it->toXML(indent + 2);
   }
   for (int n=0; n < indent; ++n)
      ostr << " ";
   ostr << "</HDDM>"
        << std::endl;
   return ostr.str();
}


streamposition::streamposition()
 : block_start(), block_offset(), block_status() {}

streamposition::streamposition(uint64_t start, uint32_t offset, uint32_t status)
 : block_start(start), block_offset(offset), block_status(status) {}

istream::istream(std::istream &src)
 : m_istr(src),
   m_status_bits(0)
{
   char hdr[10];
   src.getline(hdr,7);
   m_documentString = hdr;
   if (m_documentString != "<HDDM ") {
      throw std::runtime_error("hddm_s::istream::istream error - invalid hddm header");
   }
   src.clear();
   std::string line;
   while (std::getline(src,line).good()) {
      m_documentString += line + "\n";
      if (line == "</HDDM>") {
         break;
      }
   }
   if (src.bad()) {
      throw std::runtime_error("hddm_s::istream::istream error - invalid hddm header");
   }
   pthread_mutex_init(&m_streambuf_mutex,0);
   for (int i=0; i<threads::max_threads; ++i) {
      my_thread_private[i] = 0;
   }
   m_leftovers[0] = 0;
   init_private_data();
}

istream::~istream() {
   pthread_mutex_destroy(&m_streambuf_mutex);
   for (int i=0; i<threads::max_threads; ++i) {
      thread_private_data *my_private = my_thread_private[i];
      if (my_private != 0) {
         if (MY(istr))
            delete MY(istr);
         if (MY(xcmp))
            delete MY(xcmp);
         if (MY(xstr))
            delete MY(xstr);
         if (MY(sbuf))
            delete MY(sbuf);
         delete [] MY(event_buffer);
         delete my_private;
      }
   }
}

void istream::init_private_data() {
   int threadID = threads::getID();
   if (my_thread_private[threadID] == 0) {
      my_thread_private[threadID] = new thread_private_data;
   }
   MY_SETUP
   MY(genome).m_tagname = "HDDM";
   MY(genome).m_sequence = synthesize(m_documentString,0,HDDM::DocumentString(),0);
   MY(event_buffer) = new char[MY(event_buffer_size) = 100000];
   MY(sbuf) = new istreambuffer(MY(event_buffer),MY(event_buffer_size));
   MY(xstr) = new xstream::xdr::istream(MY(sbuf));
   MY(istr) = new std::istream(m_istr.rdbuf());
   MY(xcmp) = 0;
   MY(event_size) = 0;
   MY(last_start) = 0;
   MY(last_offset) = 0;
   MY(next_start) = 0;
   MY(events_to_skip) = 0;
   MY(status_bits) = 0;
   MY(mutex_lock) = 0;
   MY(bytes_read) = 0;
   MY(records_read) = 0;
   MY(sequencing) = 0;
   MY(hit_eof) = 0;
}

streamposition istream::getPosition() {
   MY_SETUP
   streamposition pos;
   pos.block_start = MY(last_start);
   pos.block_offset = MY(last_offset);
   pos.block_status = MY(status_bits);
   return pos;
}

void istream::setPosition(const streamposition &pos) {
   MY_SETUP
   m_status_bits = pos.block_status;
   lock_streambufs();
   update_streambufs();
   unlock_streambufs();
   if (MY(status_bits) & (k_bz2_compression | k_z_compression)) {
      if (((int)m_status_bits & k_bits_compression) != 0 &&
          ((int)m_status_bits & k_can_reposition) == 0)
      {
         throw std::runtime_error("hddm_s::istream::setPosition error - "
                                  "old-format hddm input file does not support repositioning.");
      }
      else if (MY(xcmp) == 0) {
         throw std::runtime_error("hddm_s::istream::setPosition error - "
                                  "compressed stream encountered but no decompressor configured.");
      }
      if (MY(status_bits) & k_z_compression) {
         ((xstream::z::istreambuf*)MY(xcmp))->
             set_new_position(pos.block_start, pos.block_offset);
      }
      else if (MY(status_bits) & k_bz2_compression) {
         ((xstream::bz::istreambuf*)MY(xcmp))->
             set_new_position(pos.block_start, pos.block_offset);
      }
   }
   else {
      MY(next_start) = pos.block_start;
   }
}

void istream::update_streambufs() {
   MY_SETUP
   if ((int)m_status_bits != MY(status_bits)) {
      configure_streambufs();
   }
}

void istream::configure_streambufs() {
   MY_SETUP
   int oldcmp = MY(status_bits) & k_bits_compression;
   int newcmp = (int)m_status_bits & k_bits_compression;
   if (oldcmp != newcmp) {
      if (oldcmp != k_no_compression) {
         MY(istr)->rdbuf(m_istr.rdbuf());
         delete MY(xcmp);
         MY(xcmp) = 0;
      }
      if (newcmp == k_z_compression) {
         //std::cerr << "input switched on z compression" << std::endl;
         MY(xcmp) = new xstream::z::istreambuf(m_istr.rdbuf(), m_leftovers,
                                                        sizeof(m_leftovers));
         MY(istr)->rdbuf(MY(xcmp));
      }
      else if (newcmp == k_bz2_compression) {
         //std::cerr << "input switched on bz2 compression" << std::endl;
         MY(xcmp) = new xstream::bz::istreambuf(m_istr.rdbuf(), m_leftovers,
                                                         sizeof(m_leftovers));
         MY(istr)->rdbuf(MY(xcmp));
      }
      else if (newcmp != k_no_compression) {
         throw std::runtime_error("hddm_s::istream::configure_streambufs error - "
                                  "unrecognized compression flag requested.");
      }
   }
   MY(status_bits) = m_status_bits;
}

void istream::lock_streambufs() {
   MY_SETUP
   if (MY(mutex_lock) != 0) {
      unlock_streambufs();
      throw std::runtime_error("hddm_s::istream::lock_streambufs error - "
                               "mutex lock requested when lock already held.");
   }
   if ((MY(status_bits) & k_bits_compression) == k_no_compression) {
      pthread_mutex_lock(&m_streambuf_mutex);
      MY(mutex_lock) = 1;
   }
   else if ((MY(status_bits) & k_bits_compression) == k_z_compression) {
      ((xstream::z::istreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);
      MY(mutex_lock) = 2;
   }
   else if ((MY(status_bits) & k_bits_compression) == k_bz2_compression) {
      ((xstream::bz::istreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);
      MY(mutex_lock) = 3;
   }
   else {
      MY(mutex_lock) = -1;
   }
}

void istream::unlock_streambufs() {
   MY_SETUP
   if (MY(mutex_lock) == 0) {
      throw std::runtime_error("hddm_s::istream::unlock_streambufs error - "
                               "mutex unlock requested when lock not held.");
   }
   else if (MY(mutex_lock) == 1) {
      pthread_mutex_unlock(&m_streambuf_mutex);
   }
   else if (MY(mutex_lock) == 2) {
      ((xstream::z::istreambuf*)MY(xcmp))->set_streambuf_mutex(0);
   }
   else if (MY(mutex_lock) == 3) {
      ((xstream::bz::istreambuf*)MY(xcmp))->set_streambuf_mutex(0);
   }
   MY(mutex_lock) = 0;
}

istream &istream::operator>>(HDDM &record) {
   MY_SETUP
   while (1 == 1) {
      lock_streambufs();
      MY(event_size) = 0;
      while (MY(event_size) == 0) {
         update_streambufs();
         if (MY(status_bits) & (k_bz2_compression | k_z_compression)) {
            if (MY(status_bits) & k_can_reposition) {
               MY(istr)->clear();
               MY(istr)->read(MY(event_buffer),4);
               MY(bytes_read) += MY(istr)->gcount();
               if (!MY(istr)->good()) {
                  unlock_streambufs();
                  MY(hit_eof) = 1;
                  return *this;
               }
               if (MY(status_bits) & k_bz2_compression) {
                  MY(last_start)  = dynamic_cast<xstream::bz::istreambuf*>
                                    (MY(xcmp))->get_block_start();
                  MY(last_offset) = dynamic_cast<xstream::bz::istreambuf*>
                                    (MY(xcmp))->get_block_offset();
               }
               else {
                  MY(last_start)  = dynamic_cast<xstream::z::istreambuf*>
                                    (MY(xcmp))->get_block_start();
                  MY(last_offset) = dynamic_cast<xstream::z::istreambuf*>
                                    (MY(xcmp))->get_block_offset();
               }
               MY(last_offset) -= 4;
            }
            else {
               MY(last_start) = 0;
               MY(last_offset) = 0;
            }
         }
         else {
            if (MY(next_start) > 0) {
               m_istr.seekg(MY(next_start), std::ios_base::beg);
               MY(istr)->clear();
               MY(last_start) = MY(next_start);
               MY(last_offset) = 0;
               MY(next_start) = 0;
            }
            else {
               MY(last_start) = m_istr.tellg();
               MY(last_offset) = 0;
            }
            MY(istr)->read(MY(event_buffer),4);
            MY(bytes_read) += MY(istr)->gcount();
            if (!MY(istr)->good()) {
               unlock_streambufs();
               MY(hit_eof) = 1;
               return *this;
            }
         }
         MY(hit_eof) = 0;
         MY(sbuf)->reset();
         *MY(xstr) >> MY(event_size);
         if (MY(event_size) == 1) {
            MY(istr)->read(MY(event_buffer)+4,4);
            MY(bytes_read) += MY(istr)->gcount();
            if (!MY(istr)->good()) {
               unlock_streambufs();
               throw std::runtime_error("hddm_s::istream::operator>> error -"
                                        " read error on token input!");
            }
            int size;
            *MY(xstr) >> size;
            MY(istr)->read(MY(event_buffer)+8,size);
            MY(bytes_read) += MY(istr)->gcount();
            if (!MY(istr)->good()) {
               unlock_streambufs();
               throw std::runtime_error("hddm_s::istream::operator>> error -"
                                        " read error on token input!");
            }
            int format, flags;
            *MY(xstr) >> format >> flags;
            if (format != 0) {
               unlock_streambufs();
               throw std::runtime_error("hddm_s::istream::operator>> error - "
                                        "unsupported compression format!");
            }
            m_status_bits.store(flags);
            MY(event_size) = 0;
         }
      }
      if (MY(event_size)+8 > MY(event_buffer_size)) {
         delete MY(xstr);
         delete MY(sbuf);
         char *newbuf = new char[MY(event_buffer_size) = MY(event_size)+1000];
         MY(sbuf) = new istreambuffer(newbuf, MY(event_buffer_size));
         MY(xstr) = new xstream::xdr::istream(MY(sbuf));
         memcpy(newbuf,MY(event_buffer),4);
         delete [] MY(event_buffer);
         MY(event_buffer) = newbuf;
      }
      MY(istr)->read(MY(event_buffer)+4,MY(event_size));
      MY(bytes_read) += MY(istr)->gcount();
      MY(records_read)++;
      if (!MY(istr)->good()) {
         unlock_streambufs();
         throw std::runtime_error("hddm_s::istream::operator>> error -"
                                  " read error in mid-record!");
      }
      if ((MY(status_bits) & k_crc32_integrity) != 0) {
         unsigned int recorded_crc;
         char crcbuf[10];
         istreambuffer sbuf(crcbuf,10);
         xstream::xdr::istream xstr(&sbuf);
         MY(istr)->read(crcbuf,4);
         MY(bytes_read) += MY(istr)->gcount();
         xstr >> recorded_crc;
         xstream::digest::crc32 crc;
         std::ostream out(&crc);
         out.write(MY(event_buffer),MY(event_size)+4);
         out.flush();
         if (crc.digest() != recorded_crc) {
            char errmsg[] = 
                 "WARNING: crc data integrity check failed"
                 " on hddm_s input stream!"
                 "\nThis may be the result of a bug in the"
                 " xstream library if you are analyzing a data"
                 " file that was generated by code prior to svn"
                 " rev 18530.\nIf this concerns you, regenerate"
                 " using a newer build of the sim-recon tools"
                 " and it should go away.\n";
            if ((MY(status_bits) & 0x02) == 0) {
               std::cerr << errmsg << std::endl;
               MY(status_bits) |= 0x02;
            }
            //unlock_streambufs();
            //throw std::runtime_error("hddm_s::istream::operator>> error -"
            //                 " crc check error on input stream!");
         }
      }
      unlock_streambufs();
      if (MY(events_to_skip) > 0) {
         --MY(events_to_skip);
      }
      else {
         break;
      }
   }
   MY(sbuf)->reset();
   MY(sequencing) = 0;
   MY(codon) = &MY(genome);
   *this >> (streamable&)record;
   return *this;
}

ostream::ostream(std::ostream &src)
 : m_ostr(src),
   m_status_bits(k_default_status)
{
   m_ostr << HDDM::DocumentString();
   if (!m_ostr.good()) {
      throw std::runtime_error("hddm_s::ostream::ostream(ostream) "
                               "error - write error on header output!");
   }
   pthread_mutex_init(&m_streambuf_mutex,0);
   for (int i=0; i<threads::max_threads; ++i) {
      my_thread_private[i] = 0;
   }
   init_private_data();
}

ostream::~ostream() {
   pthread_mutex_destroy(&m_streambuf_mutex);
   for (int i=0; i<threads::max_threads; ++i) {
      thread_private_data *my_private = my_thread_private[i];
      if (my_private != 0) {
         if (MY(xstr)) {
            delete MY(xstr);
         }
         if (MY(sbuf)) {
            delete MY(sbuf);
         }
         if (MY(xcmp)) {
            MY(xcmp)->pubsync();
            MY(ostr)->rdbuf(m_ostr.rdbuf());
            delete MY(xcmp);
         }
         if (MY(ostr)) {
            MY(ostr)->flush();
            delete MY(ostr);
         }
         delete [] MY(event_buffer);
         delete my_private;
      }
   }
}

void ostream::init_private_data() {
   int threadID = threads::getID();
   if (my_thread_private[threadID] == 0) {
      my_thread_private[threadID] = new thread_private_data;
   }
   MY_SETUP
   MY(event_buffer) = new char[MY(event_buffer_size) = 100000];
   MY(sbuf) = new ostreambuffer(MY(event_buffer),MY(event_buffer_size));
   MY(xstr) = new xstream::xdr::ostream(MY(sbuf));
   MY(ostr) = new std::ostream(m_ostr.rdbuf());
   MY(xcmp) = 0;
   MY(last_start) = 0;
   MY(last_offset) = 0;
   MY(records_written) = 0;
   MY(bytes_written) = 0;
   MY(status_bits) = 0;
   MY(mutex_lock) = 0;
}

void ostream::setCompression(int flags) {
   MY_SETUP
   int oldcmp = (int)m_status_bits & k_bits_compression;
   int newcmp = flags & k_bits_compression;
   if (oldcmp != newcmp) {
      m_status_bits.fetch_and(~k_bits_compression | flags);
      m_status_bits.fetch_or(k_bits_compression & flags);
      if (newcmp != 0)
         m_status_bits.fetch_or(k_can_reposition);
      MY(sbuf)->reset();
      *MY(xstr) << 1 << 8 << 0 << (int)m_status_bits;
      lock_streambufs();
      MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());
      if (!MY(ostr)->good()) {
         unlock_streambufs();
         throw std::runtime_error("hddm_s::ostream::setCompression"
                                  " error - write error on token output!");
      }
      MY(ostr)->flush();
      update_streambufs();
      unlock_streambufs();
   }
}

void ostream::setIntegrityChecks(int flags) {
   MY_SETUP
   int oldint = (int)m_status_bits & k_bits_integrity;
   int newint = flags & k_bits_integrity;
   if (oldint != newint) {
      m_status_bits.fetch_and(~k_bits_integrity | flags);
      m_status_bits.fetch_or(k_bits_integrity & flags);
      MY(sbuf)->reset();
      *MY(xstr) << 1 << 8 << 0 << (int)m_status_bits;
      lock_streambufs();
      MY(ostr)->write(MY(sbuf)->getbuf(),MY(sbuf)->size());
      if (!MY(ostr)->good()) {
         unlock_streambufs();
         throw std::runtime_error("hddm_s::ostream::setIntegrityChecks"
                                 " error - write error on token output!");
      }
      MY(ostr)->flush();
      update_streambufs();
      unlock_streambufs();
   }
}

streamposition ostream::getPosition() {
   MY_SETUP
   streamposition pos;
   pos.block_start = MY(last_start);
   pos.block_start = MY(last_offset);
   pos.block_status = MY(status_bits);
   return pos;
}

void ostream::update_streambufs() {
   MY_SETUP
   if ((int)m_status_bits != MY(status_bits)) {
      configure_streambufs();
   }
}

void ostream::configure_streambufs() {
   MY_SETUP
   int oldcmp = MY(status_bits) & k_bits_compression;
   int newcmp = (int)m_status_bits & k_bits_compression;
   if (oldcmp != newcmp) {
      if (oldcmp != k_no_compression) {
         MY(ostr)->rdbuf(m_ostr.rdbuf());
         delete MY(xcmp);
         MY(xcmp) = 0;
      }
      if (newcmp == k_z_compression) {
         //std::cerr << "output switched on z compression" << std::endl;
         MY(xcmp) = new xstream::z::ostreambuf(m_ostr.rdbuf());
         MY(ostr)->rdbuf(MY(xcmp));
      }
      else if (newcmp == k_bz2_compression) {
         //std::cerr << "output switched on bz2 compression" << std::endl;
         MY(xcmp )= new xstream::bz::ostreambuf(m_ostr.rdbuf());
         MY(ostr)->rdbuf(MY(xcmp));
      }
      else if (newcmp != k_no_compression) {
         throw std::runtime_error("hddm_s::ostream::configure_streambufs error - "
                                  "unrecognized compression flag requested.");
      }
   }
   MY(status_bits) = m_status_bits;
}

void ostream::lock_streambufs() {
   MY_SETUP
   if (MY(mutex_lock) != 0) {
      unlock_streambufs();
      throw std::runtime_error("hddm_s::ostream::lock_streambufs error - "
                               "mutex lock requested when lock already held.");
   }
   if ((MY(status_bits) & k_bits_compression) == k_no_compression) {
      pthread_mutex_lock(&m_streambuf_mutex);
      MY(mutex_lock) = 1;
   }
   else if ((MY(status_bits) & k_bits_compression) == k_z_compression) {
      ((xstream::z::ostreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);
      MY(mutex_lock) = 2;
   }
   else if ((MY(status_bits) & k_bits_compression) == k_bz2_compression) {
      ((xstream::bz::ostreambuf*)MY(xcmp))->set_streambuf_mutex(&m_streambuf_mutex);
      MY(mutex_lock) = 3;
   }
   else {
      MY(mutex_lock) = -1;
   }
}

void ostream::unlock_streambufs() {
   MY_SETUP
   if (MY(mutex_lock) == 0) {
      throw std::runtime_error("hddm_s::ostream::unlock_streambufs error - "
                               "mutex unlock requested when lock not held.");
   }
   else if (MY(mutex_lock) == 1) {
      pthread_mutex_unlock(&m_streambuf_mutex);
   }
   else if (MY(mutex_lock) == 2) {
      ((xstream::z::ostreambuf*)MY(xcmp))->set_streambuf_mutex(0);
   }
   else if (MY(mutex_lock) == 3) {
      ((xstream::bz::ostreambuf*)MY(xcmp))->set_streambuf_mutex(0);
   }
   MY(mutex_lock) = 0;
}

int istream::getTag(const std::string &src, int start,
                    std::string &tag, int &level)
{
   tag = "";
   size_t p_btag = src.find("<",start);
   size_t p_bline = src.find_last_of("\n",p_btag);
   if (p_bline == std::string::npos)
   {
      p_bline = 0;
   }
   else
   {
      ++p_bline;
   }
   level = (p_btag-p_bline)/2;
   size_t p_etag = p_btag;
   for (size_t quotes=0; p_etag < src.size(); ++p_etag) {
      if (src[p_etag] == '"') {
         tag += "\"";
         ++quotes;
      }
      else if (quotes/2*2 != quotes) {
         tag += src[p_etag];
      }
      else if (src.find_first_of(" \t\n",p_etag) == 0) {
         tag += " ";
         p_etag = src.find_first_not_of(" \t\n",p_etag)-1;
      }
      else if (src[p_etag] == '>') {
         tag += ">";
         break;
      }
      else {
         tag += src[p_etag];
      }
   }
   if (p_etag == src.size()) {
      std::stringstream sstr;
      sstr << "hddm_s::istream::getTag"
           << " error - bad header format" << std::endl
           << "   tag " << tag << " at position " << start
           << std::endl;
      throw std::runtime_error(sstr.str());
   }
   return p_etag+2;
}

int istream::getEndTag(const std::string &src, int start,
                       const std::string &tag)
{
   if (tag.rfind("/>") == tag.size()-2) {
      return src.find(tag,start) + tag.size()+1;
   }
   else {
      std::string etag = "</";
      etag += tag.substr(1,tag.find_first_of(' ')-1) + ">";
      size_t p_etag = src.find(etag,start);
      size_t p_quote = src.find_first_of('"',start);
      while (p_quote != std::string::npos && p_quote < p_etag) {
         p_quote = src.find_first_of('"',p_quote+1);
         if (p_quote > p_etag) {
            p_etag = src.find(etag,p_quote+1);
         }
         p_quote = src.find_first_of('"',p_quote+1);
      }
      if (p_etag == std::string::npos) {
         std::stringstream sstr;
         sstr << "hddm_s::istream::getEndTag"
              << " error - bad header format" << std::endl
              << "   tag " << tag << " at position " << start
              << std::endl
              << "   end tag " << etag << " not found."
              << std::endl;
         throw std::runtime_error(sstr.str());
      }
      return p_etag + etag.size()+1;
   }
}

void istream::collide(const std::string &itag, const std::string &rtag) {
   std::string itagname = itag.substr(1,itag.find(" ")-1);
   std::string rtagname = rtag.substr(1,rtag.find(" ")-1);
   std::string errmsg = "hddm_s::istream::collide warning:\n"
         "tag " + itagname + " in input file "
         "does not match c++ header hddm_s.hpp\n"
         "  input file: " + itag + "\n"
         "  c++ header: " + rtag + "\n"
         "  === Tag " + itagname + " will be ignored,"
         " rebuild to cure the problem ===";
   if (itagname != "HDDM") {
      std::cerr << errmsg << std::endl;
   }
   else {
      throw std::runtime_error(errmsg);
   }
}

chromosome istream::synthesize(const std::string &src, int p_src,
                               const std::string &ref, int p_ref)
{
   chromosome chrom;
   int slevel, rlevel;
   std::string stag, rtag;
   p_src = getTag(src,p_src,stag,slevel);
   p_ref = getTag(ref,p_ref,rtag,rlevel);
   std::string stagname = stag.substr(1,stag.find(" ")-1);
   std::string rtagname = rtag.substr(1,rtag.find(" ")-1);
   if (stagname != rtagname) {
      throw std::runtime_error("hddm_s::istream::synthesize error - matching algorithm error #2");
   }
   else if (!tags_match(stag,rtag)) {
      collide(stag,rtag);
      return chrom;
   }

   int p2_src, p2_ref;
   int s2level, r2level;
   std::string s2tag, r2tag;
   getTag(src,p2_src=p_src,s2tag,s2level);
   while (s2level > slevel) {
      codon *gene = new codon();
      std::string s2tagname = s2tag.substr(1,s2tag.find(" ")-1);
      getTag(ref,p2_ref=p_ref,r2tag,r2level);
      int order_of_this_tag_in_ref = 1;
      while (r2level == s2level) {
         std::string r2tagname = r2tag.substr(1,r2tag.find(" ")-1);
         if (s2tagname == r2tagname) {
            if (!tags_match(s2tag,r2tag)) {
               collide(s2tag,r2tag);
               break;
            }
            else {
               gene->m_order = order_of_this_tag_in_ref;
            }
            gene->m_sequence = synthesize(src,p2_src,ref,p2_ref);
            break;
         }
         p2_ref = getEndTag(ref,p2_ref,r2tag);
         getTag(ref,p2_ref,r2tag,r2level);
         ++order_of_this_tag_in_ref;
      }
      gene->m_tagname = s2tagname;
      chrom.push_back(*gene);
      delete gene;
      p2_src = getEndTag(src,p2_src,s2tag);
      getTag(src,p2_src,s2tag,s2level);
   }
   return chrom;
}
